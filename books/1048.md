# 分解与规范化

##  2.6.1 关系模式的规范化

Ø  关系模式的规范化实际上就是通过模式分解将一个较低范式的关系模式转化为多个较高范式的关系模式的过程。

​     从范式变化的角度看，关系模式的规范化是一个不断增加约束条件的过程；

​     从关系模式变化的角度看，规范化是关系模式的一个逐步分解的过程。

Ø  关系模式的分解是关系模式规范化的本质问题，其目的是实现概念的单一化，即使得一个关系仅描述一个概念或概念间的一个种联系。通过分解可以将一个关系模式分成多个满足更高要求的关系模式，这些关系模式可以在一定程度上解决或缓解数据冗余、更新异常、插入异常、删除异常等问题。

Ø  关系模式分解实际上又是一个关系模式的属性投影和属性重组的过程，又称投影分解。投影和重组的基本指导思想是逐步消除数据依赖中不适合的成分，结果将产生多个属于更高级别范式的关系模式。

 

u 投影分解的步骤就是低级范式到高级范式转化的步骤，具体步骤是：

Ø 基于消除关系模式中非主属性对候选码的函数依赖的原则，对1NF关系模式进行合理的投影（属性重组），结果将产生多个2NF关系模式。 

Ø 基于消除关系模式中非主属性对候选码的传递函数依赖的原则，对2NF关系模式进行合理的投影，结果将产生多个3NF关系模式。 

Ø 基于消除关系模式中主属性对候选码的传递函数依赖的原则，对3NF关系模式进行合理的投影，结果将产生多个BCNF关系模式。

 

 

## 2.6.2 关系模式的分解

•             连接无损分解

​    定义2.12   假设一个关系模式*R*(*U*)被分解成*n*个子关系模式：*R*1(*U*1),*R*2(*U*2),…, *Rn*(*Un*)，其中*U* =*R*1(*U*1)∪*R*2(*U*2)∪…∪*Rn*(*Un*)，并假设*r*, *r*1, *r*2,…, *rn*分别属于关系模式*R*(*U*)及*n*个子关系模式的关系（二维表），如果这*n*个子关系的自然连接与原关系*r*相等，即r = r1 ⋈  r2 ⋈    …   ⋈ rn，那么这种分解称为（自然）连接无损分解，其中ri是r在Ui上的投影, i = 1,2,…n。

Ø  分解的基本思想之一是消除对候选码的部分函数依赖和传递函数依赖。我们可以先在待分解的关系模式中找出这些部分函数依赖和传递函数依赖以及完全函数依赖，然后“分解”部分函数依赖和传递函数依赖，使得这些函数依赖最终都变成完全函数依赖，最后将这些完全函数依赖所涉及的属性分别投影成新的关系即可。

​     

 

   【例2.14】对于例2.6中的关系模式SSC(学号, 姓名, 系别, 导师工号, 导师姓名, 导师职称, 课程名称, 课程成绩)，请运用模式分解方法将其转化为若干个属于BC范式的关系模式。

Ø 关系模式SSC中唯一的候选码为{学号, 课程名称}。我们先找出对候选码的所有完全函数依赖、部分函数依赖和传递函数依赖：

•    {学号, 课程名称}     课程成绩

•    {学号, 课程名称}     {姓名, 系别}

•    {学号, 课程名称}     导师工号

•    导师工号      {导师姓名, 导师职称}

•    {学号, 课程名称}      {导师姓名, 导师职称}

 

 

 

 

u 以下找出部分函数依赖中的完全函数依赖：

​    由“{学号, 课程名称}      {姓名, 系别}”得到“学号      {姓名, 系别}”

​    由“{学号, 课程名称}     导师工号 ”得到“学号      导师工号”

u 我们根据以上所有的完全函数依赖初步设定分解成的各关系模式（原则是“一个完全函数依即为一个关系模式”）：

Ø T1(学号, 课程名称, 课程成绩)

Ø T2(导师工号, 导师姓名, 导师职称)

Ø T3(学号, 姓名, 系别)

Ø T4(学号, 导师工号)

 

 

 

u 为了减少数据冗余和减少数据维护的复杂性，可以将关系模式T4(学号, 导师工号)并到T3(学号, 姓名, 系别)中，从而形成新的关系模式——T3′(学号, 姓名, 系别, 导师工号)。这样，就得到如下的分解结果：

Ø T1(学号, 课程名称, 课程成绩)

Ø T2(导师工号, 导师姓名, 导师职称)

Ø T3′(学号, 姓名, 系别, 导师工号)

u 由定理2.3稍加分析可以知道，以上三个关系模式均属于BC范式，而且上述的分解是连接无损分解。

 

 

​       定理2.4   假设S和T为关系模式R分解后所得到的两个关系模式，则该分解为连接无损分解的充分必要条件是：(S∩T) → (S-T)或(S∩T) → (T-S)

 

 

\2. 保持函数依赖的分解

​      定义2.13   设*R*(*U*)是一个关系模式，*F*为*R*(*U*)的一个函数依赖集，*B*,*C*为*R*(*U*)所涉及的属性集的子集。如果利用Armstrong公理系统中的推理规则能够从函数依赖集*F*中推出*B*→*C*，则称*F*逻辑蕴涵*B*→*C*。*F*所逻辑蕴涵的函数依赖的集合称为*F*的闭包，记为*F*+。

​      定义2.14   设一个关系模式*R*(*U*)被分解成*n*个关系模式：*R*1, *R*2,…, *Rn*，*F*为*R*(*U*)的属性间函数依赖的集合，*F*1, *F*2,…, *Fn*分别为*F*在*R*1, *R*2,…, *Rn*上的投影。对于任意*F*所逻辑蕴涵的函数依赖*B*→*C*，总存在某一个*Fi*，使得*Fi*逻辑蕴涵*B*→*C*，则这种分解称为保持函数依赖的分解。 

 

 

\3. 既保持函数依赖又具有自然连接无损的分解

Ø 连接无损分解和保持函数依赖的分解是两个相互独立的模式分解。但它们的优缺点具有一定的互补性。

Ø 连接无损分解可以保证分解所得到的关系模式经过自然连接后又得到原关系模式，不会造成信息的丢失。这种分解可能带来数据冗余、更新冲突等问题。

​     原因：连接无损分解不是按照关系模式所蕴涵数据语义来进行分解。而保持函数依赖的分解则正好是按照数据语义来进行分解，它可以使分解后的关系模式相互独立。避免由连接无损分解带来的问题，但它在某些情况下可能造成信息丢失。一个自然的想法就是构造这样的分解：该分解既是保持函数依赖的分解，又具有自然连接无损的特性。这种分解就称为既保持函数依赖又具有自然连接无损的分解。

 

 

​     【例2.15】  考虑例2.10中的关系模式：emp_info(Eno, Ename, Dept, Dleader)

Ø Eno为员工编号，Ename为员工姓名，Dept为员工所在部门，Dleader为部门领导。如果将该关系模式分解为：emp_info1(Eno, Ename, Dept)和emp_info2(Eno, Dleader)。易验证，这种分解虽然是连接无损分解，但会造成数据冗余、更新异常等问题。进一步分析还可以发现，该分解不保持函数依赖。例如，函数依赖Dept→Dleader既不被emp_info1的函数依赖集所逻辑蕴涵，也不为emp_info2的函数依赖集所逻辑蕴涵。

Ø 现在我们将关系模式emp_info(Eno, Ename, Dept, Dleader)分解成如下的两个模式：

​          emp_info2(Eno, Ename, Dept)

​          dept_info2(Dept, Dleader)

Ø 可以验证，这种分解方法保持了函数依赖，同时又具有自然连接无损的特性，它是既保持函数依赖又具有自然连接无损的分解。

 

 