{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 "},"page/11014.html":{"url":"page/11014.html","title":"基础","keywords":"","body":"基础 SQL语言的功能包括数据查询、数据操纵、数据定义和数据控制4部分。 SQL语言简洁、方便、实用，为完成其核心功能只用了6个动词：SELECT、CREATE、INSERT、UPDATE、DELETE、GRANT（REVOKE），目前已成为应用最广的关系数据库语言。 SQL语言易学易用，作为关系数据库的标准语言，它已被众多商用数据库管理系统产品所采用。不过，因为不同的数据库管理系统在其实践过程中都对SQL规范做了某些编改和扩充，所以，实际上不同数据库管理系统之间的SQL语言不能完全通用。例如，微软公司的SQL Server数据库系统支持的是Transact-SQL（简称T-SQL），而甲骨文公司的Oracle 数据库所使用的SQL语言则是PL-SQL。 "},"page/11015.html":{"url":"page/11015.html","title":"发展","keywords":"","body":"发展 SQL语言的发展 　　1974年由Boyce和Chamberlin最初提出， 　　1979年被IBM公司在其关系数据库系统System R上首先予以实现。 　　1986年10月，美国国家标准化学会（ANSI, American National Standards Institute）公布了第一个SQL标准，称为SQL-86。 　　1987年6月，国际标准化组织（ISO, International Standards Organization）也接纳了这一标准，并对其作进一步的完善。完善工作于1989年4月完成，结果形成了所谓的SQL-89标准。 　　在SQL-89标准的基础上，ISO和ANSI联手对SQL进行研究和完善，于1992年8月又推出了新的SQL标准——SQL-92（SQL2），1999年推出SQL-99（SQL3），2003年进一步被扩充为SQL-2003，使其兼容XML语言。 　　如今，几乎所有的数据库产品厂商都推出了各自的支持SQL语言的关系数据库软件产品，如DB2、Oracle、SQL Server等，或者提供了支持SQL语言的接口。 　　除了SQL以外，还有其他类似的一些数据库语言，如QBE、Quel、Datalog等，但这些语言仅限于少数专业的数据库研究人员使用，并不是主流语言。事实上，SQL是迄今为止最受欢迎的关系数据库语言之一，目前还没有出现能够与之相媲美的同类语言。 "},"page/11261.html":{"url":"page/11261.html","title":"SQL","keywords":"","body":"SQL SQL是Structured Query Language的缩写，译为“结构化查询语言”，它是关系数据库的标准语言。 按功能划分，SQL语言可以分为四类： 数据查询语言（Data Query Language, DQL） 数据定义语言（Data Definition Language, DDL） 数据操纵语言（Data Manipulation Language, DML） 数据控制语言（Data Control Language, DCL） SQL语言的发展 1974年由Boyce和Chamberlin最初提出， 1979年被IBM公司在其关系数据库系统System R上首先予以实现。 1986年10月，美国国家标准化学会（ANSI, American National Standards Institute）公布了第一个SQL标准，称为SQL-86。 1987年6月，国际标准化组织（ISO, International Standards Organization）也接纳了这一标准，并对其作进一步的完善。完善工作于1989年4月完成，结果形成了所谓的SQL-89标准。 在SQL-89标准的基础上，ISO和ANSI联手对SQL进行研究和完善，于1992年8月又推出了新的SQL标准——SQL-92（SQL2），1999年推出SQL-99（SQL3），2003年进一步被扩充为SQL-2003，使其兼容XML语言。 如今，几乎所有的数据库产品厂商都推出了各自的支持SQL语言的关系数据库软件产品，如DB2、Oracle、SQL Server等，或者提供了支持SQL语言的接口。 除了SQL以外，还有其他类似的一些数据库语言，如QBE、Quel、Datalog等，但这些语言仅限于少数专业的数据库研究人员使用，并不是主流语言。事实上，SQL是迄今为止最受欢迎的关系数据库语言之一，目前还没有出现能够与之相媲美的同类语言。 SQL语言的特点 SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，是一种通用的、功能强大而又简单易学的关系数据库语言 特点： （1）高度非过程化语言 非关系数据模型的数据操纵语言都是面向过程的语言，在使用时必须指定存储路径。SQL是一种高度非过程化的语言，它一次执行一条命令，对数据提供自动导航。SQL不要求用户指定对数据的存放方法，只要求用户提出要“干什么”，至于“怎么干”，用户就不用管了，而由系统自动完成。 （2）统一的数据库操作语言 SQL语言风格统一，用于创建数据库、定义关系模式、完成数据的查询、修改、删除、控制等操作。为数据库应用系统的开发提供了良好的环境。在数据库投入运行以后，可以使用SQL语言实现数据库重构，在一定程度上满足用户不断发展的需求，同时不影响数据库的正常运行，使数据库系统具有良好的可扩展性。 （3）关系数据库的标准语言 SQL成为国际标准以后，由于绝大多数的数据库厂商都支持SQL，所以SQL可以用于各类数据库管理系统，从而使它成为关系数据库的标准语言。所有用SQL编写的程序都是可以在不同的系统中移植，同时也结束了数据库查询语言“各自为政的分割局面”。 （4）面向集合的数据操纵语言 非关系数据模型的数据操纵语言一般是面向记录进行操作的，即每一次操作都是针对一条记录进行的。如果要对多条记录操作，则必须循环进行。而SQL则面向集合的方式进行操作，即每一次操作是针对所有满足条件的元组组成的集合进行，操作所产生的结果也是元组的集合。 （5）可嵌入式的数据库语言 ​ SQL语言不但可以在交互方式下以命令的形式执行，还可以嵌入到其他的高级语言中。在交互方式下，用户可以在终端键盘上直接键入SQL命令对数据库进行操作；作为可嵌入式的数据库语言，SQL语言可嵌入到像C、COBOL、FORTRAN、VB、PowerBuilder、Delphi等这种高级语言中，通过程序调用来实现对数据库的操作。不管是在交互方式下还是在嵌入方式下，SQL语言的语法结构基本上都一样，这使得对数据库的操作变得更为灵活和方便 （6）简单易学 ​ SQL语言的语法结构比较简单，调用格式非常简洁。所使用命令的核心关键字才包括9个：CREATE、ALTER、DROP、GRANT、REVOKE、SELECT、INSERT、UPDATE、DELETE 。而且其语法接近英语口语，方便理解和记忆。 SQL的基本功能 四大功能介绍： （1）数据查询功能 通过SELECT语句完成。SELECT语句的功能非常强大，表达形式非常丰富，可以完成很多复杂的查询任务。SQL语言的最初设计就是用于数据查询，这也是它之所以称为“结构查询语言（Structured Query Language）”的主要原因。 （2）数据操纵功能 通过INSERT、UPDATE、DELETE 语句完成。INSERT、UPDATE、DELETE 语句分别用于实现数据插入、数据更新和数据删除功能。 （3）数据定义功能 通过CREATE、ALTER、DROP语句来完成。CREATE、ALTER、DROP语句分别用于定义、修改和删除数据库和数据库对象，这些数据库对象包括数据表、视图等。 （4）数据控制功能 通过GRANT、REVOKE语句来完成。数据控制主要是指事务管理、数据保护（包括数据库的恢复、并发控制等）以及数据库的安全性和完整性控制。 SQL功能与SQL语句的对应关系 SQL功能 SQL语句 数据查询（DQL） SELECT 数据操纵（DML） INSERT、UPDATE、DELETE 数据定义（DDL） CREATE、ALTER、DROP 数据控制（DCL） GRANT、REVOKE "},"page/11127.html":{"url":"page/11127.html","title":"MSSQL","keywords":"","body":"Transact-SQL ​ SQL语句只能按照既定的顺序执行，在执行过程中不能根据某些中间结果有选择地或循环地执行某些语句块，不能像高级程序语言那样进行流程控制。为此，微软公司在SQL语言的基础上添加了流程控制语句，从而得到一种结构化程序设计语言——Transact-SQL。 　　Transact-SQL即事务SQL，也简写为T-SQL，它是微软公司对关系数据库标准语言SQL进行扩充的结果，是SQL语言的超集。Transact-SQL支持所有的标准SQL语言操作。 　　作为一种标准的关系数据库语言，SQL几乎可以在所有的关系数据库上使用。但由于Transact-SQL是微软对SQL扩充的结果，所以只有SQL Server支持Transact-SQL，而其他关系数据库（如Access、Oracle等）却不支持Transact-SQL。SQL Server已经在市场中占据了主导地位，特别是随着SQL Server 版本的不断翻新，加上微软公司的强力支撑，SQL Server的主导地位将进一步得到加强。无论是数据库管理员还是数据库应用程序开发人员，要想深入领会和掌握数据库技术，必须认真学习Transact-SQL。除了拥有SQL语言所有的功能外，Transact-SQL还具备对SQL Server数据库独特的管理功能。 T-SQL是微软根据SQL改的语言规范，SQL Server是其实现语言规范的应用程序，MSSQL是Microsoft SQL Server的缩写 T-SQL是SQL语言的一种版本，且只能在微软MS SQL-Server以及Sybase Adaptive Server系列数据库上使用。 T-SQL是ANSI SQL的扩展加强版语言，除了提供标准的SQL命令之外，T-SQL还对SQL做了许多补充，提供了类似C、BASIC和Pascal的基本功能，如变量说明、流控制语言、功能函数等。 SQL Server的发展史 SQL Server是一个典型的关系数据库管理系统，其最初是由Microsoft、Sybase 和Ashton-Tate三家公司共同研发，于1988年推出了第一个OS/2版本。 1993年，Microsoft推出Windows NT操作系统并将数据库产品移植到Windows NT上，此后三家公司基本上“分道扬镳”。 目前，SQL Server主要是指由Microsoft公司推出的一系列SQL Server版本。SQL Server发展迅速，最近几乎是每两年推出一个新版本。 1. SQL Server 6.0/6.5/7.0 1995年，Microsoft推出SQL Server 6.0版本，这是第一个完全由Microsoft公司开发的版本。 1996年，Microsoft进一步推出了SQL Server 6.5版本。该版本满足众多小型商业数据管理的应用需求，也曾风靡一时。但是由于受到以前版本在结构上的限制，SQL Server 6.5在应用中逐步暴露出它的一些缺点。 1998年，Microsoft公司经过对SQL Server的核心数据库引擎进行重新改写以后，推出了SQL Server 7.0版本。SQL Server 7.0在数据存储和数据库引擎方面发生了根本性的变化，提供了面向中小型企业应用的数据库功能支持，它是SQL Server系列中第一个得到广泛应用的SQL Server版本。 2. SQL Server 2000 SQL Server 2000版本继承了SQL Server 7.0 版本的优点，增加了许多更先进的功能：具有更好的可用性和可伸缩性，与相关软件集成程度高，提供了企业级的数据库功能，易于安装和部署等。它既可以在Windows 98 的膝上型电脑上运行，也支持在Windows 2000大型多处理器的服务器等多种平台上使用。 3. SQL Server 2005 SQL Server 2005的功能体现在两个方面： 数据管理功能，SQL Server 2005 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能，构建和管理用于业务的高可用和高性能的数据的应用程序； 智能数据分析功能——商业智能 (BI)，SQL Server 2005可以有效地执行大规模联机事务处理，完成数据仓库和电子商务应用等许多具有挑战性的工作，构建和部署经济有效的BI解决方案。 在SQL Server系列版本中，自从SQL Server 2005开始，其管理工具的操作界面发生根本性的变化，使得对数据库的操作变得更为简单、方便。它提供了单一集成的管理控制台——SQL Server Management Studio（SSMS）。 SSMS是对SQL Server 2000查询分析器和企业管理器的集成和扩充而形成的一种SQL Server管理工具。 通过SSMS，数据管理员可以监视和管理SQL Server数据库、Integration Services、Analysis Services、Reporting Services、Notification Services以及在数量众多的分布式服务器和数据库上的SQL Server Mobile Edition，从而简化了管理工作。 在SSMS中还可以编写和执行查询，查看服务器对象，管理对象，监视系统活动和查看联机帮助等；SSMS还提供了一个开发环境，可在其中使用 Transact-SQL、多维表达式、XML for Analysis 和 SQL Server Mobile Edition来编写、编辑和管理脚本和存储过程等。 直到目前的SQL Server 2017版本，一直沿用这种界面风格和功能。 4. SQL Server 2008 SQL Server 2008兼容SQL Server 2005的功能并增加了许多新的功能。将结构化、半结构化和非结构化文档的数据直接存储到数据库中，对数据进行查询、搜索、同步、报告和分析等操作，满足数据爆炸和下一代数据驱动应用程序的需求，其功能十分强大，性能较SQL Server 2005更为稳定。 5. SQL Server 2012 SQL Server 2012是Microsoft于2012年3月发布的新一代数据平台产品，为用户带来更多全新的体验。能够顺应云技术发展的需要，全面支持云技术，能够快速实现私有云与公有云之间数据的扩展与应用的迁移，可用于大型联机事务处理、数据仓库和电子商务等方面的数据库平台，为数据存储、数据分析提供基于云技术的解决方案，是一种全新的数据分析处理平台。 6. SQL Server 2014 2014年4月，Microsoft推出了SQL Server 2014版本。与其他版本相比，SQL Server 2014提供了驾驭海量数据的关键技术——in-memory增强技术。该技术能够整合云端各种数据结构，极大地增强了对云的支持，提供了全新的混合云解决方案，实现云备份和灾难恢复，大幅提升数据处理的效率，能快速处理数以百万条的记录。SQL Server 2014为大数据分析提供了一种有效的解决方案。 本书是基于SQL Server 2014版本介绍关系数据库的基本原理及其相关应用，包括关系数据库理论、数据库设计方法以及数据管理、存储、查询、分析、备份等方面的内容。我们之所以选择SQL Server 2014版本来介绍数据库原理的相关内容，是在充分考虑了当前“用户条件”允许的范围内选择了最新的SQL Server版本——SQL Server 2014。 7. SQL Server 2016/2017 SQL Server 2016是Microsoft数据平台历史上最大的一次跨越性发展，除了兼容SQL Server 2014版本功能以外，增强了安全性、高可用性和灾难恢复功能，是性能最高的数据仓库，提供实时运营分析、大数据简化等功能，再次简化了数据库分析方式。 SQL Server 2017同时面向Windows、Linux、macOS、以及Docker容器，用户可以在 SQL Server 平台上选择开发语言、数据类型、本地开发或云端开发以及操作系统开发等，引入了图数据处理、适应性查询、面向高级分析的R/Python集成等功能。 SQL Server 2016/2017对安装环境（包括软环境和硬环境）提出较高的要求。SQL Server 2016只支持在Windows 8及以上版本的桌面操作系统或在Windows Server 2012及以上版本的服务器操作系统上安装，但目前由于操作习惯等因素，很多用户还不适应Windows 8或更高一级操作系统版本。 本书下面MSSQL部分用SQL Server 2014标准版。 T-SQL语言的构成 在SQL Server数据库中，T-SQL语言由以下几部分组成。 （1）数据定义语言（DDL）。 DDL用于执行数据库的任务，对数据库以及数据库中的各种对象进行创建、删除、修改等操作。如前所述，数据库对象主要包括表、默认约束、规则、视图、触发器、存储过程。DDL包括的主要语句及功能如表5.1所示。 表5.1 DDL主要语句及功能 语 句 功 能 说 明 CREATE 创建数据库或数据库对象 不同数据库对象，其CREATE语句的语法形式不同 ALTER 对数据库或数据库对象进行修改 不同数据库对象，其ALTER语句的语法形式不同 DROP 删除数据库或数据库对象 不同数据库对象，其DROP语句的语法形式不同 DDL各语句的语法、使用方法及举例请参考相关章节。 （2）数据操纵语言（DML）。 DML用于操纵数据库中的各种对象，检索和修改数据。DML包括的主要语句及功能如表5.2所示。 表5.2 DML主要语句及功能 语 句 功 能 说 明 SELECT 从表或视图中检索数据 是使用最频繁的SQL语句之一 INSERT 将数据插入到表或视图中 UPDATE 修改表或视图中的数据 既可修改表或视图的一行数据，也可修改一组或全部数据 DELETE 从表或视图中删除数据 可根据条件删除指定的数据 DML各语句的语法、使用方法及举例请参考相关章节。 （3）数据控制语言（DCL）。 DCL用于安全管理，确定哪些用户可以查看或修改数据库中的数据。DCL包括的主要语句及功能如表5.3所示。 表5.3 DCL主要语句及功能 语 句 功 能 说 明 GRANT 授予权限 可把语句许可或对象许可的权限授予其他用户和角色 REVOKE 收回权限 与GRANT的功能相反，但不影响该用户或角色从其他角色中作为成员继承许可权限 DENY 收回权限，并禁止从其他角色继承许可权限 功能与REVOKE相似，不同之处是，除收回权限外，还禁止从其他角色继承许可权限 DCL各语句的语法、使用方法及举例请参考相关章节。 （4）T-SQL增加的语言元素。 这部分不是ANSI SQL所包含的内容，而是微软为了用户编程的方便而增加的语言元素。这些语言元素包括变量、运算符、流程控制语句、函数等。这些T-SQL语句都可以在查询分析器中交互执行。 "},"page/11128.html":{"url":"page/11128.html","title":"Mysql","keywords":"","body":"Mysql MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，所以你不需要支付额外的费用。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 "},"page/11134.html":{"url":"page/11134.html","title":"原理","keywords":"","body":"原理 SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，是一种通用的、功能强大而又简单易学的关系数据库语言。 特点： （1）高度非过程化语言 ​ 非关系数据模型的数据操纵语言都是面向过程的语言，在使用时必须指定存储路径。SQL是一种高度非过程化的语言，它一次执行一条命令，对数据提供自动导航。SQL不要求用户指定对数据的存放方法，只要求用户提出要“干什么”，至于“怎么干”，用户就不用管了，而由系统自动完成。 （2）统一的数据库操作语言 ​ SQL语言风格统一，用于创建数据库、定义关系模式、完成数据的查询、修改、删除、控制等操作。为数据库应用系统的开发提供了良好的环境。在数据库投入运行以后，可以使用SQL语言实现数据库重构，在一定程度上满足用户不断发展的需求，同时不影响数据库的正常运行，使数据库系统具有良好的可扩展性。 （3）关系数据库的标准语言 ​ SQL成为国际标准以后，由于绝大多数的数据库厂商都支持SQL，所以SQL可以用于各类数据库管理系统，从而使它成为关系数据库的标准语言。所有用SQL编写的程序都是可以在不同的系统中移植，同时也结束了数据库查询语言“各自为政的分割局面”。 ​ （4）面向集合的数据操纵语言 ​ 非关系数据模型的数据操纵语言一般是面向记录进行操作的，即每一次操作都是针对一条记录进行的。如果要对多条记录操作，则必须循环进行。而SQL则面向集合的方式进行操作，即每一次操作是针对所有满足条件的元组组成的集合进行，操作所产生的结果也是元组的集合。 （5）可嵌入式的数据库语言 ​ SQL语言不但可以在交互方式下以命令的形式执行，还可以嵌入到其他的高级语言中。在交互方式下，用户可以在终端键盘上直接键入SQL命令对数据库进行操作；作为可嵌入式的数据库语言，SQL语言可嵌入到像C、COBOL、FORTRAN、VB、PowerBuilder、Delphi等这种高级语言中，通过程序调用来实现对数据库的操作。不管是在交互方式下还是在嵌入方式下，SQL语言的语法结构基本上都一样，这使得对数据库的操作变得更为灵活和方便。 （6）简单易学 ​ SQL语言的语法结构比较简单，调用格式非常简洁。所使用命令的核心关键字才包括9个：CREATE、ALTER、DROP、GRANT、REVOKE、SELECT、INSERT、UPDATE、DELETE 。而且其语法接近英语口语，方便理解和记忆。 "},"page/11135.html":{"url":"page/11135.html","title":"MSSQL","keywords":"","body":"SQL Server "},"page/11136.html":{"url":"page/11136.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11011.html":{"url":"page/11011.html","title":"配置","keywords":"","body":"配置 "},"page/11012.html":{"url":"page/11012.html","title":"MySQL","keywords":"","body":"MySQL 所有平台的 MySQL 下载地址为： MySQL 下载 。 挑选你需要的 MySQL Community Server 版本及对应的平台。 注意：安装过程我们需要通过开启管理员权限来安装，否则会由于权限不足导致无法安装。 "},"page/11201.html":{"url":"page/11201.html","title":"Windows","keywords":"","body":"Windows 1 下载 1.1下载地址 下载地址 https://downloads.mysql.com/archives/community/ 1.2 选择适合自己的版本并下载 1.3 将下载文件解压至自定义路径 1.4 添加配置文件 在解压的路径下查看是否含有my.ini的文件，如果没有则新建一个， 具体步骤为 1.新建一个txt， 2.重命名为my.ini，注意连扩展名一起改 3.用记事本打开my.ini 4.将下面内容复制到里面，并保存关闭，注意里面自定义路径要更改 [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=C:\\IDE\\mysql-5.7.26-winx64 # 设置mysql数据库的数据的存放目录 datadir=C:\\IDE\\mysql-5.7.26-winx64\\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 2.环境变量配置 2.1复制路径 进入解压目录下的bin目录 右击复制 2.2 配置环境变量 打开控制面板--系统--高级系统设置--环境变量--找到系统变量（S）中的path变量---编辑--新建---control+V---确定---确定 3 安装mysql服务 如果没进行2则要进行3.1 3.1 进入bin目录 以管理员进入dos界面，切换到解压的bin目录下， 具体操作：鼠标移到左下角--搜索命令提示符---右击以管理员身份运行 输入cd 自定义路径 如： cd C:\\IDE\\mysql-5.7.26-winx64\\bin 配置1：https://blog.csdn.net/missing2011/article/details/81474857 配置2：https://blog.csdn.net/sunboy520555/article/details/80918407 远程1：https://blog.csdn.net/sinat_36306474/article/details/82084049 远程2：https://www.2cto.com/database/201702/594659.html 远程3：https://blog.csdn.net/liuhailiuhai12/article/details/64124637 远程4：https://www.jb51.net/article/42441.htm 卸载1：https://www.cnblogs.com/jpfss/p/6652701.html 3.2 输入mysqld install 3.2.1 修复 显示下图，点此下载DirectX修复工具增强版，然后修复，然后进行3.2.2 3.2.1如果显示下图，到这一步表示安装成功 3.3 输入mysqld --initialize --console 初始化 其中标红的为数据库root用户的初始密码，一定要牢记，后面登录需要用到， 要是不小心关掉了或者没记住，删掉初始化的 data目录，再执行一遍初始化命令又会重新生成。 3.4输入mysqld --install安装mysql服务 3.5输入net start mysql启动服务 备注：mysqld --remove是卸载MySQL服务，net stop mysql是停止服务。 4 配置数据库 4.1进入 输入mysql -u root -p后会让你输入密码，密码为前面让你记住的密码，输入正确后就会出现如下界面，表示进入了MySQL命令模式。 4.2 更改密码 接着更改密码，输入 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; 其中123456为新密码，出现如下界面表示更改成功。 至此安装完成 5 连接Navicat 5.1连接本地数据库 5.1.1下载并打开navicat 按照下图配置，密码为4.2步设置的mysql密码 5.1.2再次双击变成绿色即连接上 5.2 连接云端数据库 5.2.1服务器端设置 对数据库进行远程登录的授权，这时我们可以进入服务器后台，在MySQL命令行中输入以下命令 GRANT ALL PRIVILEGES ON . TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; myuser 改为你的数据库用户名 一般为root mypassword 改为数据库登录密码 5.2.2直接使用IP进行连接 6 卸载mysql 6.1 停止MySQL服务 开始-》所有应用-》Windows管理工具-》服务，将MySQL服务停止 6.2 卸载mysql server 控制面板\\所有控制面板项\\程序和功能，将mysql server卸载掉 6.3 将MySQL安装目录下的MySQL文件夹删除 6.4 运行“regedit”文件，打开注册表 删除HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQL文件夹 删除HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQL文件夹 删除HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQL的文件夹 如果没有相应的文件夹，就不用删除了 6.5 删除C盘下的“C:\\ProgramData\\MySQL ”文件夹 该programData文件默认是隐藏的，设置显示后即可见 或者直接复制 C:\\ProgramData 到地址栏回车即可进入 将整个MySQL文件夹删除掉 6.6 删除服务 如果已经将MySQL卸载，但通过“开始-》所有应用-》Windows管理工具-》服务”查看到MySQL服务仍然残留在系统服务里 只要在CMD里输入一条命令就可以将服务删除： sc delete mysql //这里的mysql是你要删除的服务名 mysqld --remove //也可卸载服务 服务就被删除了 卸载完成 配置1：https://blog.csdn.net/missing2011/article/details/81474857 配置2：https://blog.csdn.net/sunboy520555/article/details/80918407 远程1：https://blog.csdn.net/sinat_36306474/article/details/82084049 远程2：https://www.2cto.com/database/201702/594659.html 远程3：https://blog.csdn.net/liuhailiuhai12/article/details/64124637 远程4：https://www.jb51.net/article/42441.htm 卸载1：https://www.cnblogs.com/jpfss/p/6652701.html "},"page/11202.html":{"url":"page/11202.html","title":"Linux","keywords":"","body":"Linux Linux/UNIX 上安装 MySQL apt安装 sudo apt-get install -y mysql-server mysql-client 1.简介 2.检查 安装前，我们可以检测系统是否自带安装 MySQL: mysql -V 卸载 apt-get autoremove --purge mysql-server-5.6 apt-get autoremove mysql-server apt-get remove mysql-common dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P 3.安装 apt-get install mysql-server mysql-client 4.服务 ​ 停止MySQL数据库服务： sudo systemctl stop mysql.service 　　启动MySQL数据库服务： sudo systemctl start mysql.service 　　重启MySQL数据库服务： 　sudo systemctl restart mysql.service 　　查看MySQL运行状态： sudo systemctl status mysql.service rpm安装 1.简介 Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址： MySQL - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。 MySQL-client - MySQL 客户端程序，用于连接并操作Mysql服务器。 MySQL-devel - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。 MySQL-shared - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。 MySQL-bench - MySQL数据库服务器的基准和性能测试工具。 2.检查 安装前，我们可以检测系统是否自带安装 MySQL: rpm -qa | grep mysql 如果你系统有安装，那可以选择进行卸载: rpm -e mysql　　// 普通删除模式 rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 3.安装MySQL 接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：https://dev.mysql.com/downloads/repo/yum/ 可以直接点下载，下载rpm安装包 也可以复制下列包名，前面加上wget http://repo.mysql.com/使用命令下载 即： wget http://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm 安装 rpm -ivh mysql-community-release-el7-5.noarch.rpm yum update yum install mysql-server 权限设置： chown mysql:mysql -R /var/lib/mysql 初始化 MySQL： mysqld --initialize 启动 MySQL： systemctl start mysqld 查看 MySQL 运行状态： systemctl status mysqld 注意：如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。 此外,你也可以使用 MariaDB 代替，MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。 yum install mariadb-server mariadb mariadb数据库的相关命令是： systemctl start mariadb #启动MariaDB systemctl stop mariadb #停止MariaDB systemctl restart mariadb #重启MariaDB systemctl enable mariadb #设置开机启动 4.验证 MySQL 安装 在成功安装 MySQL 后，一些基础表会表初始化，在服务器启动后，你可以通过简单的测试来验证 MySQL 是否工作正常。 使用 mysqladmin 工具来获取服务器状态： 使用 mysqladmin 命令来检查服务器的版本, 在 linux 上该二进制文件位于 /usr/bin 目录，在 Windows 上该二进制文件位于C:\\mysql\\bin 。 [root@host]# mysqladmin --version linux上该命令将输出以下结果，该结果基于你的系统信息： mysqladmin Ver 8.23 Distrib 5.0.9-0, for redhat-linux-gnu on i386 如果以上命令执行后未输出任何信息，说明你的Mysql未安装成功。 5.使用 MySQL Client(Mysql客户端) 执行简单的SQL命令 你可以在 MySQL Client(Mysql客户端) 使用 mysql 命令连接到 MySQL 服务器上，默认情况下 MySQL 服务器的登录密码为空，所以本实例不需要输入密码。 命令如下： [root@host]# mysql 以上命令执行后会输出 mysql>提示符，这说明你已经成功连接到Mysql服务器上，你可以在 mysql> 提示符执行SQL命令： mysql> SHOW DATABASES; +----------+ | Database | +----------+ | mysql | | test | +----------+ 2 rows in set (0.13 sec) 6. Mysql安装后需要做的 Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： [root@host]# mysqladmin -u root password \"new_password\"; 现在你可以通过以下命令来连接到Mysql服务器： [root@host]# mysql -u root -p Enter password:******* 注意：在输入密码时，密码是不会显示了，你正确输入即可。 对数据库进行远程登录的授权，这时我们可以进入服务器后台，在MySQL命令行中输入以下命令 GRANT ALL PRIVILEGES ON . TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; myuser 改为你的数据库用户名 一般为root mypassword 改为数据库登录密码 "},"page/11013.html":{"url":"page/11013.html","title":"MSSQL","keywords":"","body":"SQL Server "},"page/11203.html":{"url":"page/11203.html","title":"2008","keywords":"","body":"2008 1.安装 1.1安装SQL Server 2008的硬件和软件要求 为了正确安装和运行SQL Server 2008，计算机必须满足以下配置要求。 （1）硬件 处理器：需要 Pentium III 兼容处理器或更高速度的处理器，处理器速度不低于1 GHz，为了获得更好的运行效果，建议为2 GHz或以上。 内存：512 MB以上，建议为2 GB 或更大。 硬盘：1.7 GB的安装空间以及必要的数据预留空间。 （2）软件 ① 操作系统要求（32位）。SQL Server 2008只能运行在Windows操作系统之上。SQL Server 2008设计了不同的分支版本，每个版本对操作系统的要求不尽相同。在SQL Server 2008服务器软件的32位版本中，Enterprise版（除了Enterprise Evaluation版，即企业评估版之处）只能运行在Windows Server 2003和Windows Server 2008操作系统上。Standard版能够运行在Windows XP（除了Windows XP家庭版之外）、Windows Vista、Windows Server 2003、Windows Server 2008等大多数Windows操作系统之上。Developer版能够运行在Windows XP、Windows Vista、Windows Server 2003、Windows Server 2008等操作系统之上。其他版本所适合的操作系统在此就不详细列出了。 ② 安装组件要求。SQL Server 2008安装时需要的组件如下： .NET Framework 3.5； SQL Server Native Client； SQL Server 安装程序支持文件； Microsoft Windows Installer 4.5 或更高版本； Microsoft 数据访问组件（MDAC）2.8 SP1 或更高版本。 1.2 SQL Server 2008的安装 第1步：插入自动运行的安装光盘或双击已经下载的SQL Server 2008安装程序，SQL Server 2008需要.NET Framework 3.5的支持，安装程序启动后会检测系统是否已经安装了.NET Framework 3.5，如果没有安装，则弹出要求安装的对话框，单击“确定”按钮，等待一段时间后进入如图1.16所示的“.NET Framework 3.5许可协议”窗口，同意许可条款并单击“安装”按钮开始安装，安装完成后单击“安装完成”窗口中的“退出”按钮即可。 第2步：安装完.NET Frame work 3.5后可能会弹出需要安装Windows XP补丁的对话框，这是安装SQL Server 2008必须要安装的补丁。安装完该补丁后重启计算机。 第3步：重启计算机后重新启动安装程序，进入“SQL Server安装中心”窗口，单击左边菜单栏中的“安装”选项卡，在窗口右边将列出可以进行的安装方式，如图1.17所示。单击“全新SQL Server独立安装或向现有安装添加功能”选项将安装全新的SQL Server 2008。 第4步：安装程序将检查SQL Server 安装程序支持文件时可能发生的问题，并将检查信息显示在“安装程序支持规则”窗口中，如图1.18所示。如果有检查未通过的规则，必须进行更正，否则安装将无法继续。 第5步：安装程序支持规则全部通过后单击“确定”按钮进入“产品密钥”窗口，如图1.19所示。在“指定可用版本”选项中选择“Enterprise Evaluation”，在“输入产品密钥”选项中输入企业评估版的25位产品密钥，完成后单击“下一步”按钮。 第6步：进入“许可条款”窗口，阅读并接受许可条款，单击“下一步”按钮。进入“安装程序支持文件”窗口，如图1.20所示，单击“安装”按钮安装SQL Server必备组件。安装完成后重新进入“安装程序支持规则”窗口，如图1.21所示。如果通过，则单击“下一步”按钮。 第7步：进入“功能选择”窗口，在“功能”区域中选择要安装的功能组件，用户可以根据自身需求来安装组件，这里单击“全选”按钮安装全部组件。单击“下一步”按钮进入“实例配置”窗口。 第8步：在“实例配置”窗口中进行实例配置，如果是第一次安装，则既可以使用默认实例，也可以自行指定实例名称。如果当前服务器上已经安装了一个默认的实例，则再次安装时必须指定一个实例名称。自定义实例名的方法为，选择“命名实例”单选按钮，在后面的文本框中输入用户自定义的实例名称。如果选择“默认实例”，则实例名称默认为MSSQLSERVER。这里选择“命名实例”，名称为SQL2008，如图1.22所示。 第9步：实例配置完后单击“下一步”按钮进入“磁盘空间要求”窗口，窗口中显示安装SQL Server 2008所需要的磁盘容量。单击“下一步”按钮进入“服务器配置”窗口，在“服务账户”选项卡中为每个SQL Server服务单独配置用户名和密码及启动类型。“账户名”可以在下拉框中进行选择。也可以单击“对所有SQL Server服务器使用相同的账户”按钮，为所有的服务分配一个相同的登录账户。配置完成后的界面如图1.23所示，单击“下一步”按钮。 第10步：进入“数据库引擎配置”窗口，在“账户设置”选项卡中选择身份验证模式。身份验证模式是一种安全模式，用于验证客户端与服务器的连接，它有两个选项：Windows身份验证模式和混合模式。在Windows身份验证模式中，用户通过Windows账户连接时，使用Windows操作系统中的信息验证账户名和密码，混合模式允许用户使用Windows身份验证或SQL Server身份验证进行连接，而建立连接后，系统的安全机制对于两种连接是一样的。 本书选择“混合模式”为身份验证模式，并为内置的系统管理员账户“sa”设置密码，为了便于介绍，这里密码设为“123456”，如图1.24所示。在实际操作过程中，密码要尽量复杂以提高安全性。 第11步：单击“下一步”按钮进入“Analysis Services配置”窗口，对Analysis Services进行设置，单击“添加当前用户”按钮指定当前Windows登录用户对Analysis Services具有管理权限。单击“下一步”按钮进入“Reporting Services配置”窗口，选择“安装本机模式默认配置”选项，单击“下一步”按钮进入“错误和使用情况报告”窗口，这里用户可以根据需求在复选框中选择选项。 第12步：单击“下一步”按钮进入“安装规则”窗口，窗口中将显示安装规则的通过情况，如图1.25所示，如果全部通过，则可以单击“下一步”按钮。 第13步：进入“准备安装”窗口，单击“安装”按钮开始安装，等待一段时间后安装完成，窗口中将显示已经成功安装的功能组件，如图1.26所示。单击“下一步”按钮，在“完成”窗口中单击“关闭”按钮结束安装。 "},"page/11204.html":{"url":"page/11204.html","title":"2014","keywords":"","body":"2014 SQL Server 2014的几个版本 SQL Server 2014不同版本的特点及其区别： 商业智能版（Business Intelligence，64位和32位） SQL Server 2014商业智能版提供了综合性平台，可用于构建和部署安全、可扩展、易于管理的商业智能解决方案，其数据集成功能强大，强化了数据集成管理功能，提供了基于浏览器的数据浏览功能。此版本主要是面向智能数据分析的。 标准版（Standard，64位和32位） SQL Server 2014标准版提供了基本的数据管理功能，支持商业智能数据库，适用于面向部门和小型组织的数据库应用程序，支持将常用开发工具运用于内部部署和云部署，有助于以最少的IT资源获得高效的数据库管理。该版本可以理解为企业版的简装版，面向中小型企业应用。 Web版（64 位和 32 位） 对于小规模至大规模的Web应用而言，SQL Server 2014 Web版提供良好的可伸缩性、经济性和可管理性功能，相应应用的开发成本比较低，可伸缩性好。它主要是面向基于数据库的Web应用开发。 开发版（Developer，64位和32位） SQL Server 2014开发版构建任意类型的应用程序，包括企业版的所有功能，但有许多功能是受限的，一般用于开发和测试，不用作正式投入运行系统的数据库服务器，即它是开发人员和测试人员首选的SQL Server 2014版本。 精简版（Express，64位和32位） SQL Server 2014精简版主要是为学习者提供免费学习的SQL Server软件，用于开发桌面及小型服务器数据驱动的客户端应用程序。SQL Server 2014精简版可以无缝升级到其他更高端的SQL Server版本。 安装SQL Server 2014的要求 操作系统的文件系统格式（磁盘格式）分为两种类型：NTFS文件系统和FAT32文件系统。建议将SQL Server 2014安装在NTFS文件系统的计算机上。虽然FAT32文件系统也支持安装SQL Server 2014，出于安全考虑一般不建议在这种文件系统上安装SQL Server 2014。 SQL Server 2014对计算机的硬件和软件环境都有较高的要求。在安装SQL Server 2014之前，先对自己的计算机配置情况进行适当的评估，以确定是否可以安装SQL Server 2014。安装过程最好保持Internet是可访问的，随时可能需要下载一些必要的组件。 在软件方面，.NET Framework 3.5 SP1是必须先安装的，SQL Server Management Studio的运行依赖于.NET Framework 3.5提供的类库和方法。如果机器上没有预先安装.NET Framework 3.5 SP1，在安装SQL Server 2014时会提示下载.NET Framework 3.5 SP1并给出下载地址。 各SQL Server 2014版本适用的Windows操作系统说明如下表所示。 SQL Server 2014适用Windows操作系统的情况 版本 适用的操作系统(32位) 适用的操作系统(64位) 备注 企业版（Enterprise） Windows Server 2008 及以上版本 Windows Server 2008 及以上版本 仅支持Windows Server版本系列 商业智能版（Business Intelligence） Windows Server 2008 及以上版本 Windows Server 2008 及以上版本 仅支持Windows Server版本系列 标准版（Standard） Windows 7, Windows Server 2008 及以上版本 Windows 7, Windows Server 2008 及以上版本 Web版（Web） Windows 7, Windows Server 2008 及以上版本 Windows 7, Windows Server 2008 及以上版本 开发版（Developer） Windows 7, Windows Server 2008 及以上版本 Windows 7, Windows Server 2008 及以上版本 精简版（Express） Windows 7, Windows Server 2008 及以上版本 Windows 7, Windows Server 2008 及以上版本 在硬件方面，SQL Server 2014要求最少有6GB的硬盘空间可用，具体空间耗费情况跟选择安装的SQL Server 2014组件有关，如表所示。 SQL Server 2014组件需要的磁盘空间 安装的组件 所需磁盘空间 数据库引擎 和数据文件、复制、全文搜索以及 Data Quality Services 811 MB Analysis Services 和数据文件 345 MB Reporting Services和报表管理器 304 MB Integration Services 591 MB Master Data Services 243 MB 客户端组件（除 SQL Server 联机丛书组件和 Integration Services 工具之外） 1823 MB SQL Server联机丛书组件 200 MB SQL Server 2014对处理器和内存的要求说明如表所示 SQL Server 2014对处理器、内存的要求 组 件 要 求 内存 最低要求： Express 版本：512 MB所有其他版本：1 GB建议：Express 版本：1 GB所有其他版本：至少 4 GB 并且应该随着数据库大小的增加而增加，以便确保最佳的性能。 处理器速度 最低要求： x86 处理器：1.0 GHzx64 处理器：1.4 GHz建议：2.0 GHz 或更快 处理器类型 x64 处理器：AMD Opteron、AMD Athlon 64、支持Intel EM64T的Intel Xeon、支持 EM64T的Intel Pentium IVx86处理器：Pentium III兼容处理器或更快 1.下载 从Microsoft官方网站https://www.microsoft.com/zh-cn/下载SQL Server 2014标准版 或者参考https://zlogs.net/1910072300/ 2.双击打开，双击setup.exe 解压下载的文件包，在解压形成的目录中寻找可执行文件setup.exe并双击它 3.允许应用更改 4.安装-->全新安装 之后将打开“SQL Server安装中心”对话框，单击左侧的“安装”选项，然后单击右边的“全新SQL Server独立安装或向现有安装添加功能”选项， 5.输入密钥-->下一步 单击“全新SQL Server独立安装或向现有安装添加功能”选项后，打开“SQL Server安装中心（产品秘钥）”对话框。在该对话框中，如果选择“指定可用版本”项，可选择安装精简版或测试版。安装这两个版本时，都不需要产品秘钥，但测试版受使用时间限制，不超过180天；精简版则在功能上受到诸多限制。如果购买有产品秘钥的，则选择“输入产品秘钥”项，然后输入相应的秘钥即可安装标准版。 6.接受条款-->下一步 单击【下一步】按钮，打开“许可条款”对话框，从中选择“我接受许可条款”（必须选择，否则不能往下安装），然后单击【下一步】按钮。 7.下一步 8.所有通过-->下一步 安装程序会对系统进行短暂的检测，以查看系统是否适合安装选择的SQL Server版本。如果都通过，则显示如图所示的界面。 9.sql功能安装-->下一步 此后进入“功能选择”对话框，如图4.7所示。在此对话框中，选择要安装的功能。每点选“功能”框中的某一项时，右边“功能说明”框中都显示相应详细的功能描述，同时在“所选功能的必备组件”框中显示需要安装的组件； 10.全选-->选择自定义目录-->下一步 在对话框的下方，可以修改实例根目录和共享目录的位置。本书只利用SQL Server 2014来介绍数据库的基本原理，不涉及SQL Server 2014数据库以外其他太多的功能，如分析服务（Analysis Service）等，因此只需选择“数据库引擎服务”即可。作为学习之用，出于课外学习数据分析等功能的需要，建议选择所有的功能（单击【全选】按钮）。建议不要将实例根目录和共享目录设置在C盘上，否则随着数据的增加而导致C盘的可用磁盘空间逐渐变小，从而影响系统的运行效率，特别是在实际应用中尤是如此。 11.默认实例-->下一步 “功能选择”对话框设置结果如图4.8所示，单击【下一步】按钮，进入“实例配置”对话框。 12.下一步 在“实例配置”对话框中选择“默认实例”，然后单击【下一步】按钮，进入“服务器配置”对话框。在此对话框中，可以为每个服务设置帐户和密码以及设置服务的启动方式。保持数据库引擎的启动方式为自动，其他服务都设置为手动（如果将不常用的服务设置为自动方式，则在打开电脑后这些服务将自动运行，从而因占用系统资源而导致系统响应速度变慢），而服务的帐户和密码使用默认设置，即待以后再设置，如图所示。 13.windows身份验证-->添加当前用户-->下一步 单击【下一步】按钮后，进入“数据库引擎配置”对话框，设置数据库的身份验证方式。有两种验证范式： Windows身份验证方式，在这种方式下SQL Server的登录用户实际上就是Windows用户；混合模式（SQL Server身份+Windows身份验证），在此模式下需要一个Windows用户和SQL Server管理员用户sa共同通过验证才能登录服务器，而sa的密码需要设置。 我们选择混合模式验证方式，sa的密码为“sql123”，同时单击【添加当前用户】按钮，表示选择当前Windows用户和sa进行混合验证，如图所示。 注意如果是云端用账号连接，一定要选混合模式 14.添加当前用户-->下一步 15.下一步 16.添加当前用户-->下一步 17.自定义目录-->下一步 18.安装 19.等待进度条走完 20.关闭 21.重启即可完成安装 "},"page/11247.html":{"url":"page/11247.html","title":"2014组件和管理工具","keywords":"","body":"2014组件和管理工具 SQL Server 2014组件和管理工具 SQL Server 2014提供了一系列的组件，用于支撑高性能的数据管理功能和智能数据分析功能。SQL Server 2014的管理工具主要是SQL Server 2014 Management Studio（SSMS），还有数据导入、导出等工具。 SQL Server 2014组件 SQL Server数据库引擎 数据库引擎是SQL Server 2014的核心组件，基本功能是实现数据的存储、处理和保护，还包含复制、全文搜索以及用于管理关系数据和XML数据的工具。 分析服务（Analysis Services） 分析服务包括用于创建和管理联机分析处理 (OLAP) 以及数据挖掘应用程序的工具。通过OLAP可以实现对多维、复杂的海量数据进行快速的高级分析，通过数据挖掘可以从海量数据中发现意想不到的“惊人”结果，以供决策支持。 报表服务（Reporting Services） 报表服务是提供全面报表决策方案的服务器和客户端组件，用于创建、管理和部署各种类型的报表，包括表格报表、矩阵报表、图形报表以及自由格式报表等。报表服务还是一个可用于开发报表应用程序的可扩展平台。 集成服务（Integration Services） 集成服务是对SQL Server 2000数据转换服务（DTS）、数据导入\\导出功能的扩充，形成了用于数据移动、复制和转换的图形工具和可编程对象。 主数据服务（Master Data Services） 主数据服务（Master Data Services）也简称为 MDS，它是 SQL Server 2008 R2开始增加的关键商业智能特性之一，其目的是为企业信息提供单个权威来源，可以为其它应用和数据提供权威引用。通过配置MDS，可以管理任何领域产品、客户、账户等。 SQL Server 2014管理工具 SQL Server Management Studio (SSMS) SQL Server Management Studio (SSMS)是自SQL Server 2005版本开始新增加的组件，它是对SQL Server 2000查询分析器、企业管理器和分析管理器等工具的集成和扩充，形成了用于访问、配置、管理和开发SQL Server的所有组件的集成环境。 SQL Server配置管理器 SQL Server配置管理器主要用于为SQL Server服务、服务器协议、客户端协议和客户端别名提供基本配置管理。 SQL Server Profiler SQL Server Profiler提供了一种图形用户界面，用于监视数据库引擎实例和分析服务实例。 数据库引擎优化顾问 用于协助创建索引、索引视图和分区的最佳组合。 数据质量客户端 它提供了一个非常简单和直观的图形用户界面，用于连接到DQS数据库并执行数据清洗操作。在数据清洗操作过程中，通过此客户端可以监视执行的各项活动。 SQL Server Data Tools SQL Server Data Tools (SSDT)在以前版本中称为是Business Intelligence Development Studio（BIDS），它是分析服务、报表服务和集成服务解决方案的集成开发环境。如果说SQL Server 2014的数据管理功能是通过SSMS来实现的，那么SQL Server 2014的数据分析功能则是通过SSDT来完成的。因此，它在商业智能、数据分析中有着重要的不可替代的作用。 连接组件 连接组件属于客户端组件，用于实现客户端和服务器之间的通信。此外，还用于DB-Library、ODBC和OLE DB的网络库。 "},"page/11248.html":{"url":"page/11248.html","title":"2008组件和管理工具","keywords":"","body":"2008组件和管理工具 SQL Server 2008服务器组件 （1）Database Engine。数据库引擎是SQL Server 2008用于存储、处理和保护数据的核心服务，例如，查询数据、创建数据库、创建表和视图、数据查询等操作都是由数据库引擎完成的。数据库引擎还提供了受控访问和快速事务处理功能，并提供了大量支持以保持可用性。Service Broker（服务代理）、Replication（复制技术）和Full Text Search（全文搜索）都是数据库引擎的一部分。 SQL Server 2008实例有两种类型。 ① 默认实例。SQL Server 2008默认实例仅由运行该实例的计算机的名称唯一标识，它没有单独的实例名，默认实例的服务名称为MSSQLSERVER。如果应用程序在请求连接 SQL Server时只指定了计算机名，则SQL Server客户端组件将尝试连接这台计算机上的数据库引擎默认实例。一台计算机上只能有一个默认实例，而默认实例可以是SQL Server的任何版本。 ② 命名实例。除默认实例外，所有数据库引擎实例都可以由安装该实例的过程中指定的实例名标识。应用程序必须提供准备连接的计算机的名称和命名实例的实例名。计算机名和实例名格式为“计算机名\\实例名”，命名实例的服务名称即为指定的实例名。 （2）Analysis Services。SQL Server Analysis Services（分析服务，简称SSAS）为商业智能应用程序提供联机分析处理（OLAP）和数据挖掘功能。 （3）Integration Services。SQL Server Integration Services（集成服务，简称SSIS）主要用于清理、聚合、合并、复制数据的转换以及管理SSIS包。除此之外，它还提供生产并调试SSIS包的图形向导工具，以及用于执行FTP操作、电子邮件消息传递等工作流功能的任务。 （4）Reporting Services。SQL Server Reporting Services（报表服务，简称SSRS）是基于服务器的报表平台，可以用来创建和管理包含关系数据源和多维数据源中的数据的表格、矩阵、图形和自由格式的报表。 SQL Server 2008管理和开发工具 3.1SQL Server 2008管理工具 Microsoft SQL Server 2008安装后，可在“开始”菜单中查看安装了哪些工具。另外，还可以使用这些图形化工具和命令实用工具进一步配置SQL Server。表1.4列举了用来管理SQL Server 2008实例的工具。 表1.4 SQL Server管理工具 管 理 工 具 说 明 SQL Server Management Studio 用于编辑和执行查询，以及启动标准向导任务 SQL Server Profiler 提供用于监视SQL Server数据库引擎实例或Analysis Services 实例的图形用户界面 数据库引擎优化顾问 可以协助创建索引、索引视图和分区的最佳组合 SQL Server Business IntelligenceDevelopment Studio 用于包括 Analysis Services、Integration Services 和Reporting Services项目在内的商业解决方案的集成开发环境 Reporting Services配置管理器 提供报表服务器配置的统一的查看、设置和管理方式 SQL Server 配置管理器 管理服务器和客户端网络配置设置 SQL Server 安装中心 安装、升级到或更改 SQL Server 2008 实例中的组件 这里对表1.4中的“SQL Server配置管理器”补充说明如下。 SQL Server 配置管理器用于管理与 SQL Server 2008相关的服务。尽管其中许多任务可以使用Microsoft Windows服务对话框来完成，但值得注意的是，“SQL Server 配置管理器”还可以对其管理的服务执行更多的操作，例如，在服务账户更改后应用正确的权限。 打开“开始→所有程序→Microsoft SQL Server 2008→配置工具→SQL Server配置管理器”，在窗口的左边窗格中选择“SQL Server服务”，即可在右边窗格中出现的服务列表中对各服务进行操作，如图1.27所示。 使用SQL Server 配置管理器可以完成下列服务任务： （1）启动、停止和暂停服务，双击图1.27所示服务列表中的某个服务即可进行操作。 （2）将服务配置为自动启动或手动启动、禁用服务或者更改其他服务设置。 （3）更改 SQL Server 服务所使用的账户的密码。 （4）查看服务的属性。 （5）启用或禁用 SQL Server 网络协议。 （6）配置 SQL Server 网络协议。 SQL Server 2008中还有一些组件作为服务运行，如图1.27所示。 ① SQL Server代理。SQL Server代理是一种Windows服务，主要用于执行作业、监视 SQL Server、激发警报，以及允许自动执行某些管理任务。SQL Server代理的配置信息主要存放在系统数据库msdb的表中。在SQL Server 2008中，必须将SQL Server代理配置成具有sysadmin固定服务器角色的用户，才可以执行其自动化功能。而且该账户必须拥有诸如服务登录、批处理作业登录、以操作系统方式登录等Windows权限。 ② SQL Server Brower（浏览器）。此服务将命名管道和TCP端口信息返回给客户端应用程序。在用户希望远程连接SQL Server 2008时，如果用户通过使用实例名称来运行 SQL Server 2008，并且在连接字符串中没有使用特定的 TCP/IP 端口号，则必须启用 SQL Server Browser 服务以允许远程连接。 ③ SQL Full-Text Filter Daemon Launcher（全文搜索）。用于快速构建结构化或半结构化数据的内容和属性的全文索引，以允许对数据进行快速的语言搜索。 3.2 SQL Server Management Studio环境 　　SQL Server 2008 使用的图形界面管理工具是“SQL Server Management Studio”（简称SSMS）。这是一个集成的统一的管理工具组，在SQL Server 2005版本之后已经开始使用这个工具组开发、配置SQL Server数据库，发现并解决其中的故障。SQL Server 2008将继续使用这个工具组，并对其进行一些改进。 　　在“SQL Server Management Studio”中主要有两个工具：图形化的管理工具（对象资源管理器）和Transact SQL编辑器（查询分析器）。此外还拥有“解决方案资源管理器”窗口、“模板资源管理器”窗口和“注册服务器”窗口等。 （1）对象资源管理器与查询分析器 如图1.28所示，可以看到在SQL Server Management Studio中，把SQL Server 2000的Enterprise Manager（企业管理器）和Query Analyzer（查询分析器）两个工具结合在一个界面上，这样可以在对服务器进行图形化管理的同时编写Transact SQL脚本，且用户可以直接通过SQL Server 2008的“对象资源管理器”窗口来操作数据库。 图1.28 SQL Server Management Studio 打开“SQL Server Management Studio”的方法如下： 在桌面上单击“开始→所有程序→SQL Server 2008→SQL Server Management Studio”，在出现的“连接到服务器”对话框中，单击“连接”按钮，如图1.29所示，就可以以Windows身份验证模式启动SQL Server Management Studio，并以计算机系统管理员身份连接到SQL Server服务器。 图1.29 “连接到服务器”对话框 ① 利用对象资源管理器查看数据库对象。以Windows身份验证模式登录到SQL Server Management Studio。在对象资源管理器中展开“数据库”，选择系统数据库中的master数据库并展开，则将列出该数据库中所包含的所有对象，如表、视图、存储过程等。 ② 利用查询分析器查询master数据库中表dbo.spt_values的数据。在SQL Server Management Studio面板中单击“新建查询”按钮，在打开的“查询编辑器”窗格中输入以下命令： USE master GO SELECT * FROM dbo.spt_values 单击“执行”按钮，该查询执行的结果如图1.28所示。 （2）模板资源管理器 在SQL Server Management Studio的查询分析器中使用Transact SQL脚本可以实现从查询到对象建立的所有任务。而使用脚本编制数据库对象与使用图形化向导编制数据库对象相比，最大的优点是，使用脚本化方式具有图形化向导方式所无法比拟的灵活性。但是，高度的灵活性也就意味着使用它的时候有着比图形化向导方式更高的难度。SQL Server Management Studio提供了模板资源管理器来降低编写脚本的难度。 在SQL Server Management Studio的菜单栏中单击“视图”，选择“模板资源管理器”，界面右侧将出现“模板资源管理器”窗格，如图1.28所示。在模板资源管理器中除了可以找到超过100个对象以及Transact SQL任务的模板之外，还包括备份和恢复数据库等管理任务。 例如，在图1.28中可以双击“create_database”图标，打开创建数据库的脚本模板。 （3）注册服务器 SQL Server Management Studio界面有一个单独的可以同时处理多台服务器的注册服务器窗口。可以用IP地址来注册数据库服务器，也可以用比较容易分辨的名称为服务器命名，甚至还可以为服务器添加描述。名称和描述会在注册服务器窗口中显示。 如果要知道现在正在使用的是哪台服务器，只需要单击SQL Server Management Studio菜单栏中的“视图”，选择“已注册的服务器”菜单项，即可打开“已注册的服务器”窗口。 通过SQL Server Management Studio注册服务器，可以保存实例连接信息、连接和分组实例，查看实例运行状态。 在对象资源管理器中注册服务器的主要步骤如下： 启动SQL Server Management Studio，在菜单栏中选择“视图”，在弹出的子菜单中选择“已注册的服务器”，弹出“已注册的服务器”窗口，如图1.30所示，右击“数据库引擎”节点下的“Local Server Groups”，在弹出的快捷菜单中选择“新建服务器注册”菜单项，打开“新建服务器注册”对话框。 图1.30 “已注册的服务器”窗格 在对话框中单击“常规”选项卡。在“服务器名称”文本框中，输入要注册的服务器名称，如图1.31所示。在“连接属性”选项卡中，可以指定要连接到的数据库名称和使用的网络协议等其他信息。 图1.31 “新建服务器注册”对话框 （4）解决方案资源管理器 创建新项目的步骤如下。 第1步：单击菜单栏中的“文件”，在弹出的子菜单中选择“新建”，单击“项目”，选择所要创建的项目的类型。类型主要有“SQL Server脚本”、“Analysis Services脚本（分析服务脚本）”和“SQL Server Compact Edition脚本”。然后为创建的项目或方案命名，并选择文件的存储路径，单击“确定”按钮，完成项目的创建过程。 第2步：接下来就可以为该项目创建一个或多个（如果所创建的项目接触的数据库不只一个）数据库连接或者添加已经存在的项目文件，如图1.32所示，只需要在“解决方案资源管理器”窗格内的“SQL Server 脚本1”上右击鼠标，在弹出的快捷菜单中选择要添加的项目即可。 图1.32 “解决方案资源管理器”窗格 "},"page/11249.html":{"url":"page/11249.html","title":"2008基本概念","keywords":"","body":"SQL Server2008数据库基本概念 1.1基本模式 1.1.1 逻辑数据库 用户经常需要在T-SQL中引用SQL Server对象并对其进行操作，如对数据库表进行查询和数据更新等，在其所使用的T-SQL语句中需要给出对象的名称。用户可以给出两种对象名，即完全限定名和部分限定名。 （1）完全限定名。在SQL Server 2008中，完全限定名是对象的全名，包括4个部分：服务器名、数据库名、数据库架构名和对象名，其格式为 server.database.scheme.object 在SQL Server 2008上创建的每一个对象都必须有一个唯一的完全限定名。 （2）部分限定名。在使用T-SQL编程时，常省略全名中的某些部分，对象全名的4个部分中的前3个部分均可以省略，当省略中间的部分时，圆点符“.”不可省略。把只包含对象完全限定名中的一部分的对象名称为部分限定名。SQL Server可以根据系统的当前工作环境确定对象名称中省略的部分。 在部分限定名中，未指出的部分使用以下默认值。 服务器：默认为本地服务器。 数据库：默认为当前数据库。 数据库架构名：默认为dbo。 例如，以下是一些正确的对象部分限定名： server.database...object /*省略架构名*/ server.. scheme.object /*省略数据库名*/ database. scheme.object /*省略服务器名*/ server…object /*省略架构名和数据库名*/ scheme.object /*省略服务器名和数据库名*/ object /*省略服务器名、数据库名和架构名*/ 下面大致介绍一下SQL Server 2008中所包含的常用数据库对象。 ① 表： 表是SQL Server中最主要的数据库对象，它是用来存储和操作数据的一种逻辑结构。表由行和列组成，因此也称为二维表。表是在日常工作和生活中经常使用的一种表示数据及其关系的形式。 ② 视图： 视图是从一个或多个基本表中引出的表。数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。 由于视图本身并不存储实际数据，因此也可以称之为虚表。视图中的数据来自定义视图的查询所引用的基本表，并在引用时动态生成数据。当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。视图一经定义，就可以像基本表一样被查询、修改、删除和更新了。 ③ 索引： 索引是一种不用扫描整个数据表就可以对表中的数据实现快速访问的途径，它是对数据表中的一列或者多列数据进行排序的一种结构。 表中的记录通常按其输入的时间顺序存放，这种顺序称为记录的物理顺序。为了实现对表记录的快速查询，可以对表的记录按某个或某些属性进行排序，这种顺序称为逻辑顺序。 索引是根据索引表达式的值进行逻辑排序的一组指针，它可以实现对数据的快速访问，索引是关系数据库的内部实现技术，它被存放在存储文件中。 ④ 约束： 约束机制保障了SQL Server 2008中数据的一致性与完整性，具有代表性的约束就是主键和外键。主键约束当前表记录的唯一性，外键约束当前表记录与其他表的关系。 ⑤ 存储过程： 存储过程是一组为了完成特定功能的SQL语句集合（功能函数）。这个语句集合经过编译后存储在数据库中，存储过程具有接受参数、输出参数、返回单个或多个结果以及返回值的功能。存储过程独立于表存在（表不存在，存储过程存在，但是会出错）。 存储过程有与函数类似的地方，但它又不同于函数，例如，它不返回取代其名称的值，也不能直接在表达式中使用。 ① 触发器： 触发器与表紧密关联。它可以实现更加复杂的数据操作，更加有效地保障数据库系统中数据的完整性和一致性。触发器基于一个表创建，但可以对多个表进行操作。 ② 默认值： 默认值是在用户没有给出具体数据时，系统所自动生成的数值。它是SQL Server 2008系统确保数据一致性和完整性的方法。 ③ 用户和角色： 用户是指对数据库有存取权限的使用者；角色是指一组数据库用户的集合。这两个概念类似于Windows XP的本地用户和组的概念。 ④ 规则： 规则用来限制表字段的数据范围。 ⑤ 类型： 用户可以根据需要在给定的系统类型之上定义自己的数据类型。 ⑥ 函数： 用户可以根据需要在SQL Server 2008上定义自己的函数。 1.1.2 物理数据库 1．页和区 SQL Server 2008中有两个主要的数据存储单位：页和区。 页是用于数据存储的最基本单位。每个页的大小是8 KB。每页的开头是96 B的标头，用于存储有关页的系统信息。紧接着标头存放的是数据行，数据行按顺序排列。数据库表中的每一行数据都不能跨页存储，即表中的每一行数据字节数不能超过8192。页的末尾是行偏移表，页中的每一行在偏移表中都有一个对应的条目。每个条目记录着对应行的第一个字节与页首部的距离。 区是用于管理空间的基本单位。每8个连接的页组成一个区，大小为64 KB，即每1 MB的数据库就有16个区。区用于控制表和索引的存储。 2．数据库文件 SQL Server 2008所使用的文件包括以下三类文件。 （1）主数据文件。主数据文件简称主文件，正如其名字所示，该文件是数据库的关键文件，包含了数据库的启动信息，并且存储数据。每个数据库必须有且仅能有一个主文件，其默认扩展名为.mdf。可直接拷贝 （2）辅助数据文件。辅助数据文件简称辅（助）文件，用于存储未包括在主文件内的其他数据。辅助文件的默认扩展名为.ndf。辅助文件是可选的，根据具体情况，可以创建多个辅助文件，也可以不使用辅助文件。一般当数据库很大时，有可能需要创建多个辅助文件。而当数据库较小时，则只需要创建主文件而不需要创建辅助文件。 （3）日志文件。日志文件用于保存恢复数据库所需的事务日志信息。每个数据库至少有一个日志文件，也可以有多个，日志文件的扩展名为.ldf。日志文件的存储与数据文件不同，它包含一系列记录，这些记录的存储不以页为存储单位。 3．文件组 使用文件组可以提高表中数据的查询性能。在SQL Server 2008中有两类文件组。 （1）主文件组。主文件组包含主要数据文件和任何没有明确指派给其他文件组的其他文件。管理数据库的系统表的所有页均分配在主文件组中。 （2）用户定义文件组。用户定义文件组是指在CREATE DATABASE或ALTER DATABASE语句中使用FILEGROUP关键字指定的文件组。 每个数据库中都有一个文件组作为默认文件组运行。若在SQL Server 2008中创建表或索引时没有为其指定文件组，那么将从默认文件组中进行存储页分配、查询等操作。用户可以指定默认文件组，如果没有指定默认文件组，则主文件组是默认文件组。 2.数据库和数据库文件 2.1.1 数据库的组成 　　从操作系统的角度看，作为存储数据的逻辑对象，数据库最终是以文件的形式保存在磁盘上。这些文件就是所谓的数据库文件。数据库文件又分为数据文件和日志文件。 　　数据文件是数据库用于存储数据的操作系统文件，它保存了数据库中的全部数据。数据文件又分为主数据文件和次要数据文件。主数据文件是数据库的起点，指向数据库的其他文件。每个数据库有且仅有一个主数据文件，而次要数据文件可以有多个或没有。主数据文件的默认扩展名是.mdf，次要数据文件的默认扩展名是.ndf。 日志文件记录了针对数据库的所有修改操作，其中每条日志记录可能是记录了所执行的逻辑操作，也可能记录了已修改数据的前像和后像。前像是操作执行前的数据复本；后像是操作执行后的数据复本。日志文件包含了用于恢复数据库的所有日志信息。利用日志文件，可以在数据库出现故障或崩溃时把它恢复到最近的状态，从而最大限度地减少由此带来的损失。在创建数据库的时候，默认创建一个日志文件被，其推荐的文件扩展名是.ldf。每个数据库至少有一个日志文件，当然也可以有多个。 　　数据文件和日志文件可以保存在FAT或NTFS文件系统中。但从安全性角度考虑，一般使用NTFS文件系统保存这些文件。数据文件名和日志文件名是面向操作系统的，即操作系统是通过这些名称来访问数据文件和日志文件。 　　从逻辑结构看，数据库是数据表的集合，此外数据库还包含索引、视图等“附属部件”，数据表、索引、视图等统称为数据库对象。在创建数据库的时候，我们要给数据库输入一个合法的字符串作为数据库的名称，这个名称简称为数据库名。 　　数据库名是数据库的逻辑名称，应用程序对数据库对象的访问必须通过数据库名来完成，即数据库名是面向应用程序的（而非操作系统，数据库文件是面向操作系统的）。另外，支撑数据库的数据文件和日志文件也有面向应用程序的名称，分别称为数据文件和日志文件的逻辑文件名。通过逻辑文件名，SQL语句就可以有限度地访问和操作数据文件和日志文件。为了区别于逻辑文件名，数据文件和日志文件对应的磁盘文件（即.mdf文件、.ndf文件、.ldf文件）称为它们的物理文件名。 　　对于每个数据文件和日志文件，它们既有自己的逻辑文件名（面向应用程序），也有自己的物理文件名（面向操作系统）。在SQL Server 2014中，当创建数据库时会自动生成一个主数据文件和一个日志文件。在默认情况下，主数据文件的逻辑文件名与数据库名（数据库名由用户设置）相同，其物理文件名等于其逻辑文件名加上扩展名“.mdf”；日志文件的逻辑文件名等于数据库名加上“_log”，日志文件的物理文件名等于数据库名加上“_log.ldf”。 【例子】 当创建一个名为MyDatabase的数据库时，会自动形成一个主数据文件和一个日志文件，其默认的逻辑文件和物理文件名如表7.1所示。 2.1.2 文件组 　　文件组是数据文件的一种逻辑划分。文件组就是将若干个数据文件放在一起而形成的文件集。 　　文件组有两种类型：主文件组（PRIMARY）和用户定义文件组。 　　　　主文件组包含主数据文件和任何没有明确指定文件组的其他数据文件。 　　　　用户定义文件组是用户利用Transact-SQL语句或者在SQL Server Management Studio（SSMS）中通过可视化操作创建的文件组。 　　 一个文件组包含多个不同的数据文件，一个数据文件只能属于一个文件组。一个数据库至少有一个文件组（主文件组），也可能有多个文件组（至多为32767个文件组）。在一个数据库中，有且仅有一个文件组被指定为默认文件组。在数据库创建时主文件组会自动被设置为默认文件组，但我们也可以将用户定义文件组设置为默认文件组。在创建数据表或者其他数据库对象的时候，如果不显式指定文件组，那么这些数据库对象将自动在默认文件组上创建，即被建对象的所有页都在默认文件组中分配。 3. 系统数据库和用户数据库 　　系统数据库存储有关SQL Server的系统信息，它们是SQL Server 2008管理数据库的依据。如果系统数据库遭到破坏，那么SQL Server将不能正常启动。在安装SQL Server 2008时，系统将创建4个可见的系统数据库：master、model、msdb和tempdb。 （1）master数据库包含了SQL Server 2008的登录账号、系统配置、数据库位置及数据库错误信息等，控制用户数据库和SQL Server的运行。 （2）model数据库为新创建的数据库提供模板。 （3）msdb数据库为“SQL Server代理”调度信息和作业记录提供存储空间。 （4）tempdb数据库为临时表和临时存储过程提供存储空间，所有与系统连接的用户的临时表和临时存储过程都存储于该数据库中。 每个系统数据库都包含主数据文件和主日志文件。扩展名分别为.mdf 和.ldf，例如master数据库的两个文件分别为master.mdf和master.ldf。 "},"page/11227.html":{"url":"page/11227.html","title":"连接","keywords":"","body":"连接 "},"page/11228.html":{"url":"page/11228.html","title":"MSSQL","keywords":"","body":"SQL Server "},"page/11237.html":{"url":"page/11237.html","title":"W-2014界面-云端允许连接","keywords":"","body":"1.开放端口 1.1云服务商端口开放1433 1.2云主机设置策略 2.连接 2.1云端登录 2.2数据库允许连接 2.3新建远程用户（为了安全，不直接用管理员） 新建用户 设置权限 2.4服务器配置 2.5找到SQL SERVER 配置管理器并打开 (开始目录-->Microsoft SQL Server2012-->配置工具中) 2.6启动服务 完成 "},"page/11229.html":{"url":"page/11229.html","title":"W-2008界面-连本地","keywords":"","body":"2008界面连本地 点击开始菜单 点击所有程序 找到Microsoft SQL Server 2008 R2文件夹，并点击打开 找到配置工具文件夹，并点击打开 找到SQL Server 配置管理器，并点击打开 点击左侧SQLServer服务 找到右侧SQL Server(MSSQLSERVER0)服务，并右击启动 点击开始菜单 点击所有程序 找到Microsoft SQL Server 2008 R2文件夹，并点击打开 找到SQL Server Management Studio应用程序，并点击打开 点击服务器名称选项框填写部分尾端的下三角符号，选择自己对应的上面启动的服务，如我的ZS305-7\\MSSQLSERVER0，其中7为座位号 点击连接 "},"page/11230.html":{"url":"page/11230.html","title":"W-2014界面-连本地","keywords":"","body":"2014界面连本地 1.开始-->Microsoft SQL Server 2014-->SQL Server Management Studio 2.连接 成功安装SQL Server 2014后，打开Windows操作系统的菜单：选择菜单“所有程序”|“Microsoft SQL Server 2014”|“SQL Server 2014 Management Studio”，即可打开SQL Server 2014的“连接到服务器”对话框，如图所示 “连接到服务器”对话框中各项的含义和使用方法将在后面详细介绍。为了观看效果，请先按照下列说明输入相关选项的值： 服务器类型：选择“数据库引擎” 服务器名称：输入SQL Server 2014所在的计算机的名称，笔者的计算机名称为“MZQ”（刚在此台计算机上安装了SQL Server 2014） 身份验证：选择“SQL Server身份验证” 登录名：输入“sa”，sa是管理员用户，具有最高、最全的权限，故sa也称为超级用户 密码：输入“sql123”，这是在安装时设置的 3.文件-->连接对象资源管理器 4.连接 各项设置完毕后，单击【连接】按钮，即可登录SQL Server 2014，如图所示，这就是SQL Server 2014功能管理工具——SQL Server 2014 Management Studio（简称SSMS）。 在SSMS中，可以用两种方式操作SQL Server 2014 基于鼠标的可视化操作，在可视化操作中，用鼠标通过右击“对象资源管理器”中的对象，实现对该对象的可视化操作，包括创建数据库、创建数据表等。这对入门者比较直观，容易上手，但过程繁琐，不利于大规模开发。 代码操作则是指通过编写SQL代码来操作SQL Server 2014。SQL语句（代码）才是关系数据库的“灵魂”。这是因为随着版本的升级，SQL Server管理界面会不断发生变化，而SQL代码变化则很少，甚至不变，因此可“以不变应万变”；如果用SQL代码操纵数据库对象（包括创建、查看、更新、删除等操作），则由于SQL代码容易保存下来，这样下次工作可以较为容易地在这次工作的基础上继续深入，方便修改和完善，而且SQL代码容易移植到别的机器上。本书主要介绍如何使用代码来操作SQL Server 2014。 为编写和执行SQL代码，在下图所示的SSMS界面中单击“新建查询”快捷菜单，即可打开一个SQL代码编辑器窗口，在此编辑器窗口中输入和编辑SQL代码，然后单击“执行”快捷菜单即可执行编辑器中的SQL代码。如果选中某些SQL代码，然后单击“执行”快捷菜单，则表示执行被选中的代码。 SSMS中的SQL代码编辑器 注意，可以通过多次单击“新建查询”快捷菜单来打开多个代码编辑器窗口，从而可以建立多个会话。 "},"page/11231.html":{"url":"page/11231.html","title":"LW-DBeaver界面-连本地","keywords":"","body":"linux-DBeaver界面-连本地 "},"page/11236.html":{"url":"page/11236.html","title":"LW-Navicat界面-连本地","keywords":"","body":"LW-Navicat界面-连本地 "},"page/11232.html":{"url":"page/11232.html","title":"W-命令-连本地","keywords":"","body":"win-命令-连本地 "},"page/11233.html":{"url":"page/11233.html","title":"L-命令-连本地","keywords":"","body":"linux-命令-连本地 "},"page/11234.html":{"url":"page/11234.html","title":"LW-DBeaver界面-连本地","keywords":"","body":"linux-DBeaver界面-连本地 "},"page/11235.html":{"url":"page/11235.html","title":"LW-DBeaver界面-连云端","keywords":"","body":"linux-DBeaver界面-连云端 "},"page/11338.html":{"url":"page/11338.html","title":"jdbc-mysql","keywords":"","body":"jdbc-mysql JDBC Java提供了专门用于操作数据库的API，即JDBC （Java DataBase Connection）。JDBC操作不同的数据库仅仅是连接方式上的差异而已，使用JDBC的应用程序一旦和数据库建立连接，就可以使用JDBC提供的API操作数据库（如图11.15）.程序经常使用JDBC进行如下的操作 ： (1)与一个数据库建立连接。 (2)向数据库发送SQL语句。 (3)处理数据库返回的结果。 连接MySQL数据库 MySQL数据库服务器启动后（见11.2），应用程序为了能和数据库交互信息，必须首先和MySQL数据库服务器上的数据库建立连接。目前在开发中常用的连接数据库的方式是加载JDBC-数据库驱动（连接器）（用Java语言编写的数据库驱动称作JDBC-数据库驱动），即JDBC调用本地的JDBC-数据库驱动和相应的数据库建立连接，如图11.16所示意。Java运行环境将JDBC-数据库驱动转换为DBMS（数据库管理系统）所使用的专用协议来实现和特定的DBMS交互信息。 使用 1．下载JDBC-MySQL数据库驱动 可以登录MySQL的官方网站：www.mysql.com，下载JDBC-MySQL数据库驱动（JDBC Driver for MySQL）。 教材下载的是mysql-connector-java-5.1.40.zip，将该zip文件解压至硬盘，在解压后的目录下的mysql-connector-java-5.1.40-bin.jar文件就是连接MySQL数据库的JDBC-数据库驱动。将该驱动复制到JDK的扩展目录中（即JAVA_HOME环境变量指定的JDK），比如：E:\\jdk1.8\\jre\\lib\\ext。 也可以在工程中直接添加： 右击工程文件夹属性选项-构建-项目属性-库-添加JAR/文件夹，添加这个文件： …\\mysql-connector-java-5.0.8-bin.jar 2.加载JDBC-MySQL数据库驱动 应用程序负责加载的JDBC-MySQL数据库驱动，代码如下： try{ Class.forName(\"com.mysql.jdbc.Driver\"); } catch(Exception e){} MySQL数据库驱动被封装在Driver类中，该类的的包名是com.mysql.jdbc，该类不是Java运行环境类库中的类，所以需要放置在jre的扩展中 不要忘记将下载的mysql-connector-java-5.1.40-bin.jar文 （连接MySQL数据库的JDBC-数据库驱动）复制到JDK的扩展目录中。 常用数据库驱动 MySQL驱动程序：com.mysql.jdbc.Driver Oracle驱动程序：oracle.jdbc.driver.OracleDriver SQLServer驱动程序：com.Microsoft.jdbc.sqlserver.SQLServerDriver 3.连接数据库 应用程序要和MySQL数据库服务器管理的数据库students(在11.3节建立的数据库)建立连接，而有权访问数据库students的用户的id和密码分别是root和空，那么使用Connection getConnection(java.lang.String) 方法建立连接的代码如下： Connection con; //创建连接对象 String uri = \"jdbc:mysql://192.168.100.1:3306/students?user=root&password=&useSSL=true\"; //uri 连接字符串 try{ con = DriverManager.getConnection(uri); //连接代码 //getConnection多个重载方法 } catch(SQLException e){ System.out.println(e); } //如果root用户密码是99，将&password=更改为&password=99即可 常用数据库连接 与MySQL数据库连接的方法： Connection con= DriverManager.getConnection(“jdbc:mysql://主机IP或主机名:3306/数据库名”,用户名，密码); 与Oracle数据库连接的方法： Connection con= DriverManager.getConnection(“jdbc:oracle:thin:@主机IP或主机名:1521:数据库名”,用户名,密码); //主机名仅限局域网 与SQLServer数据库连接的方法： Connection con= DriverManager.getConnection(“jdbc:microsoft:sqlserver://主机IP或主机名:1433:数据库名”,用户名,密码); 使用 Connection getConnection(java.lang.String, java.lang.String, java.lang.String) 方法建立连接的代码如下： Connection con; String uri = \"jdbc:mysql:// 192.168.100.1:3306/students? useSSL=true\"; String user =\"root\"; String password =\"\"; try{ con = DriverManager.getConnection(uri,user,password); //连接代码 } catch(SQLException e){ System.out.println(e); } 4、创建Statement对象 Statement st=con.createStatement(); 利用Statement对象可以执行静态SQL语句，静态SQL语句可以是Select语句、Delete语句、Update语句和Insert语句。 也可以使用Connection对象的preparedStatement()方法创建一个preparedStatement对象，用于执行动态SQL语句。动态SQL语句用“？”作为所有动态参数的占位符，先进行预编译，当给占位符所在的变量赋值后，再执行该动态SQL语句。 标准的sql都是静态，有参数的是动态 例： str=\"insert into mycustomer values(?,?,?,?,?)\"; PreparedStatement pst=con.prepareStatement(str); id=5; //各变量赋值 name=\"qiansheng\"; age=34; address=\"wenzhou\"; email=\"qiansheng@163.com\"; pst.setInt(1,id);//设置占位符对应的变量值 pst.setString(2,name); //1第一个问号，2第二个问号 pst.setInt(3,age); pst.setString(4,address); pst.setString(5,email); pst.execute(); 5、执行SQL语句 Statement接口提供了许多创建和执行SQL语句的方法。其中，executeQuery()方法执行SQL select语句，返回包含满足指定SQL语句条件的记录组成的结果集；executeUpdate()方法执行SQL的更新语句，包括Update语句、Delete语句和Insert语句。例： str=\"insert into customer values ('wangyang',24,'beijing','wangyang@sina.com')\"; int recordNumber=st.executeUpdate(str); //增删改 //多少行受影响的多少行recordNumber，可以没有 执行executeUpdate()方法返回该SQL语句涉及的记录数。 str=\"select * from mycustomer\"; //查询表中记录 ResultSet rs=st.executeQuery(str); //二维表结果集rs 由于SQL语句是select，用executeQuery()方法，返回一个结果集保存在ResultSet对象rs中。 6、处理ResultSet对象中的数据。 例： while(rs.next()){ //通过next方法一行一行读取 id=rs.getInt(\"id\"); name=rs.getString(\"cName\"); age=rs.getInt(\"cAge\"); address=rs.getString(\"cAddress\"); email=rs.getString(\"cEmail\"); System.out.println(id+\" \"+name+\" \"+age+\" \"+address+\" \"+email); } 7、关闭连接 例： rs.close(); st.close(); con.close() ResultSet对象和数据库连接对象（Connection对象）实现了紧密的绑定，一旦连接对象被关闭，ResultSet对象中的数据立刻消失。 程序将无法获取rs中的数据 操作数据库代码-无界面（详见Word文档） 注意 注意汉字问题 需要特别注意的是，如果数据库的表中的记录有汉字，那么在建立连接时需要额外多传递一个参数characterEncoding，并取值gb2312或utf-8 gb2312繁体很少见的字没有 String uri = \"jdbc:mysql://localhost/students?useSSL=true&characterEncoding=utf-8\"; con = DriverManager.getConnection(uri, \"root\",\"\"); //连接代码 "},"page/11016.html":{"url":"page/11016.html","title":"基础","keywords":"","body":"基础 "},"page/11137.html":{"url":"page/11137.html","title":"标识符","keywords":"","body":"标识符 Transact-SQL 在数据库编程中，要访问任何一个逻辑对象（如变量、过程、触发器等）都需要通过其名称来完成。逻辑对象的名称是利用合法的标识符来表示的，是在创建、定义对象时设置的，此后就可以通过名称来引用逻辑对象。 　　标识符有两种类型：常规标识符和分隔标识符。 　　常规标识符在使用时不需将其分隔开，要符合标识符的格式规则。 　　　　这些规则就是，标识符中的首字符必须是英文字母、数字、_（下划线）、@、#或汉字， 　　　　首字符后面可以是字母、数字、下划线、@和$等字符，可以包含汉字。 　　　　标识符一般不能与SQL Server的关键字重复， 　　　　也不应以@@开头（因为系统全局变量的标识符是以@@开头）， 　　　　不允许嵌入空格或其他特殊字符等。 　　分隔标识符是指包含在两个单引号(' ') 或者方括号([ ]) 内的字符串，这些字符串中可以包含空格。 "},"page/11308.html":{"url":"page/11308.html","title":"MSSQL","keywords":"","body":"MSSQL 标识符 在数据库编程中，要访问任何一个逻辑对象（如变量、过程、触发器等）都需要通过其名称来完成。逻辑对象的名称是利用合法的标识符来表示的，是在创建、定义对象时设置的，此后就可以通过名称来引用逻辑对象。 标识符有两种类型：常规标识符和分隔标识符。 常规标识符在使用时不需将其分隔开，要符合标识符的格式规则。这些规则就是，标识符中的首字符必须是英文字母、数字、_（下划线）、@、#或汉字，首字符后面可以是字母、数字、下划线、@和$等字符，可以包含汉字。标识符一般不能与SQL Server的关键字重复，也不应以@@开头（因为系统全局变量的标识符是以@@开头），不允许嵌入空格或其他特殊字符等。 分隔标识符是指包含在两个单引号 (' ') 或者方括号 ([ ]) 内的字符串，这些字符串中可以包含空格。 "},"page/11138.html":{"url":"page/11138.html","title":"关键字","keywords":"","body":"关键字 Transact-SQL 关键字也称为保留字，是SQL Server预留作专门用途的一类标识符。例如，ADD、EXCEPT、PERCENT等都是保留关键字。用户定义的标识符不能与保留关键字重复。 "},"page/11309.html":{"url":"page/11309.html","title":"MSSQL","keywords":"","body":"MSSQL 关键字也称为保留字，是SQL Server预留作专门用途的一类标识符。例如，ADD、EXCEPT、PERCENT等都是保留关键字。用户定义的标识符不能与保留关键字重复。 "},"page/11139.html":{"url":"page/11139.html","title":"预定义标识符","keywords":"","body":"预定义标识符 "},"page/11310.html":{"url":"page/11310.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11140.html":{"url":"page/11140.html","title":"用户自定义标识符","keywords":"","body":"用户自定义标识符 "},"page/11311.html":{"url":"page/11311.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11285.html":{"url":"page/11285.html","title":"MSSQL变量","keywords":"","body":"1．变量 变量名必须是一个合法的标识符。 （1）标识符。在SQL Server中标识符分为两类。 常规标识符：以ASCII字母、Unicode字母、下划线（_）、@或#开头，后续可跟一个或若干个ASCII字符、Unicode字符、下划线（_）、美元符号（$）、@或#，但不能全为下划线（_）、@或#。 注意：常规标识符不能是T-SQL的保留字。常规标识符中不允许嵌入空格或其他特殊字符。 分隔标识符：包含在双引号（\"）或者方括号（[ ]）内的常规标识符或不符合常规标识符规则的标识符。 标识符允许的最大长度为128个字符。符合常规标识符格式规则的标识符可以分隔，也可以不分隔。对不符合标识符规则的标识符必须进行分隔。 （2）变量的分类。 SQL Server中变量可分为两类。 全局变量： 全局变量由系统提供且预先声明，通过在名称前加两个“@”来区别于局部变量。T-SQL全局变量作为函数引用。 例如，@@ERROR返回执行的上一个T-SQL语句的错误号；@@CONNECTIONS返回自上次启动SQL Server以来连接或试图连接的次数。 相当于函数 局部变量： 局部变量用于保存单个数据值。例如，保存运算的中间结果，作为循环变量等。 当首字母为“@”时，表示该标识符为局部变量名； 当首字母为“#”时，此标识符为一临时数据库对象名，若开头含一个“#”，表示局部临时数据库对象名；若开头含两个“#”，表示全局临时数据库对象名。 局部变量的使用 （1）局部变量的定义与赋值。 ① 局部变量的定义。 在批处理或过程中用DECLARE语句声明局部变量，所有局部变量在声明后均初始化为NULL。语法格式： DECLARE { @local_variable data_type [= value]} [ ,...n] 说明如下。 local_variable：局部变量名，应为常规标识符。前面的“@”表示是局部变量。 data_type：数据类型，用于定义局部变量的类型，可为系统类型或自定义类型。 =value：为变量赋值，值可以是常量或表达式，但它必须与变量声明类型匹配。 n：表示可定义多个变量，各变量间用逗号隔开。 ② 局部变量的赋值。 当声明局部变量后，可用SET或SELECT语句为其赋值。 用SET语句赋值： 将DECLARE语句创建的局部变量设置为给定表达式的值。语法格式： SET @local_variable＝expression //set一个变量赋值，select可以给多个 【例5.2】 创建局部变量@var1、@var2并赋值，然后输出变量的值。 DECLARE @var1 char(10) ,@var2 char(30) SET @var1='中国' /*一个SET语句只能为一个变量赋值*/ SET @var2=@var1+'是一个伟大的国家' SELECT @var1, @var2 //输出语句 GO 执行结果如下： 【例5.3】 创建一个名为sex的局部变量，并在SELECT语句中使用该局部变量查找表XSB中所有女同学的学号、姓名。 USE PXSCJ GO DECLARE @sex bit SET @sex=0 SELECT 学号, 姓名 FROM XSB WHERE 性别=@sex 执行结果如下： 【例5.4】 使用查询为变量赋值。 DECLARE @student char(8) SET @student=(SELECT 姓名 FROM XSB WHERE 学号= '081101') SELECT @student 用SELECT语句赋值： 语法格式： SELECT {@local_variable=expression} [,…n] //前面可以出现多次 关于SELECT，需说明以下几点： SELECT @local_variable 通常用于将单个值返回到变量中。如果expression为列名，则返回多个值，此时将返回的最后一个值赋给变量。（会把多个值最后一个给　＝ａ,b,c则　赋值ｃ） 如果SELECT 语句没有返回行，变量将保留当前值。 如果expression是不返回值的标量子查询，则将变量设为 NULL。 一个SELECT语句可以初始化多个局部变量。 【例5.5】 使用SELECT语句为局部变量赋值。 DECLARE @var1 nvarchar(30) SELECT @var1 ='刘丰' //赋值 SELECT @var1 AS 'NAME'　//输出 执行结果如下： 【例5.6】 为局部变量赋空值。 DECLARE @var1 nvarchar(30) SELECT @var1 = '刘丰' SELECT @var1 = ( SELECT 姓名 FROM XSB WHERE 学号= '089999' ) SELECT @var1 AS 'NAME' 执行结果如下： （2）局部游标变量的定义与赋值。 ① 局部游标变量的定义。 语法格式： DECLARE { @cursor_variable_name CURSOR } [ ,...n] @cursor_variable_name是局部游标变量名，应为常规标识符。前面的“@”表示是局部的。CURSOR表示该变量是游标变量。 ② 局部游标变量的赋值。 利用SET语句为一个游标变量赋值，有三种情况： 将一个已存在的并且赋值的游标变量的值赋给另一个局部游标变量。 将一个已声明的游标名赋给指定的局部游标变量。 声明一个游标，同时将其赋给指定的局部游标变量。 上述三种情况的语法描述如下。 语法格式： SET { @cursor_variable = { @cursor_variable /*将一个已赋值的游标变量的值赋给一个目标游标变量*/ | cursor_name /*将一个已声明的游标名赋给游标变量*/ | { CURSOR 子句 } /*游标声明*/ } } ③ 游标变量的使用步骤如下。 定义游标变量→给游标变量赋值→打开游标→利用游标读取行（记录）→使用结束后关闭游标→删除游标的引用。 【例5.7】 使用游标变量。 USE PXSCJ GO DECLARE @CursorVar CURSOR /*定义游标变量*/ SET @CursorVar = CURSOR SCROLL DYNAMIC /*为游标变量赋值*/ FOR SELECT 学号, 姓名 FROM XSB WHERE 姓名 LIKE '王%' OPEN @CursorVar /*打开游标*/ FETCH NEXT FROM @CursorVar FETCH NEXT FROM @CursorVar /*通过游标读行记录*/ CLOSE @CursorVar DEALLOCATE @CursorVar /*删除对游标的引用*/ （3）表数据类型变量的定义与赋值。 语法格式： DECLARE { @table_variable_name [AS] TABLE ( { | } [ ,... ] ) } 【例5.8】 声明一个表数据类型变量并向变量中插入数据。 DECLARE @var_table //表数据类型的变量 AS TABLE ( num char(6) NOT NULL PRIMARY KEY, name char(8) NOT NULL, sex bit NULL ) /*声明变量*/ INSERT INTO @var_table SELECT 学号,姓名,性别 FROM XSB /*插入数据*/ SELECT * FROM @var_table /*查看内容　ｓｅｌｅｃｔ　ｆｒｏｍ　可以是　表、视图、（表）变量*/ "},"page/11141.html":{"url":"page/11141.html","title":"行与缩进","keywords":"","body":"行与缩进 "},"page/11312.html":{"url":"page/11312.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11142.html":{"url":"page/11142.html","title":"大小写","keywords":"","body":"大小写 "},"page/11313.html":{"url":"page/11313.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11143.html":{"url":"page/11143.html","title":"注释","keywords":"","body":"注释 Transact-SQL Transact-SQL语言中有两种注释，一种是行单行注释，一种是多行注释。它们分别用符号“--”（连续的两个减号）和“/ /”来实现。 注释是Transact-SQL程序代码中不被执行的文本部分，其作用是说明程序各模块的功能和设计思想，以方便程序的修改和维护。 　　注释有两种方法，一种是用“--”（紧连的两个减号）来注释，另一种是用“/**/”来注释，它们都称为注释符。其中： • --：用于注释一行代码，被注释的部分是从注释符“--”开始一直到其所在行末尾的部分。 • / /：用于注释多行代码，被注释的部分包含在两个星号的中间。 【例子】 下面一段代码中同时使用了这两种注释： USE MyDatabase; -- 使用数据库MyDatabase GO /* 该程序用于查询成绩及格的学生信息，包括学生姓名、性别、平均成绩。 程序编写者：xxx 程序编写时间：2017年12月31日 */ SELECT s_name, s_sex, s_avgrade --姓名、性别、平均成绩 FROM student --在表中查询 GO "},"page/11314.html":{"url":"page/11314.html","title":"MSSQL","keywords":"","body":"MSSQL Transact-SQL语言中有两种注释，一种是行单行注释，一种是多行注释。它们分别用符号“--”（连续的两个减号）和“/ /”来实现。 注释是Transact-SQL程序代码中不被执行的文本部分，其作用是说明程序各模块的功能和设计思想，以方便程序的修改和维护。 注释有两种方法，一种是用“--”（紧连的两个减号）来注释，另一种是用“/**/”来注释，它们都称为注释符。 其中： --：用于注释一行代码，被注释的部分是从注释符“--”开始一直到其所在行末尾的部分。 / /：用于注释多行代码，被注释的部分包含在两个星号的中间。 【例子】 下面一段代码中同时使用了这两种注释： USE MyDatabase; -- 使用数据库MyDatabase GO /* 该程序用于查询成绩及格的学生信息，包括学生姓名、性别、平均成绩。 程序编写者：xxx 程序编写时间：2017年12月31日 */ SELECT s_name, s_sex, s_avgrade --姓名、性别、平均成绩 FROM student --在表中查询 GO "},"page/11144.html":{"url":"page/11144.html","title":"编码","keywords":"","body":"编码 "},"page/11315.html":{"url":"page/11315.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11145.html":{"url":"page/11145.html","title":"语句结束","keywords":"","body":"语句结束 "},"page/11316.html":{"url":"page/11316.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11017.html":{"url":"page/11017.html","title":"风格","keywords":"","body":"风格 "},"page/11131.html":{"url":"page/11131.html","title":"MSSQL","keywords":"","body":"SQL Server "},"page/11132.html":{"url":"page/11132.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11146.html":{"url":"page/11146.html","title":"元素","keywords":"","body":"元素 "},"page/11147.html":{"url":"page/11147.html","title":"对象","keywords":"","body":"组成 "},"page/11205.html":{"url":"page/11205.html","title":"MSSQL","keywords":"","body":"SQL Server 表和表结构 每个数据库包含了若干个表。表是SQL Server中最主要的数据库对象，它是用来存储数据的一种逻辑结构。表由行和列组成，因此也称为二维表。表是在日常工作和生活中经常使用的一种表示数据及其关系的形式，表3.1就是用来表示学生情况的一个学生表。 表3.1 学生表 学 号 姓 名 性 别 出 生 时 间 专 业 总 学 分 备 注 081101 王林 男 1990-02-10 计算机 50 081103 王燕 女 1989-10-06 计算机 50 081108 林一帆 男 1989-08-05 计算机 52 已提前修完一门课 081202 王林 男 1989-01-29 通信工程 40 有一门课不及格，待补考 081204 马琳琳 女 1989-02-10 通信工程 42 下面简单介绍与表有关的几个概念： （1）表结构。组成表的各列的名称及数据类型，统称为表结构。 （2）记录。每个表包含了若干行数据，它们是表的“值”，表中的一行称为一个记录。因此，表是记录的有限集合。 （3）字段。每个记录由若干个数据项构成，将构成记录的每个数据项称为字段。例如，表3.1中表结构为（学号，姓名，性别，出生时间，专业，总学分，备注），包含7个字段，由5个记录组成。 （4）空值。空值（NULL）通常表示未知、不可用或将在以后添加的数据。若一个列允许为空值，则向表中输入记录值时可不为该列给出具体值；而一个列若不允许为空值，则在输入时必须给出具体值。 （5）关键字。若表中记录的某一字段或字段组合能唯一标识记录，则称该字段或字段组合为候选关键字（Candidate key）。若一个表有多个候选关键字，则选定其中一个为主关键字（Primary key），也称为主键。当一个表仅有唯一的一个候选关键字时，该候选关键字就是主关键字。这里的主关键字与第1章中的主码所起的作用是相同的，都用来唯一标识记录行。 例如，在学生表中，2个及其以上记录的姓名、性别、出生时间、专业、总学分和备注这6个字段的值有可能相同，但是“学号”字段的值对表中所有记录来说一定不同，即通过“学号”字段可以将表中的不同记录区分开来。所以，“学号”字段是唯一的候选关键字，学号就是主关键字。再例如，学生成绩表记录的候选关键字是（学号，课程号）字段组合，它也是唯一的候选关键字。 视图概念 视图一经定义以后，就可以像表一样被查询、修改、删除和更新。使用视图有下列优点： （1）为用户集中数据，简化用户的数据查询和处理。有时用户所需要的数据分散在多个表中，定义视图可将它们集中在一起，从而方便用户进行数据查询和处理。 （2）屏蔽数据库的复杂性。用户不必了解复杂的数据库中的表结构，并且数据库表的更改也不影响用户对数据库的使用。 （3）简化用户权限的管理。只需授予用户使用视图的权限，而不必指定用户只能使用表的特定列，也增加了安全性。 （4）便于数据共享。各用户不必都定义和存储自己所需的数据，而可共享数据库的数据，这样，同样的数据只需存储一次。 （5）可以重新组织数据以便输出到其他应用程序中。 在使用视图时，要注意下列事项： （1）只有在当前数据库中才能创建视图。视图的命名必须遵循标识符命名规则，不能与表同名。 （2）不能把规则、默认值或触发器与视图相关联。 游标概念 一个对表进行操作的T-SQL语句通常都可产生或处理一组记录，但是许多应用程序，尤其是T-SQL嵌入到的主语言，通常不能把整个结果集作为一个单元来处理，这些应用程序就需要一种机制来保证每次处理结果集中的一行或几行，游标（cursor）就提供了这种机制。 如果修改字段含义或对字段表示的状态追加时,需要及时更新字段注释。SQL Server通过游标提供了对一个结果集进行逐行处理的能力，游标可看做一种特殊的指针，它与某个查询结果相联系，可以指向结果集的任意位置，以便对指定位置的数据进行处理。使用游标可以在查询数据的同时对数据进行处理。 在SQL Server中，有两类游标可以用于应用程序中：前端（客户端）游标和后端（服务器端）游标。服务器端游标是由数据库服务器创建和管理的游标，而客户端游标是由ODBC 和DB-Library 支持，在客户端实现的游标。 SQL Server对游标的使用要遵循“声明游标→打开游标→读取数据→关闭游标→删除游标”的过程。 索引 索引是根据表中一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表。 在数据库系统中建立索引主要有以下作用： 快速存取数据； 保证数据记录的唯一性； 实现表与表之间的参照完整性； 在使用ORDER BY、GROUP BY子句进行数据检索时，利用索引可以减少排序和分组的时间。 1．聚集索引 聚集索引将数据行的键值在表内排序并存储对应的数据记录，使得数据表物理顺序与索引顺序一致。SQL Server 2008是按B树（BTREE）方式组织聚集索引的，B树方式构建为包含了多个节点的一棵树。顶部的节点构成了索引的开始点，叫做根。 每个表只会有一个聚集索引。 由于数据记录按聚集索引键的次序存储，故聚集索引对查找记录很有效。 按照特定索引 2．非聚集索引 非聚集索引完全独立于数据行的结构。SQL Server 2008也是按B树方式组织非聚集索引的，与聚集索引的不同之处在于：非聚集索引B树的叶节点不存放数据页信息，而是存放非聚集索引的键值，并且每个键值项都有指针指向包含该键值的数据行。 只有在表上创建聚集索引时，表内的行才按特定顺序存储，这些行按聚集索引键顺序存储。如果一个表只有非聚集索引，则它的数据行将按无序的堆集方式存储。 按照录入序号 存储过程 在SQL Server 2008中，使用T-SQL语句编写存储过程。存储过程可以接收输入参数、返回表格或标量结果和消息，调用“数据定义语言（DDL）”和“数据操作语言（DML）”语句，然后返回输出参数。 使用存储过程的优点如下： （1）存储过程在服务器端运行，执行速度快。 （2）存储过程执行一次后，就驻留在高速缓冲存储器，在以后的操作中，只需从高速缓冲存储器中调用已编译好的二进制代码执行，提高了系统性能。 （3）使用存储过程可以完成所有数据库操作，并可通过编程方式控制对数据库信息访问的权限，确保数据库的安全。 （4）自动完成需要预先执行的任务。存储过程可以在SQL Server启动时自动执行，而不必在系统启动后再进行手工操作，大大方便了用户的使用，可以自动完成一些需要预先执行的任务。 （1）系统存储过程。系统存储过程是由SQL Server提供的存储过程，可以作为命令执行。系统存储过程定义在系统数据库master中，其前缀是“sp_”，例如，常用的显示系统对象信息的sp_help系统存储过程，为检索系统表的信息提供了方便快捷的方法。系统存储过程允许系统管理员执行修改系统表的数据库管理任务，可以在任何一个数据库中执行。SQL Server 2008提供了很多的系统存储过程，通过执行系统存储过程，可以实现一些比较复杂的操作，本书也介绍了其中一些系统存储过程。要了解所有的系统存储过程，请参考SQL Server联机丛书。 （2）扩展存储过程。扩展存储过程是指在SQL Server 2008环境之外，使用编程语言（如C++语言）创建的外部例程形成的动态链接库（DLL）。使用时，先将DLL加载到SQL Server 2008系统中，并且按照使用系统存储过程的方法执行。扩展存储过程在 SQL Server 实例地址空间中运行；但因为扩展存储过程不易撰写，而且可能会引发安全性问题，所以微软可能会在未来的SQL Server中删除这一功能，本书将不详细介绍扩展存储过程。 （3）用户存储过程。在SQL Server 2008中，用户存储过程可以使用T-SQL语言编写，也可以使用CLR方式编写。在本书中，T-SQL存储过程就称为存储过程。 ① 存储过程：存储过程保存T-SQL语句集合，可以接收和返回用户提供的参数。存储过程中可以包含根据客户端应用程序提供的信息，以及在一个或多个表中插入新行所需的语句。存储过程也可以从数据库向客户端应用程序返回数据。例如，电子商务Web应用程序可能根据联机用户指定的搜索条件，使用存储过程返回有关特定产品的信息。 ② CLR存储过程：CLR存储过程是对Microsoft .NET Framework公共语言运行时（CLR）方法的引用，可以接收和返回用户提供的参数。它们在“.NET Framework 程序集”中是作为类的公共静态方法实现的。简单地说，CLR存储过程就是可以使用Microsoft Visual Studio 2008环境下的语言作为脚本编写的、可以对Microsoft .NET Framework公共语言运行时（CLR）方法进行引用的存储过程。编写CLR存储过程需要有C#语言的基础，本书将在附录D中具体介绍编写CLR存储过程和CLR触发器的方法。 触发器 触发器的类型在SQL Server 2008中，按照触发事件的不同可以将触发器分为两大类：DML触发器和DDL触发器。 （1）DML触发器。当数据库中发生数据操纵语言（DML）事件时将调用DML触发器。一般情况下，DML事件包括对表或视图的INSERT语句、UPDATE语句和DELETE语句，因而DML触发器也可分为三种类型：INSERT、UPDATE和DELETE。 （2）DDL触发器。DDL触发器也是由相应的事件触发的，但DDL触发器触发的事件是数据定义语句（DDL）。这些语句主要是以CREATE、ALTER、DROP等关键字开头的语句。DDL触发器的主要作用是执行管理操作，例如审核系统、控制数据库的操作等。在通常情况下，DDL触发器主要用于以下一些操作需求：防止对数据库架构进行某些修改；希望数据库中发生某些变化以利于相应数据库架构中的更改；记录数据库架构中的更改或事件。DDL触发器只在响应由T-SQL语法所指定的DDL事件时才会触发。 "},"page/11206.html":{"url":"page/11206.html","title":"MySQL","keywords":"","body":"MySQL "},"page/11148.html":{"url":"page/11148.html","title":"数据类型","keywords":"","body":"数据类型 Transact-SQL 与其他编程语言一样，Transact-SQL语言也有自己的数据类型。数据类型在定义数据对象（如列、变量和参数等）时是必须的。自SQL Server 2008版本开始就新增了XML数据类型，以用于保存XML数据。Transact-SQL语言的其他数据类型与SQL的相同。 "},"page/11252.html":{"url":"page/11252.html","title":"MSSQL","keywords":"","body":"MSSQL 与其他编程语言一样，Transact-SQL语言也有自己的数据类型。数据类型在定义数据对象（如列、变量和参数等）时是必须的。自SQL Server 2008版本开始就新增了XML数据类型，以用于保存XML数据。Transact-SQL语言的其他数据类型与SQL的相同。 1．系统数据类型 系统数据类型又称为基本数据类型。 2．用户自定义数据类型 用户自定义数据类型可看做系统数据类型的别名。 在讨论数据类型时，使用了精度、小数位数和长度3个概念，前两个概念是针对数值型数据的，它们的含义如下。 精度：指数值数据中所存储的十进制数据的总位数。 小数位数：指数值数据中小数点右边可以有的数字位数的最大值。例如，数值数据3890.587的精度是7，小数位数是3。 长度：指存储数据所使用的字节数。 "},"page/11207.html":{"url":"page/11207.html","title":"分类","keywords":"","body":"分类 "},"page/11208.html":{"url":"page/11208.html","title":"数值型","keywords":"","body":"数值型 "},"page/11238.html":{"url":"page/11238.html","title":"MSSQL","keywords":"","body":"SQL Server 数值型 按照不同的精确程度，将数值型数据类型分为两种，一种是精确型，另一种是近似型。 精确型数据是指在计算机中可以精确存储的数据。这种数据类型包括各种整型数据类型、定点型数据类型等， 近似型主要是指浮点型float和real。这种类型的数据在内存中不一定能够精确表示，可能会存在一些微小的误差。 Number 类型： 数据类型 描述 存储 tinyint 允许从 0 到 255 的所有数字。 1 字节 smallint 允许介于 -32,768 与 32,767 的所有数字。 2 字节 int 允许介于 -2,147,483,648 与 2,147,483,647 的所有数字。 4 字节 bigint 允许介于 -9,223,372,036,854,775,808 与 9,223,372,036,854,775,807 之间的所有数字。 8 字节 decimal(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 numeric(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 smallmoney 介于 -214,748.3648 与 214,748.3647 之间的货币数据。 4 字节 money 介于 -922,337,203,685,477.5808 与 922,337,203,685,477.5807 之间的货币数据。 8 字节 float(n) 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。n 参数指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 4 或 8 字节 real 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 4 字节 精确型数据类型 数据类型 说明 bit 表示位整型，占1个字节，存储0或1，也可以取值null tinyint 表示小整型，占1个字节，可存储0到255之间的整数 smallint 表示短整型，占2个字节，可存储从-215(-32,768)到215-1(32,767) 之间的整数 int（或integer） 整型数据类型，占4个字节，可存储从-231(-2,147,483,648)到231-1(2,147,483,647)之间的整数 bigint 表示大整型，占8个字节，可存储从-263(-9,223,372,036,854,775,808)到263-1(9,223,372,036,854,775,807)之间的整数 numeric(m,n) 定点型数据类型。可表示从-1038+1到1038-1之间的有固定精度和小数位的数值数据，其中m用于设定总的有效位数（小数点两边的十进制位数之和），n则用于设定小数点右边的十进制位数之和，即表示精确到第n位。n默认值为0，且0≤n≤m，最多占17字节。 decimal(m,n) decimal(m,n)的功能同numeric(m,n) 近似型主要是指浮点型float和real。这种类型的数据在内存中不一定能够精确表示，可能会存在一些微小的误差。 近似型数据类型（float和real） 数据类型 说明 real 占4个字节，可精确到小数点后7位数，可存储从-3.40E+38到3.40E+38的浮点精度数值 float 占8个字节，近似数值类型，可存储从-1.79E+308到1.79E+308的浮点精度数值 下面分别说明常用的系统数据类型。 1．整数型 整数型包括bigint、int、smallint和tinyint，从标识符的含义就可以看出，它们的表示数范围逐渐缩小。 bigint：大整数，数范围为263～2631，其精度为19，小数位数为0，长度为8字节。 int：整数，数范围为231～2311，其精度为10，小数位数为0，长度为4字节。 smallint：短整数，数范围为215～2151，其精度为5，小数位数为0，长度为2字节。 tinyint：微短整数，数范围为0～255，长度为1字节，其精度为3，小数位数为0，长度为1字节。 2．精确数值型 精确数值型数据由整数部分和小数部分构成，其所有的数字都是有效位，能够以完整的精度存储十进制数。精确数值型包括decimal 和 numeric两类。在SQL Server 2008中，这两种数据类型在功能上完全等价。 声明精确数值型数据的格式是numeric | decimal(p[,s])，其中，p为精度，s为小数位数，s的默认值为0。例如，指定某列为精确数值型，精度为6，小数位数为3，即decimal(6,3)，那么当向某记录的该列赋值56.342 689时，该列实际存储的是56.3427。 decimal和numeric可存储–10^38 +1～10^38 –1 的固定精度和小数位的数字数据，它们的存储长度随精度变化而变化，最少为5字节，最多为17字节。 例如，若有声明numeric(8,3)，则存储该类型数据需5字节；而若有声明numeric(22,5)，则存储该类型数据需13字节。 3．浮点型 浮点型也称近似数值型。顾名思义，这种类型不能提供精确表示数据的精度，使用这种类型来存储某些数值时，可能会损失一些精度，所以它可用于处理取值范围非常大且对精确度要求不太高的数值量，如一些统计量。 有两种近似数值数据类型：float[(n)]和real，两者通常都使用科学计数法表示数据，即形为尾数E阶数，如5.6432E20，–2.98E10，1.287659E-9等。 real：使用4字节存储数据，表数范围为–3.40E + 38～3.40E + 38，数据精度为7位有效数字。 float：float型数据的数范围为–1.79E+308～1.79E+308。定义中的n取值范围是1～53，用于指示其精度和存储大小。当n在1～24之间时，实际上将定义一个real型数据，存储长度为4字节，精度为7位有效数字。当n在25～53之间时，存储长度为8字节，精度为15位有效数字。当省略n时，代表n在25～53之间。 "},"page/11239.html":{"url":"page/11239.html","title":"MySQL","keywords":"","body":"MySQL 数值类型 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 数据类型 描述 TINYINT(size) 带符号-128到127 ，无符号0到255。 SMALLINT(size) 带符号范围-32768到32767，无符号0到65535, size 默认为 6。 MEDIUMINT(size) 带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9 INT(size) 带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11 BIGINT(size) 带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20 FLOAT(size,d) 带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如 int(4) 并不是只能存储4个长度的数字。 实际上int(size)所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。就是在显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。 例如： int的值为10 （指定zerofill） int（9）显示结果为000000010 int（3）显示结果为010 就是显示的长度不一样而已 都是占用四个字节的空间 "},"page/11209.html":{"url":"page/11209.html","title":"字符串型","keywords":"","body":"字符串型 "},"page/11240.html":{"url":"page/11240.html","title":"MSSQL","keywords":"","body":"SQL Server 字符串型 　　SQL Server 2014中，字符串型数据可以由汉字、英文字母、数字等符号组成。根据编码方式的不同，字符串型又分为Unicode字符串型和非Unicode字符串型。 　　Unicode字符串型数据是指对所有字符均采用双字（16bit）节统一编码的一类数据； 　　非Unicode字符串型数据则是指对不同国家或地区采用不同编码长度的一类数据，例如英文字母使用一个字节（8bit）进行编码，汉字则使用两个字节（16bit）进行编码。 　　SQL Server 2014主要支持的字符串型数据类型如表5.2所示。 String 类型： 数据类型 描述 存储 char(n) 固定长度的字符串。最多 8,000 个字符。 Defined width varchar(n) 可变长度的字符串。最多 8,000 个字符。 2 bytes + number of chars varchar(max) 可变长度的字符串。最多 1,073,741,824 个字符。 2 bytes + number of chars text 可变长度的字符串。最多 2GB 文本数据。 4 bytes + number of chars nchar 固定长度的 Unicode 字符串。最多 4,000 个字符。 Defined width x 2 nvarchar 可变长度的 Unicode 字符串。最多 4,000 个字符。 nvarchar(max) 可变长度的 Unicode 字符串。最多 536,870,912 个字符。 ntext 可变长度的 Unicode 字符串。最多 2GB 文本数据。 bit 允许 0、1 或 NULL binary(n) 固定长度的二进制字符串。最多 8,000 字节。 varbinary 可变长度的二进制字符串。最多 8,000 字节。 varbinary(max) 可变长度的二进制字符串。最多 2GB。 image 可变长度的二进制字符串。最多 2GB。 char varchar nvarchar char的长度是不可变的 varchar的长度是可变的 char[10] 如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格, char类型的要用trim()去掉多余的空格，而varchar是不需要的 varchar[10]varchar就立马把长度变为4了,10是最大长度， 目前VARCHAR是VARCHAR2的同义词。工业标准的VARCHAR类型可以存储空字符串，但是oracle不这样做，尽管它保留以后这样做的权利。Oracle自己开发了一个数据类型VARCHAR2，这个类型不是一个标准的VARCHAR，它将在数据库中varchar列可以存储空字符串的特性改为存储NULL值。如果你想有向后兼容的能力，Oracle建议使用VARCHAR2而不是VARCHAR。 char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率， 而varchar是以空间效率为首位的 char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节； 而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。 VARCHAR2比CHAR节省空间，在效率上比CHAR会稍微差一些，即要想获得效率，就必须牺牲一定的空间，这也就是我们在数据库设计上常说的‘以空间换效率’ VARCHAR2虽然比CHAR节省空间，但是如果一个VARCHAR2列经常被修改，而且每次被修改的数据的长度不同，这会引起‘行迁移’(Row Migration)现象，而这造成多余的I/O，是数据库设计和调整中要尽力避免的，在这种情况下用CHAR代替VARCHAR2会更好一些。 固定长度，实际占用空间为建表时分配的字节大小。一个汉字占用两个字节，一个英文字母占据一个字节。比如char（10），最多存储5个汉字，10个字母。 可变长度，实际占用的空间与输入的字符长度有关，一个汉字占据两个字节，英文字母占据一个字节。比如varchar（10），最多存储5个汉字，10个字母 可变长度，实际占用空间与输入的字符长度有关，一个汉字占据一个字节，英文字母占据一个字节。比如nvarchar（10），最多存储10个汉字，10个字母。 参考1 参考2 字符型 字符型数据用于存储字符串，字符串中可包括字母、数字和其他特殊符号（如#、@、&等）。在输入字符串时，需将串中的符号用单引号或双引号括起来，如'abc'、\"Abc"},"page/11241.html":{"url":"page/11241.html","title":"MySQL","keywords":"","body":"MySQL 字符串类型 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM('X','Y','Z') SET 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 "},"page/11210.html":{"url":"page/11210.html","title":"日期时间型","keywords":"","body":"日期时间型 "},"page/11242.html":{"url":"page/11242.html","title":"MSSQL","keywords":"","body":"SQL Server 4.3.3 日期时间型 　　日期时间型，包括两种：datetime和smalldatetiime。日期时间型既可以用于存储时间型数据，也可以用于存储日期型数据。 　　自从SQL Server 2012开始，新增了4种与日期时间相关的新数据类型：datetime2、dateoffset、date和time。 日期时间型数据类型（float和real） 数据类型 说明 date 占3字节，只存储日期（无时间部分），可存储从1年1月1日到9999年12月31日的日期数据 time(n) 占3至5字节，只存储时间，n取值在0~7之间，存储格式为“HH:MM:SS[.NNNNNNN]”，其中HH,MM,SS分别表示小时、分和秒，N表示秒的小数位，取值范围从00:00:00.0000000到23:59:59.9999999，精确到100纳秒 smalldatetime 占4个字节，可存储从1900年1月1日到2079年6月6日的日期和时间数据，精确到分钟 datetime 占8个字节，可存储从1753年1月1日到9999年12月31日的日期和时间数据，精确到千分之三秒（即3.33毫秒） datetime2(n) 占6至8字节，可存储从1年01月01日00时00分00.0000000秒到9999年12月31日23时59分59.9999999秒的日期和时间数据，n取值在0~7之间的数，指定秒的小数位，精确到100钠秒 datetimeoffset(n) 占8至10字节，可存储从1年01月01日00时00分00.0000000秒到9999年12月31日23时59分59.9999999秒的日期和时间数据，n取值在0~7之间的数，指定秒的小数位，精确到100钠秒。该类型带有时区偏移量，时区偏移量最大为+/-14小时，包含了UTC偏移量，因此可以合理化不同时区捕捉的时间 Date 类型： 数据类型 描述 存储 datetime 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 8 字节 datetime2 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 6-8 字节 smalldatetime 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 4 字节 date 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 3 bytes time 仅存储时间。精度为 100 纳秒。 3-5 字节 datetimeoffset 与 datetime2 相同，外加时区偏移。 8-10 字节 timestamp 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 值基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 日期时间类型 日期时间类型数据用于存储日期和时间信息，在SQL Server 2008以前的版本中，日期时间数据类型只有datetime和smalldatetime两种。而在SQL Server 2008中新增了4种新的日期时间数据类型，分别为date、time、datetime2和datetimeoffset。 （1）datetime：datetime类型可表示的日期范围为从1753年1月1日到9999年12月31日，精确度为0.03 s（3.33 ms或0.003 33 s），例如，1～3 ms的值都表示为0 ms，4～6 ms的值都表示为4 ms。 datetime类型数据长度为8字节，日期和时间分别使用4字节存储。前4字节用于存储datetime类型数据中距1900年1月1日的天数。为正数表示日期在1900年1月1日之后，为负数则表示日期在1900年1月1日之前。后4字节用于存储datetime类型数据中距12:00（24小时制）的毫秒数。 （2）smalldatetime：smalldatetime类型数据可表示从1900年1月1日到2079年6月6日的日期和时间，数据精确到分钟。即29.998 s或更低的值向下舍入为最接近的分钟，29.999 s或更高的值向上舍入为最接近的分钟。 smalldatetime类型数据的存储长度为4字节，前2字节用来存储smalldatetime类型数据中日期部分距1900年1月1日之后的天数。后2字节用来存储smalldatetime类型数据中时间部分距中午12点的分钟数。 用户输入smalldatetime类型数据的格式与datetime类型数据完全相同，只是它们的内部存储可能不相同。 （3）date：date类型数据可以表示从公元元年1月1日到9999年12月31日的日期，date类型只存储日期数据，不存储时间数据，存储长度为3字节，表示形式与datetime数据类型的日期部分相同。 （4）time：time数据类型只存储时间数据，表示格式为“hh:mm:ss[.nnnnnnn]”。hh表示小时，范围为0～23。mm表示分钟，范围为0～59。ss表示秒数，范围为0～59。n是0～7位数字，范围为0～999 9999，表示秒的小数部分，即微秒数。所以time数据类型的取值范围为00:00:00.000 000 0～23:59:59.999 999 9。time类型的存储大小为5字节。另外还可以自定义time类型微秒数的位数，例如，time(1)表示小数位数为1，默认为7。 （5）datetime2：新的datetime2数据类型和datetime类型一样，也用于存储日期和时间信息。但是datetime2类型取值范围更广，日期部分取值范围从公元元年1月1日到9999年12月31日，时间部分的取值范围为00:00:00.0000000～23:59:59.999999。另外，用户还可以自定义datetime2数据类型中微秒数的位数，例如，datetime(2)表示小数位数为2。datetime2类型的存储大小随着微秒数的位数（精度）而改变，精度小于3时为6字节，精度为4和5时为7字节，所有其他精度则需要8字节。 （6）datetimeoffset：datetimeoffset数据类型也用于存储日期和时间信息，取值范围与datetime2类型相同。但datetimeoffset类型具有时区偏移量，此偏移量指定时间相对于协调世界时（UTC）偏移的小时和分钟数。datetimeoffset的格式为“YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+|}hh:mm]”，其中，hh为时区偏移量中的小时数，范围为00～14，mm为时区偏移量中的额外分钟数，范围为00～59。时区偏移量中必须包含“+”（加）或“–”（减）号。这两个符号表示是在UTC时间的基础上加上还是从中减去时区偏移量以得出本地时间。时区偏移量的有效范围为14:00～+14:00。 时间戳型 标识符是timestamp。若创建表时定义一个列的数据类型为时间戳类型，那么每当对该表加入新行或修改已有行时，都由系统自动将一个计数器值加到该列，即将原来的时间戳值加上一个增量。 记录timestamp列的值实际上反映了系统对该记录修改的相对（相对于其他记录）顺序。一个表只能有一个timestamp 列。timestamp类型数据的值实际上是二进制格式数据，其长度为8字节。 用户给出datetime类型数据值时，日期部分和时间部分分别给出。 日期部分的表示形式常用的格式如下： 年 月 日 2001 Jan 20、2001 Janary 20 年 日 月 2001 20 Jan 月 日[,]年 Jan 20 2001、Jan 20,2001、Jan 20,01 月 年 日 Jan 2001 20 日 月[,]年 20 Jan 2001、20 Jan,2001 日 年 月 20 2001 Jan 年（4位数） 2001表示2001年1月1日 年月日 20010120、010120 月/日/年 01/20/01、1/20/01、01/20/2001、1/20/2001 月-日-年 01-20-01、1-20-01、01-20-2001、1-20-2001 月.日.年 01.20.01、1.20.01、01.20.2001、1.20.2001 时间部分常用的表示格式如下： 时:分 10:20、08:05 时:分:秒 20:15:18、20:15:18.2 时:分:秒:毫秒 20:15:18:200 时:分AM\\ PM 10:10AM、10: "},"page/11243.html":{"url":"page/11243.html","title":"MySQL","keywords":"","body":"MySQL 日期和时间类型 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 '1000-01-01' 到 '9999-12-31' DATETIME() 日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS*注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59' TIMESTAMP() 时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS*注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC TIME() 时间。格式：HH:MM:SS注释：支持的范围是从 '-838:59:59' 到 '838:59:59' YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 *即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 '-838:59:59'/'838:59:59' HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 "},"page/11254.html":{"url":"page/11254.html","title":"货币型","keywords":"","body":"货币型 "},"page/11211.html":{"url":"page/11211.html","title":"MSSQL","keywords":"","body":"货币型 4.3.4 货币型 货币型是用来存储货币值数据，它固定精确到小数点后四位，相当于numeric(m,n)类型的特例（n=4）。SQL Server支持两种货币型。 货币型数据类型 数据类型 说明 smallmoney 占4个字节，可存储从-214,748.3648到+214,748.3647之间的货币数据值，精确到货币单位的千分之十 money 占8个字节，可存储从-2^63^(-922,337,203,685,477.5808)到2^63^- 1 (+922,337,203,685,477.5807)之间的货币数据值，精确到货币单位的千分之十 货币型 SQL Server 2008提供了两个专门用于处理货币的数据类型：money和smallmoney，它们用十进制数表示货币值。 money：数据的数范围为-2^63～2^63-1，其精度为19，小数位数为4，长度为8字节。money的数范围与bigint相同，不同的只是money型有4位小数，实际上，money就是按照整数进行运算的，只是将小数点固定在末4位。 smallmoney：数范围为–2^31～2^31-1，其精度为10，小数位数为4，长度为4字节。可见smallmoney与int的关系就如同money与bigint的关系一样。 当向表中插入money或smallmoney类型的值时，必须在数据前面加上货币表示符号（$），并且数据中间不能有逗号（,）；若货币值为负数，则需要在符号$的后面加上负号（-）。例如，$15 000.32，$680，$-20 000.9088都是正确的货币数据表示形式。 "},"page/11259.html":{"url":"page/11259.html","title":"文本型","keywords":"","body":"文本型 "},"page/11260.html":{"url":"page/11260.html","title":"MSSQL","keywords":"","body":"MSSQL 文本型 当需要存储大量的字符数据，如较长的备注、日志信息等时，字符型数据最长8000个字符的限制可能使它们不能满足这种应用需求，此时可使用文本型数据。 文本型包括text和ntext两类，分别对应ASCII字符和Unicode字符。 text类型可以表示最大长度为2^31-1(2G)个字符，其数据的存储长度为实际字符数字节。 ntext类型可表示最大长度为2^30-1个Unicode字符，其数据的存储长度是实际字符个数的两倍（以字节为单位）。 "},"page/11255.html":{"url":"page/11255.html","title":"二进制型","keywords":"","body":"二进制型 "},"page/11212.html":{"url":"page/11212.html","title":"MSSQL","keywords":"","body":"二进制型 4.3.5 二进制型 二进制型数据类型包括三种：binary(n)、varbinary(n)和image。其作用和含义说明如表5.7所示。 二进制型数据类型 数据类型 说明 binary(n) 表示固定长度的二进制数据类型，其中n用于设置最大长度，取值范围为1~8000字节 varbinary(n) 表示可变长度的二进制数据类型，其中n用于设置最大长度，取值范围为1~8000字节 image 表示更大容量、可变长度的二进制数据类型，最多可以存储231-1（2,147,483,647）字节，约为2GB。它既可存储文本格式，也可以存储GIF格式等多种格式类型的文件。 位型 SQL Server 2008中的位（bit）型数据相当于其他语言中的逻辑型数据，它只存储0和1，长度为1字节。但要注意，SQL Server对表中bit类型列的存储进行了优化：如果一个表中有不多于8个的bit列，则这些列将作为1字节存储；如果表中有9～16个bit列，则这些列将作为2字节存储，更多列的情况以此类推。 当为bit类型数据赋0时，其值为0，而赋非0（如100）时，其值为1。 字符串值TRUE和FALSE可以转换为以下bit 值：TRUE转换为1，FALSE转换为0。 二进制型 二进制数据类型表示的是位数据流，包括binary（固定长度）和varbinary（可变长度）两种。 binary [(n) ]：固定长度的n字节二进制数据。n的取值范围为1～8 000，默认为1。binary(n)数据的存储长度为 n+4 字节。若输入的数据长度小于n，则不足部分用0填充；若输入的数据长度大于n，则多余部分被截断。 varbinary [(n)]：n字节变长二进制数据。n取值范围为1～8 000，默认为1。varbinary(n)数据的存储长度为实际输入数据长度+4字节。 "},"page/11256.html":{"url":"page/11256.html","title":"其他数据类型","keywords":"","body":"其他数据类型 "},"page/11213.html":{"url":"page/11213.html","title":"MSSQL","keywords":"","body":"其他数据类型 SQL Server 2014还支持以下的数据类型： 　　sql_variant：一种通用数据类型，存储除了text、ntext、image、timestamp和它自身以外的其他类型的数据，其最大存储量为8000字节。 　　timestamp：时间戳类型，每次更新时会自动更新该类型的数据。作用跟邮局的邮戳类似，通常用于证明某一项活动（操作）是在某一时刻完成的。 　　uniqueidentitier：全局唯一标识符（GUID），其值可以从Newsequentialid()函数获得，这个函数返回的值对所有计算机来说是唯一的。 　　xml：作为一种存储格式，xml类型具有SQL Server中其他类型的所有功能，还可以添加子树、删除子树和更新标量值等，最多存储2GB数据。 　　table：表类型，用于返回表值函数的结果集，其大小取决于表中的列数和行数。 　　hierarchyid：层次类型，包含对层次结构中位置的引用，占用空间为1至892字节＋2字节的额外开销。 　　cursor：游标类型，包含对游标的引用，只能用作变量或存储过程参数，不能用于Create Table语句中。 SQL Server 2008提供了其他几种数据类型：image、cursor、sql_variant、table、uniqueidentifier、xml和hierarchyid。 图像数据类型 标识符是image，它用于存储图片、照片等。实际存储的是可变长度二进制数据，介于 0与2^31-1 (2 147 483 647) 字节之间。在SQL Server 2008中该类型是为了向下兼容而保留的数据类型。微软推荐用户使用varbinary(MAX)数据类型来替代image类型。 cursor：是游标数据类型，用于创建游标变量或定义存储过程的输出参数。 sql_variant：是一种存储SQL Server支持的各种数据类型（除text、ntext、image、timestamp 和 sql_variant 外）值的数据类型。sql_variant的最大长度可达8016字节。 table：是用于存储结果集的数据类型，结果集可以供后续处理。 uniqueidentifier：是唯一标识符类型。系统将为这种类型的数据产生唯一标识值，它是一个16字节长的二进制数据。 xml：是用来在数据库中保存xml文档和片段的一种类型，但是此种类型的文件大小不能超过2 GB。 hierarchyid：hierarchyid数据类型是SQL Server 2008新增加的一种长度可变的系统数据类型。可使用 hierarchyid表示层次结构中的位置。 varchar、nvarchar、varbinary这三种数据类型可以使用MAX关键字，如varchar(MAX)、nvarchar(MAX)、varbinary(MAX)，加了MAX关键字的这几种数据类型最多可存放231-1字节的数据，分别用来替换text、ntext和image数据类型。 "},"page/11257.html":{"url":"page/11257.html","title":"自定义数据类型","keywords":"","body":"自定义数据类型 "},"page/11214.html":{"url":"page/11214.html","title":"MSSQL","keywords":"","body":"自定义数据类型 概念 根据实际需要，用户可利用已有的标准数据类型来定义自己的数据类型，这种类型称为自定义数据类型。自定义数据类型可由CREATE TYPE语句来定义。 用户自定义数据类型可看做系统数据类型的别名。 在多表操作的情况下，当多个表中的列要存储相同类型的数据时，往往要确保这些列具有完全相同的数据类型、长度和为空性（数据类型是否允许空值）。用户自定义数据类型并不是真正的数据类型，它只是提供了一种提高数据库内部元素和基本数据类型之间一致性的机制。 类似于#define，方便管理，改一处，都改 【例子】 用户可以用下列语句创建表示地址的数据类型——address： CREATE TYPE address FROM varchar(350) NOT NULL; 执行上述语句后，就生成了名为address的数据类型，同时增加了约束条件——NOT NULL。就可以用address去定义字段和变量。该数据类型就是与varchar(350)同等，只不过它增加了一个非空约束条件。 不再需要数据类型address，可以用下列语句将之删除： DROP TYPE address; 但在删除之前，先删除所有引用该数据类型的数据库对象。 定义类型 要使用用户自定义类型，首先应定义该类型，然后用这种类型来定义字段或变量。在创建用户自定义数据类型时首先应考虑如下三个属性： 数据类型名称； 新数据类型所依据的系统数据类型（又称为基类型）； 为空性。如果为空性未明确定义，系统将依据数据库或连接的ANSI Null 默认设置进行指派。 使用命令定义。在SQL Server 2008中，使用CREATE TYPE语句来实现用户数据类型的定义。语法格式： CREATE TYPE [ schema_name. ] type_name FROM base_type [ ( precision [ , scale ] ) ] [ NULL | NOT NULL ] [ ; ] 例子：用户自定义数据类型student_num后，可以重新设计学生成绩管理数据库表XSB、CJB结构中的学号字段，如表5.4、表5.5和表5.6所示。 表5.4 自定义类型student_num 依赖的系统类型 值允许的长度 为 空 性 char 6 NOT NULL 表5.5 表XSB中学号字段的重新设计 字 段 名 类 型 字 段 名 类 型 学号 student_num 学号 student_num 表5.6 表CJB中学号字段的重新设计 字 段 名 类 型 字 段 名 类 型 学号 student_num 学号 student_num //根据上述语法，定义描述学号字段的数据类型的语句如下： CREATE TYPE student_num FROM char(6) NOT NULL 使用命令删除用户自定义数据类型 使用命令方式删除自定义数据类型可以使用DROP TYPE语句。语法格式： DROP TYPE [ schema_name. ] type_name [ ; ] 例如，删除前面定义的student_num类型的语句为 DROP TYPE student_num 以上语句实际不做操作。 利用用户自定义数据类型定义字段 在定义类型后，接着应考虑定义这种类型的字段，同样可以利用对象资源管理器和T-SQL命令两种方式实现。可以参照基本数据类型进行定义，不同点只是数据类型为用户自定义类型，而不是系统类型。 利用命令方式定义XSB表结构： CREATE TABLE XSB ( 学号 student_num NOT NULL PRIMARY KEY, /*将学号定义为student_num类型*/ 姓名 char(8) NOT NULL, 性别 bit NULL DEFAULT 1, 出生时间 datetime NULL, 专业 char(12) NULL, 总学分 int NULL, 备注 varchar(500) NULL ) 界面 创建用户自定义数据类型的方法如下 使用对象资源管理器定义。步骤如下 第1步：启动“SQL Server Management Studio”，在“对象资源管理器”中展开“数据库→PXSCJ→可编程性”，右击“类型”，选择“新建”选项，再选择“新建用户定义数据类型”，弹出“新建用户定义数据类型”窗口。 第2步：在“名称”文本框中输入自定义的数据类型名称，如student_num。在“数据类型”下拉框中选择自定义数据类型所基于的系统数据类型，如char。在“长度”栏中填写要定义的数据类型的长度，如6。其他选项使用默认值，如图5.1所示，单击“确定”按钮即可完成创建。 图5.1 “新建用户定义数据类型属性”窗口 （3）删除用户自定义数据类型。在SSMS中删除用户自定义数据类型的主要步骤如下： 在对象资源管理器中展开数据库“PXSCJ→可编程性→类型”，在“用户定义数据类型”中选择类型“dbo.student_num”，右击鼠标，在弹出的快捷菜单中选择“删除”菜单项，打开“删除对象”窗口后单击“确定”按钮即可（实际不做操作）。 删除用户自定义数据类型。 在SSMS中删除用户自定义数据类型的主要步骤如下： 在对象资源管理器中展开数据库“PXSCJ→可编程性→类型”，在“用户定义数据类型”中选择类型“dbo.student_num”，右击鼠标，在弹出的快捷菜单中选择“删除”菜单项，打开“删除对象”窗口后单击“确定”按钮即可（实际不做操作）。 利用用户自定义数据类型定义字段 例如，在对象资源管理器中对于XSB表学号字段的定义如图5.2所示。 图5.2 使用用户自定义数据类型定义XSB表 用户自定义表数据类型 SQL Server 2008还提供了一种新的用户自定义数据类型，称为用户自定义表数据类型（User-defined Table Types）。这种数据类型也由用户自行定义，可以作为参数提供给语句、存储过程或者函数。创建自定义表数据类型也使用CREATE TYPE语句，语法格式如下： CREATE TYPE [ schema_name. ] type_name AS TABLE ( [ ] [ ,...n ] ) [ ; ] 【例5.1】 创建用户自定义表数据类型，包含CJB表中的所有列。 CREATE TYPE CJB_tabletype AS TABLE ( 学号 char(6) NOT NULL, 课程号 char(3) NOT NULL, 成绩 int NOT NULL, PRIMARY KEY(学号, 课程号) //表级约束，当多个字段时用表级约束 ) "},"page/11215.html":{"url":"page/11215.html","title":"常变","keywords":"","body":"常变 "},"page/11216.html":{"url":"page/11216.html","title":"变量","keywords":"","body":"变量 4.1 变量的定义和使用Transact-SQL 1. 全局变量 　　在SQL Server中，全局变量是以@@开头，后跟相应的字符串，如@@VERSION等。如果想查看全局变量的值，可用SELECT语句或print语句来完成。 　　查看全局变量的值@@VERSION的值，相应的print语句如下： print @@VERSION; 　　该语句执行后在笔者机器上输出如下结果： Microsoft SQL Server 2014 - 12.0.4100.1 (X64) Apr 20 2015 17:29:27 Copyright (c) Microsoft Corporation Standard Edition (64-bit) on Windows NT 6.1 (Build 7601: Service Pack 1) 2. 局部变量 （1）定义局部变量 　　局部变量是由用户定义的，语法如下： DECLARE @variable1 data_type[,variable2 data_type, …] ​ @variable1, @variable2,…为局部变量名，它们必须以单字符“@”开头；data_type为数据类型，它是可以是系统数据类型，也可以是用户定义的数据类型，具体选择什么样的类型要根据实际需要而定。有关数据类型的说明见第4章的相关内容。 【例6.1】定义一个用于存储姓名的局部变量。 DECLARE @name_str varchar(8); 【例6.2】同时定义三个分别用于存储学号、出生日期和平均成绩的局部变量。 DECLARE @no_str varchar(8), @birthday_str smalldatetime, @avgrade_num numeric(3,1); （2）使用SET对局部变量赋初值 　　在定义局部变量以后，变量自动被赋以空值（NULL）。如果需要对已经定义的局部变量赋一个初值，可用SET语句来实现，其语法如下： SET @variable = value; @variable为局部变量名，value为新赋的值。 【例6.3】对上例定义的三个变量@no_str、@birthday_str和@avgrade_num分别赋初值'20170112'、'2000-2-5'和89.8。 ​ 这个赋值操作可以下三个SET语句来完成： SET @no_str='20170112'; SET @birthday_str='2000-2-5'; SET @avgrade_num = 89.8; 注意，不能同时对多个变量进行赋值，这与同时对多个变量进行定义的情况不同 【例子】下列的SET语句是错误的： SET @no_str='20170112', @birthday_str='2000-2-5', @avgrade_num = 89.8; -- 错误 （3）使用SELECT对局部变量赋初值 　　SELECT是查询语句，利用该语句可以将查询的结果赋给相应的局部变量。如果查询返回的结果包含多个值，则将最后一个值赋给局部变量。 ​ 使用SELECT对局部变量赋初值的语法格式如下： SELECT @variable1= value1[, @variable2= value2, …] FROM table_name [WHERE …] 【例6.4】 查询表student，将姓名为“刘洋”的学生的学号、出生日期和平均成绩分别赋给局部变量@no_str、@birthday_str和@avgrade_num。 ​ 该赋值操作用SELECT语句来实现则非常方便，其代码如下： SELECT @no_str = s_no, @birthday_str = s_birthday, @avgrade_num = s_avgrade FROM student WHERE s_name = '刘洋'; 【例6.5】先定义局部变量@s_no和@s_avgrade，然后对其赋值，最后利用这两个变量修改数据表student的相关信息。 USE MyDatabase GO -- 定义局部变量 DECLARE @s_no varchar(8), @s_avgrade numeric(3,1); -- 对局部变量赋值 SET @s_no='20170208'; SET @s_avgrade = 95.0; -- 使用局部变量 Update student SET s_avgrade = @s_avgrade WHERE s_no = @s_no; "},"page/11217.html":{"url":"page/11217.html","title":"常量","keywords":"","body":"常量 "},"page/11286.html":{"url":"page/11286.html","title":"MSSQL","keywords":"","body":"Transact-SQL常量 根据常量值的不同类型，常量分为字符串常量、整型常量、实型常量、日期时间常量、货币常量、唯一标识常量。各类常量举例说明如下。 1．字符串常量 字符串常量分为ASCII字符串常量和Unicode字符串常量。 （1）ASCII字符串常量。 ASCII字符串常量是用单引号括起来，由ASCII字符构成的符号串。 　　字符串常量是由两个单引号来定义的，是包含在两个单引号内的字符序列。 　　这些字符包括字母数字字符（a-z、A-Z 和0-9）以及特殊字符，如感叹号(!)、at 符(@) 和数字号(#)等。 　　默认情况下，SQL Server 2014为字符串常量分配当前数据库的默认排序规则，但也可以用COLLATE 子句为其指定排序规则。 　　如果字符串中包含一个嵌入的单引号，则需要在该单引号前再加上一个单引号，表示转义，这样才能定义包含单引号的字符串。 ASCII字符串常量举例如下： '中国人民共和国' 'China' 'How do you!' 'O''Bbaar' /*意思是 O'Bbaar */ /*如果单引号中的字符串包含引号，可以使用两个单引号来表示嵌入的单引号。*/ ​ 有许多程序员习惯用双引号来定义字符串常量。但在默认情况下，SQL Server不允许使用这样的定义方式。 ​ 如果将QUOTED_IDENTIFIER 选项设置为OFF，则SQL Server同时支持运用双引号和单引号来定义字符串。 ​ 设置QUOTED_IDENTIFIER的方法用下列语句： SET QUOTED_IDENTIFIER OFF; 在执行该语句后，QUOTED_IDENTIFIER 被设置为OFF。这时除了单引号以外，还可以用双引号来定义字符串。 　　注意，当用双引号定义字符串时，如果该字符串中包含单引号，则不能在单引号前再加上另一个单引号，否则将得到另外的一种字符串。 【例子】 'AbC''Dd!'定义的是字符串“AbC'Dd!”，而\"AbC''Dd!\"定义则是字符串“AbC''Dd!”。 SQL Server将空字符串解释为单个空格。 　　如果不需要用双引号来定义字符串，则只要将QUOTED_IDENTIFIER恢复为默认值ON即可。需要执行下列语句： SET QUOTED_IDENTIFIER ON; （2）Unicode 字符串常量。 Unicode 字符串常量与ASCII字符串常量相似，但它前面有一个N标识符（N代表 SQL-92标准中的国际语言National Language），N前缀必须为大写字母。 Unicode字符串常量举例如下： N'China ' N'How do you!' Unicode 数据中的每个字符用两个字节存储，而每个ASCII字符用一个字节存储。 'China'是普通的字符串常量，而 N'China'则是Unicode字符串常量。 2．整型常量 按照不同表示方式，整型常量又分为二进制整型常量、十六进制整型常量和十进制整型常量。 十六进制整型常量的表示：前辍 0x 后跟十六进制数字串。 十六进制常量举例： 0xEBF 0x69048AEFDD010E 0x /*空十六进制常量*/ 二进制整型常量（位常量）的表示：即数字 0 或1，并且不使用引号。如果使用一个大于 1 的数字，它将被转换为1。 DECLARE @b bit SET @b = 0; 十进制整型常量即不带小数点的十进制数，例如， 1894 2 +145345234 -2147483648 3．实型常量（数值型常量） 　　数值型常量包括三种类型：decimal型常量、float型常量和real型常量。 实型常量有定点表示和浮点表示两种方式，举例如下。 定点表示： 1894.1204 2.0 +145345234.2234 -2147483648.10 【例子】下面是decimal型常量的例子： 3.14159 -1.　 decimal型常量是包含小数点的数字字符串，但这些字符串不需单引号括起来（定点表示）。 浮点表示：　 101.5E5 0.5E-2 +123E-3 -12E5 　　float型常量和real型常量都是使用科学记数法来表示（浮点表示）。 【例子】 101.5E5 -0.5E-2 4．日期时间常量 日期时间常量：用单引号将表示日期时间的字符串括起来构成。SQL Server可以识别如下格式的日期和时间。 字母日期格式，如'April 20, 2000'； 数字日期格式，如'4/15/1998'，'1998-04-15'； 未分隔的字符串格式，如'20001207'； 以下是时间常量的例子： '14:30:24' '04:24:PM' 以下是日期时间常量的例子： 'April 20, 2000 14:30:24' 　　日期时间常量通常是用字符串常量来表示， 　　但前提是字符串常量能够隐式转换为日期时间型数据， 　　　　其格式为“yyyy-mm-dd hh:mm:ss.nnn”或“yyyy/mm/dd hh:mm:ss.nnn”， 　　　　其中yyyy表示年份，第一个mm表示月份，dd表示月份中的日期， 　　　　hh表示小时，第二个mm表示分钟，ss表示秒，nnn表示毫秒。 　　　　如果“yyyy-mm-dd”缺省，则日期部分默认为1900年01月01日； 　　　　如果“hh:mm:ss.nnn”缺省，则时间部分默认为00时00分00.000秒。 【例子】下面是一些将日期时间型常量赋给日期时间型变量的例子： DECLARE @dt datetime SET @dt = '2017-01-03 21:55:56.890' --2017年01月03日21时55分56.890秒 SET @dt = '2017/12/03' --2017年01月03日0时0分0秒 SET @dt = '2017-01-03' --2017年01月03日0时0分0秒 SET @dt = '21:55:56.890' --1900年01月01日21时55分56.890秒 5. 货币常量 money常量是以“$”作为前缀的一个整型或实型常量数据。　 货币常量是前缀为可选的小数点和可选的货币符号的数字字符串，且不用单引号括起来。SQL Server 2008不强制采用任何种类的分组规则，例如在代表货币的字符串中不允许每隔三个数字用一个逗号隔开。 下面是money常量的例子： $12 $542023 -$45.56 +$423456.99 $20000.2 -- 而$20,000.2是错误的货币常量 6. 唯一标识常量 uniqueidentifier 常量是用于表示全局唯一标识符（GUID）值的字符串。可以使用字符串或十六进制字符串格式指定。例如， '6F9619FF-8A86-D011-B42D-00004FC964FF' 0xff19966f868b11d0b42d00c04fc964ff ​ 以上介绍的几种类型的常量主要运用于对变量和字段赋值、构造表达式、构造子句等。在今后的介绍中将进一步领会到它的使用方法。 "},"page/11190.html":{"url":"page/11190.html","title":"运算符","keywords":"","body":"运算符 "},"page/11189.html":{"url":"page/11189.html","title":"MSSQL运算符","keywords":"","body":"运算符与表达式 Transact-SQL运算符 　　表达式是由表示常量、变量、函数等的标识符通过运算符连接而成的、具有实际计算意义的合法字符串。有的表达式不一定含有运算符，实际上单个的常量、变量等都可以视为一个表达式，它们往往不含有运算符。 　　运算符是用来指定要在一个或多个表达式中执行操作的一种符号。在SQL Server 2014中，使用的运算符包括算术运算符、逻辑运算符、赋值运算符、字符串串联运算符、按位运算符、一元运算符和比较运算符等。 "},"page/11288.html":{"url":"page/11288.html","title":"计算","keywords":"","body":"计算 "},"page/11289.html":{"url":"page/11289.html","title":"算术","keywords":"","body":"算术 "},"page/11192.html":{"url":"page/11192.html","title":"MSSQL算术","keywords":"","body":"算术 算术运算符 　　算术运算符加（+）、减（-）、乘（*）、除（/）和取模（%）等五种运算符。它们用于执行对两个表达式的运算，这两个表达式的返回值必须是数值数据类型，包括货币型。 　　加(+) 和减(-) 运算符还可以用于对日期时间类型值的算术运算。 "},"page/11290.html":{"url":"page/11290.html","title":"位操作","keywords":"","body":"位操作 "},"page/11193.html":{"url":"page/11193.html","title":"MSSQL位操作","keywords":"","body":"位操作 位运算符 　　位运算符是表示在两个操作数之间执行按位进行运算的符号，操作数必须为整型数据类型之一，如bit、tinyint、smallint、int、bigint等，还可以是二进制数据类型（image 数据类型除外）。下表列出了位运算符及其含义。 位运算符及其含义 位运算符 含义 & 对两个操作数按位逻辑与 \\ 对两个操作数按逻辑位或 ^ 对两个操作数按位逻辑异或 ~ 对一个操作数按位逻辑取非 "},"page/11291.html":{"url":"page/11291.html","title":"判断","keywords":"","body":"判断 "},"page/11292.html":{"url":"page/11292.html","title":"关系","keywords":"","body":"关系 "},"page/11195.html":{"url":"page/11195.html","title":"MSSQL关系","keywords":"","body":"关系比较运算符 　　比较运算符用于测试两个表达式的值之间的关系，这种关系是指等于、大于、小于、大于等于、小于等于、不等于、不小于、不大于等。比较运算符几乎适用于所有的表达式（除了text、ntext 或image 数据类型的表达式外）。表列出了Transact-SQL 支持的比较运算符。 比较运算符 运算符 含义 = 等于 > 大于 小于 >= 大于或等于 小于或等于 <> 不等于 != 不等于 ! 不小于 !> 不大于 "},"page/11293.html":{"url":"page/11293.html","title":"逻辑","keywords":"","body":"逻辑 "},"page/11196.html":{"url":"page/11196.html","title":"MSSQL逻辑","keywords":"","body":"逻辑 逻辑运算符 　　逻辑运算符用于对某些条件进行测试，返回值为TRUE或FALSE。逻辑运算符包括ALL、AND、ANY、BETWEEN、EXISTS、IN、LIKE、NOT、OR、SOME等，其含义说明如表所示 逻辑运算符及其含义 逻辑运算符 含义 AND 对两个表达式进行逻辑与运算，即如果两个表达式的返回值均为TRUE，则运算结果返回TRUE，否则返回FALSE。 BETWEEN 测试操作数是否在BETWEEN指定的范围之内，如果在则返回TRUE，否则返回FALSE EXISTS 测试查询结果是否包含某些行，如果包含则返回TRUE，否则返回FALSE IN 测试操作数是否在IN后面的表达式列表中，如果在则返回TRUE，否则返回FALSE LIKE 测试操作数是否与LIKE后面指定的模式相匹配，如果匹配返回TRUE，否则返回FALSE NOT 对表达式的逻辑值取反 OR 对两个表达式进行逻辑与或运算，即如果两个表达式的返回值均为FALSE，则运算结果返回FALSE，否则返回TRUE。 ANY 在一组的比较中只要有一个TRUE，则运算结果返回TRUE，否则返回FALSE ALL 在一组的比较中只有所有的比较都返回TRUE，则运算结果返回TRUE，否则返回FALSE SOME 在一组的比较中只要有部分比较都返回TRUE，则运算结果返回TRUE，否则返回FALSE （1）ANY(任意一个)、SOME(任意一个)、ALL、IN的使用。 可以将ALL或ANY关键字与比较运算符组合进行子查询。SOME的用法与ANY相同。=ANY运算符与IN等效。 <>ALL与NOT IN等效。 以 > 比较运算符为例： ALL表示大于每一个值，即大于最大值。例如，>ALL(5, 2, 3)表示大于5。因此，使用>ALL的子查询也可用MAX集函数实现。 ANY表示至少大于一个值，即大于最小值。例如，>ANY (7, 2, 3)表示大于2。因此，使用>ANY的子查询也可用MIN集函数实现。 【例5.10】 查询成绩高于“林一帆”最高成绩的学生姓名、课程名及成绩。 USE PXSCJ GO SELECT 姓名, 课程名, 成绩 FROM XSB, CJB, KCB WHERE 成绩> ALL ( SELECT b.成绩 FROM XSB a, CJB b WHERE a.学号= b.学号 AND a.姓名= '林一帆' ) AND XSB.学号=CJB.学号 AND KCB.课程号=CJB.课程号 AND 姓名<>'林一帆' （2）BETWEEN的使用。 语法格式： test_expression [ NOT ] BETWEEN begin_expression AND end_expression 如果test_expression的值大于或等于begin_expression的值并且小于或等于 end_expression的值，则运算结果为TRUE，否则为FALSE。test_expression为测试表达式，begin_expression和end_expression指定测试范围，三个表达式的类型必须相同。 NOT关键字表示对谓词BETWEEN的运算结果取反。 【例5.11】 查询总学分在 40～50之间的学生学号和姓名。 SELECT 学号, 姓名, 总学分 FROM XSB WHERE 总学分 BETWEEN 40 AND 50 使用 >= 和 = 40 AND 总学分 （3）LIKE的使用。 语法格式： match_expression [ NOT ] LIKE pattern [ ESCAPE Escape_character ] 确定给定的字符串是否与指定的模式匹配，若匹配，则运算结果为TRUE，否则为FALSE。模式可以包含普通字符和通配字符。LIKE运算符的内容参见第4章中WHERE子句一节。 【例5.13】 查询课程名以“计”或C开头的情况。 SELECT * FROM KCB WHERE 课程名 LIKE '[计C]%' （4）EXISTS与NOT EXISTS的使用。 语法格式： EXISTS subquery 用于检测一个子查询的结果是否不为空，若不为空则运算结果为真，否则为假。subquery用于代表一个受限的SELECT语句（不允许有COMPUTE子句和INTO关键字）。EXISTS子句的功能有时可用IN或= ANY运算符实现，而NOT EXISTS 的作用与EXISTS正相反。 【例5.14】 查询所有选课学生的姓名。 SELECT DISTINCT 姓名 FROM XSB WHERE EXISTS ( SELECT * FROM CJB WHERE XSB.学号= CJB.学号 ) "},"page/11294.html":{"url":"page/11294.html","title":"基本","keywords":"","body":"基本 "},"page/11295.html":{"url":"page/11295.html","title":"赋值","keywords":"","body":"赋值 "},"page/11225.html":{"url":"page/11225.html","title":"MSSQL赋值","keywords":"","body":"赋值 赋值运算符 　　 赋值运算符就是等号“=”，它是Transact-SQL中唯一的赋值运算符。 　　除了用作赋值操作以外，赋值运算符还可以用于建立字段标题和定义字段值的表达式之间的关系。 【例子】 下列语句创建了两个字段，其中第一个字段的列标题为“中国”，所有字段值均为“China”；第二个字段的列标题为“姓名”，该字段的字段值来自表student中的s_name字段值。 SELECT 中国= 'China', 姓名= s_name FROM student 执行结果如下： 中国 姓名 -------------------------- China 刘洋 China 王晓珂 China 王伟志 China 岳志强 China 贾簿 China 李思思 China 蒙恬 China 张宇 "},"page/11296.html":{"url":"page/11296.html","title":"字符串连接符","keywords":"","body":"字符串连接符 "},"page/11226.html":{"url":"page/11226.html","title":"MSSQL字符串连接符","keywords":"","body":"字符串连接运算符 　　在SQL Server中，字符串连接运算符为加号“+”，表示要将两个字符串连接起来而形成一个新的字符串。该运算符可以操作的字符串类型包括char、varchar、text以及nchar、nvarchar、ntext等。 'abc'+'defg' -- 结果为'abcdefg' ‘abc’ + ‘’ + ‘def’ -- 结果为‘abcdef’（默认），当兼容级别设置为65时结果为 'abc def' 　　针对字符串的操作有很多种，如取子串等。但在SQL Server中仅有字符串连接操作由运算符“+”来完成，而所有其他的字符串操作都使用字符串函数来进行处理。 "},"page/11297.html":{"url":"page/11297.html","title":"优先级","keywords":"","body":"优先级 "},"page/11197.html":{"url":"page/11197.html","title":"MSSQL优先级","keywords":"","body":"运算符的优先级 　　运算符执行顺序的不同会导致不同的运算结果，所以正确地理解运算符的优先级是必要的。下图给出了运算符优优先级的示意图，其中从上到下运算符的优先级是由高到低，同一级中运算符的优先级是按照它们在表达式中的顺序从左到右依次降低。 Transact-SQL运算符的优先级 一算关逻位 运 算 符 优 先 级 +（正）、-（负）、～（按位 NOT） 1 *（乘）、/（除）、%（模） 2 +（加）、+（串联）、-（减） 3 =, >, =, , !=, !>, ! 4 ^（位异或）、&（位与）、` `（位或） 5 NOT 6 AND 7 ALL、ANY、BETWEEN、IN、LIKE、OR、SOME 8 =（赋值） 9 "},"page/11191.html":{"url":"page/11191.html","title":"表达式","keywords":"","body":"表达式 "},"page/11194.html":{"url":"page/11194.html","title":"MSSQL","keywords":"","body":"MSSQL 表达式 一个表达式就是常量、变量、列名、复杂计算、运算符和函数的组合。 一个表达式通常可以得到一个值。 与常量和变量一样，一个表达式的值也具有某种数据类型，可能的数据类型有字符类型、数值类型、日期时间类型。 这样根据表达式的值的类型，表达式可分为字符型表达式、数值型表达式和日期时间型表达式。 表达式还可以根据值的复杂性来分类。 若表达式的结果只是一个值，如一个数值、一个单词或一个日期，则这种表达式叫做标量表达式，如1+2，'a'>'b'。 若表达式的结果是由不同类型数据组成的一行值，则这种表达式叫做行表达式。例如，（学号，'王林'，'计算机'，50*10）；当学号列的值为081101时，这个行表达式的值就为（'081101'，'王 林'，'计算机'，500）。 若表达式的结果为0个、1个或多个行表达式的集合，那么这个表达式就叫做表表达式。 表达式一般用在SELECT以及SELECT语句的WHERE子句中。 "},"page/11224.html":{"url":"page/11224.html","title":"MySQL","keywords":"","body":"MySQL "},"page/11149.html":{"url":"page/11149.html","title":"语句","keywords":"","body":"语句 "},"page/11018.html":{"url":"page/11018.html","title":"功能控制语句","keywords":"","body":"功能控制语句 SQL是Structured Query Language的缩写，译为“结构化查询语言”，它是关系数据库的标准语言。 按功能划分，SQL语言可以分为四类： 数据查询语言（Data Query Language, DQL） 数据定义语言（Data Definition Language, DDL） 数据操纵语言（Data Manipulation Language, DML） 数据控制语言（Data Control Language, DCL） 四大功能介绍： （1）数据查询功能 通过SELECT语句完成。SELECT语句的功能非常强大，表达形式非常丰富，可以完成很多复杂的查询任务。SQL语言的最初设计就是用于数据查询，这也是它之所以称为“结构查询语言（Structured Query Language）”的主要原因。 （2）数据操纵功能 通过INSERT、UPDATE、DELETE 语句完成。INSERT、UPDATE、DELETE 语句分别用于实现数据插入、数据更新和数据删除功能。 （3）数据定义功能 通过CREATE、ALTER、DROP语句来完成。CREATE、ALTER、DROP语句分别用于定义、修改和删除数据库和数据库对象，这些数据库对象包括数据表、视图等。 （4）数据控制功能 通过GRANT、REVOKE语句来完成。数据控制主要是指事务管理、数据保护（包括数据库的恢复、并发控制等）以及数据库的安全性和完整性控制。 四种功能与SQL语句的对应关系如表5.1所示： "},"page/11298.html":{"url":"page/11298.html","title":"MSSQL功能控制语句","keywords":"","body":"MSSQL功能控制语句 "},"page/11019.html":{"url":"page/11019.html","title":"数据定义语言DDL","keywords":"","body":"数据定义语言DDL "},"page/11262.html":{"url":"page/11262.html","title":"MSSQL","keywords":"","body":"MSSQL 数据定义：指对数据库对象的定义、删除和修改操作。 数据库对象主要包括数据表、视图、索引等。 数据定义功能通过CREATE、ALTER、DROP语句来完成。 按照操作对象分类来介绍数据定义的SQL语法。 "},"page/11150.html":{"url":"page/11150.html","title":"创建","keywords":"","body":"创建 "},"page/11020.html":{"url":"page/11020.html","title":"数据库","keywords":"","body":"数据库 "},"page/11061.html":{"url":"page/11061.html","title":"MSSQL","keywords":"","body":"命令方式 命令方式创建数据库使用CREATE DATABASE命令，创建前要确保用户具有创建数据库的权限 语法格式 CREATE DATABASE database_name [ ON [ PRIMARY ] [ [ ,...n ] [ , [ ,...n ] ] [ LOG ON { [ ,...n ] } ] ] [ COLLATE collation_name ] [ WITH ] [FOR { ATTACH | ATTACH_REBUILD_LOG }] ] [;] 其中， ::= {( NAME = logical_file_name , FILENAME = { 'os_file_name' | 'filestream_path' } [ , SIZE = size [ KB | MB | GB | TB ] ] [ , MAXSIZE = { max_size [ KB | MB | GB | TB ] | UNLIMITED } ] [ , FILEGROWTH = growth_increment [ KB | MB | GB | TB | % ] ] ) [ ,...n ] } ::= { FILEGROUP filegroup_name [ CONTAINS FILESTREAM ] [ DEFAULT ] [ ,...n ] } ::= { [ DB_CHAINING { ON | OFF } ] [ , TRUSTWORTHY { ON | OFF } ] } 在对语法格式进行解释之前，先介绍本书的Transact-SQL语法格式中使用的约定。表2.1列出了这些约定，并进行了说明。这些约定在本书介绍T-SQL语法格式时都适用。 表2.1 本书Transact-SQL语法的约定和说明 约 定 用 途 UPPERCASE（大写） Transact-SQL 关键字 ` ` 分隔括号或大括号中的语法项。只能选择其中一项 [ ] 可选语法项。不要输入方括号 { } 必选语法项。不要输入大括号 [,...n] 指示前面的项可以重复 n 次。每一项由逗号分隔 [ ...n] 指示前面的项可以重复 n 次。每一项由空格分隔 [;] 可选的 Transact-SQL 语句终止符。不要输入方括号 ::= 语法块的名称。此约定用于对可在语句中多个位置使用的过长语法段或语法单元进行分组和标记。可使用的语法块的每个位置由括在尖括号内的标签指示： 下面对CREATE DABASE命令的语法格式进行说明。 （1）database_name：所创建的数据库逻辑名称，该名称在SQL Server实例中必须唯一。其命名须遵循SQL Server 2008的命名规则，最大长度为128个字符。 （2）ON子句：指定了数据库的数据文件和文件组，其中，PRIMARY用来指定主文件。若不指定主文件，则各数据文件中的第一个文件将成为主文件。 （3）：指定数据库文件的属性，主要给出文件的逻辑名、存储路径、大小及增长特性。这些特征可以与以界面方式创建数据库时对数据库特征的设置相联系。 ① logical_file_name：逻辑文件名，是数据库创建后在所有T-SQL语句中引用文件时所使用的名字。 ② os_file_name：操作系统文件名，是操作系统在创建物理文件时使用的路径和文件名。对于FILESTREAM文件组，FILENAME选项指向将存储FILESTREAM数据的路径“filestream_path”。在最后一个文件夹之前的路径必须存在，但不能存在最后一个文件夹。例如，如果指定路径C:\\Filestream\\Data，则C:\\Filestream必须存在才能运行CREATE DATABASE语句，但 Data文件夹不能存在。有关FILESTREAM的内容将在第3章中介绍。 ③ size：是数据文件的初始容量大小。对于主文件，若不指出大小，则默认为model数据库主文件的大小。对于辅助数据文件，自动设置为3 MB。UNLIMITED关键字表示指定文件将增长到磁盘满。 ④ max_size：指定文件的最大大小。UNLIMITED关键字表示文件大小不受限制，但实际上受磁盘可用空间限制。如果不指定MAXSIZE选项，则文件将增长到磁盘空间满。 ⑤ growth_increament：指出文件每次的增量，有百分比和空间值两种格式，前者如10%，即每次在原来空间大小的基础上增长10%；后者如5 MB，即每次增长5 MB，而不管原来空间大小是多少。但要注意，FILEGROWTH的值不能超过MAXSIZE的值。 （4）：定义文件组的属性。filegroup_name为定义的文件组的名称，CONTAINS FILESTREAM选项指定文件组在文件系统中存储FILESTREAM二进制大型对象（BLOB）。DEFAULT关键字指定命名文件组为数据库中的默认文件组。用于指定属于该文件组的文件。文件组中各文件的描述和数据文件描述相同。 （5）LOG ON子句：用于指定数据库事务日志文件的属性，其定义格式与数据文件的格式相同。如果没有指定该子句，则将自动创建一个日志文件。 （6）COLLATE collation_name：指定数据库的默认排序规则。排序规则名称既可以是 Windows 排序规则名称，也可以是 SQL 排序规则名称。如果没有指定排序规则，则将SQL Server实例的默认排序规则分配为数据库的排序规则。 （7）WITH子句：用于控制外部与数据库之间的双向访问。 ① DB_CHAINING { ON | OFF } 当指定为ON时，数据库可以为跨数据库所有权链的源或目标。当为OFF时，数据库不能参与跨数据库所有权链接。默认值为OFF。 ② TRUSTWORTHY { ON | OFF } 当指定为ON时，使用模拟上下文的数据库模块（如视图、用户定义函数或存储过程）可以访问数据库以外的资源。当为OFF时，模拟上下文中的数据库模块不能访问数据库以外的资源。默认值为OFF。 （8）FOR子句： ① FOR ATTACH子句：指定通过附加一组现有的操作系统文件来创建数据库，使用FOR ATTACH子句时必须指定数据库的主文件。如果有多个数据和日志文件，则必须确保所有的.mdf文件和.ndf文件可用，否则操作将失败。 ② FOR ATTACH_REBUILD_LOG子句：指定通过附加一组现有的操作系统文件来创建数据库，使用这一选项将不再需要所有日志文件。 由语法格式可知，最简单的一句创建数据库的语句为 CREATE DATABASE database_name 【例2.5】 创建一个名为TEST1的数据库，其初始大小为5 MB，最大大小为50 MB，允许数据库自动增长，增长方式是按10%比例增长。日志文件初始为2 MB，最大可增长到5 MB，按1 MB增长。数据文件和日志文件的存放位置为SQL Server的数据库目录“C:\\Program Files\\Microsoft SQL Server\\MSSQL10.SQL2008\\ MSSQL\\DATA”。假设SQL Server服务已启动，并以系统管理员身份登录计算机。 在“SQL Server Management Studio”窗口中单击“新建查询”按钮新建一个查询窗口，如图2.12所示。 图2.12 SQL Server 2008“查询分析器”界面 在“查询分析器”窗口中输入如下T-SQL语句： CREATE DATABASE TEST1 ON ( NAME= 'TEST1_DATA', FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL10.SQL2008\\MSSQL\\DATA\\TEST1.mdf', SIZE=5 MB, MAXSIZE=50 MB, FILEGROWTH=10% ) LOG ON ( NAME='TEST1_log', FILENAME='C:\\Program Files\\Microsoft SQL Server\\MSSQL10.SQL2008\\MSSQL\\DATA\\TEST1.ldf', SIZE=2 MB, MAXSIZE=5 MB, FILEGROWTH=1 MB ); 输入完毕后，单击SSMS面板上的“!执行”按钮，如图2.13所示。从图中可以看到，CREATE DATABASE命令执行时，在结果窗口中将显示命令执行的进展情况。 当命令成功执行后，在“对象资源管理器”中展开“数据库”目录，可以看到，新建的数据库“TEST1”就显示于其中。如果没有发现“TEST1”，则选择“数据库”，右击鼠标，在弹出的快捷菜单中选择“刷新”菜单项即可。 图2.13 在查询分析器中执行创建数据库命令 通过数据库属性对话框可以看到，新建立TEST1数据库的各项属性完全符合预定要求。 【例2.6】 创建一个名为TEST2的数据库，它有两个数据文件，其中，主数据文件为20 MB，最大大小不限，按10%增长。 1个辅数据文件为20 MB，最大大小不限，按10%增长；有1个日志文件，大小为50 MB，最大大小为100 MB，按10 MB增长。 在查询分析器中输入如下T-SQL语句并执行. CREATE DATABASE TEST2 ON PRIMARY ( NAME = 'TEST2_data1', FILENAME = 'D:\\data\\test2_data1.mdf', SIZE = 20 MB, MAXSIZE = UNLIMITED, FILEGROWTH = 10% ), ( NAME = 'TEST2_data2', FILENAME = 'D:\\data\\test2_data2.ndf', SIZE = 20 MB, MAXSIZE = UNLIMITED, FILEGROWTH = 10% ) LOG ON ( NAME = 'TEST2_log1', FILENAME = 'D:\\data\\test2_log1.ldf', SIZE = 50 MB, MAXSIZE = 100 MB, FILEGROWTH = 10 MB ); 【例2.7】 创建一个具有2个文件组的数据库TEST3。要求： （1）主文件组包括文件TEST3_dat1，文件初始大小为20 MB，最大为60 MB，按5 MB增长； （2）有1个文件组名为TEST3Group1，包括文件TEST3_dat2，文件初始大小为10 MB，最大为30 MB，按10%增长。 CREATE DATABASE TEST3 ON PRIMARY ( NAME = 'TEST3_dat1', FILENAME = 'D:\\data\\TEST3_dat1.mdf', SIZE = 20 MB, MAXSIZE = 60 MB, FILEGROWTH = 5 MB ), FILEGROUP TEST3Group1 ( NAME = 'TEST3_dat2', FILENAME = 'D:\\data\\TEST3_dat2.ndf', SIZE = 10 MB, MAXSIZE = 30 MB, FILEGROWTH = 10% ) SQL Server界面方式创建数据库 1.右击数据库-->新建数据库 2.输入数据库名-->[设置存储位置等其他选项]-->确定 新建数据库属性 自动增长设置 下面以创建学生成绩管理系统的数据库（名为PXSCJ）为例，说明使用SQL Server Management Studio窗口图形化向导创建数据库的过程。 【例2.1】 创建数据库PXSCJ，数据文件和日志文件的属性按默认值设置。 创建该数据库的主要过程如下。 第1步：以系统管理员身份登录计算机，在桌面上单击“开始→所有程序→Microsoft SQL Server 2008”，选择并启动SQL Server Management Studio。使用默认的系统配置连接到数据库服务器。 第2步：选择“对象资源管理器”中服务器目录下的“数据库”目录，右击鼠标，在弹出的快捷菜单中选择“新建数据库”菜单项，打开“新建数据库”窗口。 第3步：“新建数据库”窗口的左上方共有三个选项卡——“常规”、“选项”和“文件组”，这里只配置“常规”选项卡，其他选项卡使用系统默认设置。 在“新建数据库”窗口的左上方选择“常规”选项卡，在“数据库名称”文本框中填写要创建的数据库名称“PXSCJ”，也可以在“所有者”文本框中指定数据库的所有者，如sa。这里使用默认值，其他属性也按默认值设置。 另外，可以通过单击自动增长标签栏下面的[...]按钮，弹出图2.3所示的对话框，在该对话框中可以设置数据库是否自动增长、增长方式、数据库文件最大文件大小。数据日志文件的自动增长设置对话框与数据文件的类似。 配置路径的方式与配置自动增长方式类似，可以通过单击路径标签栏下面的 按钮来自定义路径，默认路径为C:\\Program Files\\Microsoft SQL Server\\MSSQL10.SQL2008 \\MSSQL\\DATA。这里，数据库文件大小、增长方式和路径都使用默认值，确认后单击“确定”按钮。 至此数据库PXSCJ已经创建完成了，此时，可以在对象资源管理器的“数据库”目录下找到该数据库所对应的图标，如图所示。 创建后的PXSCJ数据库 "},"page/11062.html":{"url":"page/11062.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11021.html":{"url":"page/11021.html","title":"表","keywords":"","body":"表 "},"page/11063.html":{"url":"page/11063.html","title":"MSSQL","keywords":"","body":"命令 数据表的创建 创建表 创建表使用CREATE TABLE语句。 语法格式： CREATE TABLE [ database_name . [ schema_name ] . | schema_name . ] table_name ( { /*列的定义*/ | column_name AS computed_column_expression [PERSISTED [NOT NULL]] /*定义计算列*/ } [ ] [ ,...n ] /*指定表的约束*/ ) [ ON { partition_scheme_name ( partition_column_name ) | filegroup | \"default\" } ] /*指定分区方案和存储表的文件组*/ [ { TEXTIMAGE_ON { filegroup | \"default\" } ] /*指定存储text、ntext、image等类型数据的文件组*/ [ FILESTREAM_ON { partition_scheme_name | filegroup | \"default\" } ] /*指定存储FILESTREAM数据的文件组*/ [ WITH ( [ ,...n ] ) ] /*指定表选项*/ [ ; ] 列的定义格式如下： ::= column_name data_type /*指定列名、类型*/ [ FILESTREAM ] /*指定FILESTREAM属性*/ [ COLLATE collation_name ] /*指定排序规则*/ [ NULL | NOT NULL ] /*指定是否为空*/ [ [ CONSTRAINT constraint_name ] DEFAULT constant_expression ] /*指定默认值*/ | [ IDENTITY [ ( seed ,increment ) ] [ NOT FOR REPLICATION ] /*指定列为标识列*/ ] [ ROWGUIDCOL ] /*指定列为全局标识符列*/ [ [ ...n ] ] /*指定列的约束*/ [ SPARSE ] ：列的完整性约束，指定主键、替代键、外键等。例如，指定该列为主键则使用PRIMARY KEY关键字。 ：表的完整性约束，有关列的约束和表的约束将在后面介绍。 column_name AS computed_column_expression：用于定义计算字段，计算字段是由同一表中的其他字段通过表达式计算得到的。其中，column_name为计算字段的列名，computed_column_expression是表其他字段的表达式，表达式可以是非计算字段的字段名、常量、函数、变量，也可以是一个或多个运算符连接的上述元素的任意组合。系统不将计算列中的数据进行物理存储，该列只是一个虚拟列。如果需要将该列的数据物理化，则需要使用PERSISTED关键字。 ON 子句：filegroup | “default”指定存储表的文件组。如果指定了 filegroup，则表将存储在指定的文件组中，数据库中必须存在该文件组。如果指定“default”，或者未指定ON参数，则表存储在默认文件组中。partition_scheme_name(partition_column_ name)指定分区方案来创建分区表，partition_scheme_name是分区方案的名称，partition_column_name是表中的分区列。 TEXTIMAGE_ON {filegroup | \"default\"}：TEXTIMAGE_ON表示将text、ntext、image、xml、varchar(MAX)、nvarchar(MAX)、varbinary(MAX)和CLR用户定义类型的列存储在指定文件组中。 如果表中没有这些类型的列，则不能使用TEXTIMAGE_ON。如果没有指定TEXTIMAGE_ON或指定了\"default\"，则这些列将与表存储在同一文件组中。 FILESTREAM_ON子句：filegroup | \"default\"指定存储FILESTREAM数据的文件组。如果表包含FILESTREAM数据并且已分区，则必须包含FILESTREAM_ON子句并指定 FILESTREAM文件组的分区方案partition_scheme_name。 列的数据类型可以是SQL Server提供的系统数据类型，也可以是用户定义的数据类型。SQL Server 2008提供了丰富的系统数据类型，现将其列于表3.2中。 表3.2 系统数据类型表 数 据 类 型 符 号 标 识 整数型 bigint, int, smallint, tinyint 精确数值型 decimal, numeric 浮点型 float, real 货币型 money, smallmoney 位型 bit 字符型 char, varchar、varchar(MAX) Unicode字符型 nchar, nvarchar、nvarchar(MAX) 文本型 text, ntext 二进制型 binary, varbinary、varbinary(MAX) 日期时间类型 datetime, smalldatetime, date, time, datetime2, datetimeoffset 时间戳型 timestamp 图像型 image 其他 cursor, sql_variant, table, uniqueidentifier, xml, hierarchyid 数据表是关系模式在关系数据库中的实例化，是数据库中唯一用于存储数据的数据库对象，它是整个数据库系统的基础。创建数据表是数据库建立的重要组成部分，由SQL语言中的CREATE TABLE语句来完成，其语法格式如下： CREATE TABLE [schema_name.]table_name( column1_name data_type [integrality_condition_on_column] [,column2_name data_type [integrality_condition_on_column]] … [, integrality_condition_on_TABLE]); 所涉及参数说明如下： tanble_name为所定义的数据表的名称，即表名。在一个数据库中表名必须唯一，而且表名应该能够概括该数据表保存数据所蕴涵的主题。 schema_name为表所属的架构的名称。自SQL Server 2008开始，每数据库对象都属于某一个架构，如果在定义时不指定架构，则使用默认架构dbo。关于架构的作用和意义将在后面介绍。 column1_name、column2_name表示字段名，或者称字段名。在一个表中，字段名也必须唯一，最好能够概括该字段的含义。 data_type表示数据类型。根据需要，它可以设置为上节介绍的数据类型中某一种。 integrality_condition_on_column表示字段级的完整性约束条件。这些约束条件只对相应的字段起作用，其取值如下： NOT NULL：选取该条件时，字段值不能为空。 DEFAULT：设定字段的默认值，设置格式为：DEFAULT constant，其中constant表示常量。 UNIQUE：选取该条件时，字段值不能重复。 CHECK：用于设置字段的取值范围，格式为：CHECK(expression)，其中expression为约束表达式。 PRIMARY KEY：选取该条件时，相应字段被设置为主码（主键）。 FOREIGN KEY：选取该条件时，相应字段被设置为外码（外键）。外码的设置涉及到两个表，其格式如下： FOREIGN KEY column_name REFERENCES foreign_table_name(foreign_column_name) integrality_condition_on_TABLE表示表级的完整性约束条件。 与integrality_condition_on_column不同的是，integrality_condition_on_column仅仅作用于其对应的字段，而不能设置为同时作用于多个字段；integrality_condition_on_TABLE则可以作用多个字段或整个数据表。 上述的约束条件中，除了NOT NULL和DEFAULT以外，其他的约束条件都可以在integrality_condition_on_TABLE中定义，使它们同时作用多个字段。凡是涉及到多个字段的约束条件都必须在integrality_condition_on_TABLE中定义。 注意： 由两个字段组成的主码必须利用PRIMARY KEY在 \u000b integrality_condition_on_TABLE中定义。 SQL语言对大小写不敏感。 XSB的表结构 列 名 数 据 类 型 长 度 是 否 可 空 默 认 值 说 明 学号 定长字符型（char） 6 × 无 主键, 前2位表示年级, 中间2位为班级号，后2位为序号 姓名 定长字符型（char） 8 × 无 性别 位型（bit） 默认值 √ 1 1: 男 0: 女 出生时间 日期型（date） 默认值 √ 无 专业 定长字符型（char） 12 √ 无 总学分 整数型（int） 默认值 √ 0 0≤总学分 备注 不定长字符型（varchar） 500 √ 无 参照XSB表结构的设计方法，同样可以设计出其他两个表的结构，表3.4所示是KCB的表结构，表3.5所示是CJB的表结构。 KCB的表结构 列 名 数 据 类 型 长 度 是 否 可 空 默 认 值 说 明 课程号 定长字符型（char） 3 × 无 主键 课程名 定长字符型（char） 16 × 无 开课学期 整数型（tinyint） 1 √ 1 只能为1～8 学时 整数型（tinyint） 1 √ 0 学分 整数型（tinyint） 1 × 0 CJB的表结构 列 名 数 据 类 型 长 度 是 否 可 空 默 认 值 说 明 学号 定长字符型（char） 6 × 无 主键 课程号 定长字符型（char） 3 × 无 主键 成绩 整数型（int） 默认值 √ 0 【例3.5】 设已经创建了数据库PXSCJ，现在该数据库中需创建学生情况表XSB，该表的结构见表3.3。创建表XSB的T-SQL语句如下： USE PXSCJ GO CREATE TABLE XSB ( 学号 char(6) NOT NULL PRIMARY KEY, 姓名 char(8) NOT NULL, 性别 bit NULL DEFAULT 1, 出生时间 date NULL, 专业 char(12) NULL, 总学分 int NULL, 备注 varchar(500) NULL ) 【例3.6】 创建一个带计算列的表，表中包含课程的课程号、总成绩和学习该课程的人数，以及课程的平均成绩。 CREATE TABLE PJCJ ( 课程号 char(3) PRIMARY KEY, 总成绩 real NOT NULL, 人数 int NOT NULL, 平均成绩 AS 总成绩/人数 PERSISTED ) 1．使用T-SQL语句创建分区表 （1）创建分区函数。创建分区函数使用CREATE PARTITION FUNCTION命令，语法格式如下。 CREATE PARTITION FUNCTION partition_function_name ( input_parameter_type ) AS RANGE [ LEFT | RIGHT ] =在哪一侧 FOR VALUES ( [ boundary_value [ ,...n ] ] ) [ ; ] 【例3.7】 对int类型的列创建一个名为NumberPF的分区函数，该函数把int类型的列中数据分成5个区。分为小于或等于50的区、大于50且小于或等于500的区、大于500且小于或等于1000的区、大于1000且小于或等于2000的区、大于2000的区。 CREATE PARTITION FUNCTION NumberPF(int) AS RANGE LEFT FOR VALUES(50,500,1000,2000) GO （2）创建分区方案。分区函数创建完后可以使用CREATE PARTITION SCHEME命令创建分区方案，由于在创建分区方案时需要根据分区函数的参数定义映射分区的文件组。所以需要有文件组来容纳分区数，文件组可以由一个或多个文件构成，而每个分区必须映射到一个文件组。一个文件组可以由多个分区使用。在一般情况下，文件组数最好与分区数相同，并且这些文件组通常位于不同的磁盘上。一个分区方案只可以使用一个分区函数，而一个分区函数可以用于多个分区方案中。 CREATE PARTITION SCHEME命令的语法格式如下。 CREATE PARTITION SCHEME partition_scheme_name AS PARTITION partition_function_name [ ALL ] TO ( { file_group_name | [ PRIMARY ] } [ ,...n ] ) [ ; ] 【例3.8】 假设文件组FGroup1、FGroup2、FGroup3、FGroup4、FGroup5已经在数据库PXSCJ中存在。根据例3.7中定义的分区函数创建一个分区方案，将分区函数中的5个分区分别存放在这5个文件组中。 CREATE PARTITION SCHEME NumberPS AS PARTITION NumberPF TO(FGroup1, FGroup2, FGroup3, FGroup4, FGroup5) GO （3）使用分区方案创建分区表。分区函数和分区方案创建以后就可以创建分区表了。创建分区表使用CREATE TABLE语句，只要在ON关键字后指定分区方案和分区列即可。 【例3.9】 在数据库PXSCJ中创建分区表，表中包含“编号”（值可以是1～5000）、“名称”两列，要求使用例3.8中的分区方案。 USE PXSCJ CREATE TABLE sample ( 编号 int NOT NULL PRIMARY KEY, 名称 char(8) NOT NULL ) ON NumberPS(编号) GO SQL Server 新建表 新建 1.选择数据库-->选择表-->右击新建表 设置列属性 1.输入数据- 设为单列为主键：选中列-->右击设为主键 设置多列为主键：按住ctrl不放-->左单击对应列的空白处（如下图）-->松开ctrl-->右单击选择主键 2.输入数据-->设置是否允许为null 3.输入数据-->选中列-->选择【默认值或者绑定】-->输入默认值 4.check约束 设置表名 1.右击任意列选择属性 2.选择输入名称 保存并查看表 1.点击保存 2．使用图形向导方式创建分区表 【例3.10】 使用图形向导方式对PXSCJ数据库中的CJB表根据“成绩”列分区，成绩值为0～100，根据成绩值分为5个区：0～59，60～69，70～79，81～89，90～100。操作步骤如下。 第1步：启动SQL Server Management Studio，在对象资源管理器中展开“数据库”，右击“PXSCJ”数据库菜单下的“表”选项，右击表“dbo.CJB”选择“存储”菜单项，单击“创建分区”子菜单项，进入分区向导窗口，单击“下一步”按钮，进入“选择分区列”界面，界面中将显示可用的分区列，选择“成绩”列，如图3.13所示。 图3.13 选择分区列 第2步：单击“下一步”按钮，进入“选择分区函数”界面。选择“新建分区函数”选项，填写要新建的分区函数的名称，如PointsPF，如图3.14所示。当然，也可以选择现有的分区函数。 图3.14 选择分区函数 第3步：单击“下一步”按钮，进入“选择分区方案”界面。填写要新建的分区方案的名称，如PointsPS，如图3.15所示，单击“下一步”按钮。 图3.15 选择分区方案 第4步：进入“映射分区”界面，在界面中选择各个分区要映射到的文件组，如FGroup1、FGroup2等。选择单选按钮“左边界”，在“ 图3.16 选择文件组和指定边界值 第5步：单击“下一步”按钮，进入“选择输出选项”界面。用户可以在其中选择“立即运行”选项，并单击“完成”按钮完成对CJB的分区。用户也可以选择“创建脚本”选项，并指定保存脚本的位置。 在开始使用FILESTREAM之前，必须在SQL Server 2008数据库引擎实例中启用FILESTREAM，操作步骤如下。 第1步：在SQL Server配置管理器中打开SQL Server 2008数据库实例的“属性”窗口，选择“FILESTREAM”选项卡，选中“针对Transact-SQL访问启用FILESTREAM”复选框，其他的选项是针对Windows进行读/写的，可以都选中，如图3.11所示，然后单击“确定”按钮保存对FILESTREAM的设置。 启用FILESTREAM 第2步：打开SSMS，在对象资源管理器中右击已连接的服务器，选择“属性”菜单项。在“服务器属性”窗口中选择“高级”选项卡，在“文件流访问级别”选项后的下拉列表框中选择“已启用完全访问”选项，如图3.12所示。单击“确定”按钮后在SQL Server配置管理器中重启SQL Server服务，FILESTREAM在数据库实例中的设置即可完成。 图3.12 设置文件流访问级别 完成以上步骤后数据库实例即启用了FILESTREAM，接下来就可以创建FILESTREAM文件组和具有FILESTREAM数据列的表了。在创建了FILESTREAM数据列后，访问的方法与访问一般varbinary(MAX)列的方式相同。 NULL | NOT NULL：NULL表示列可取空值，NOT NULL表示列不可取空值。 DEFAULT constant_expression：为所在列指定默认值，默认值constant_expression必须是一个常量值、标量函数或NULL值。DEFAULT定义可适用于除定义为timestamp或带identity属性的列以外的任何列。 IDENTITY：指出该列为标识符列，为该列提供一个唯一的、递增的值。seed是标识字段的起始值，默认值为1，increment是标识增量，默认值为1。如果为IDENTITY属性指定了NOT FOR REPLICATION选项，则复制代理执行插入时，标识列中的值将不会增加。 "},"page/11064.html":{"url":"page/11064.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11022.html":{"url":"page/11022.html","title":"索引","keywords":"","body":"索引 "},"page/11065.html":{"url":"page/11065.html","title":"MSSQL","keywords":"","body":"SQL Server 在PXSCJ数据库中，经常要对XSB、KCB、CJB三个表进行查询和更新。为了提高查询和更新速度，可以考虑对三个表建立如下索引： （1）对于XSB表，按学号建立主键索引（PRIMARY KEY），组织方式为聚集索引。 （2）对于KCB表，按课程号建立主键索引，组织方式为聚集索引。 （3）对于KCB表，按课程名建立唯一索引（UNIQUE约束），组织方式为非聚集索引。 （4）对于CJB表，按学号+课程号建立唯一索引，组织方式为聚集索引。 在SQL Server Management Studio中，既可利用界面方式创建上述索引，也可以利用T-SQL命令通过查询分析器建立索引。 利用SQL命令建立索引 使用CREATE INDEX语句可以为表创建索引。 语法格式： CREATE [ UNIQUE ] /*指定索引是否唯一*/ [ CLUSTERED | NONCLUSTERED ] /*索引的组织方式*/ INDEX index_name /*索引名称*/ ON {[ database_name. [ schema_name ] . | schema_name. ] table_or_view_name} ( column [ ASC | DESC ] [ ,...n ] ) /*索引定义的依据*/ [ INCLUDE ( column_name [ ,...n ] ) ] [ WHERE column_name IN (constant ,…) | column_name constant ] /*筛选索引*/ [ WITH ( [ ,...n ] ) ] /*索引选项*/ [ ON { partition_scheme_name ( column_name ) /*指定分区方案*/ | filegroup_name /*指定索引文件所在的文件组*/ | default } ] [ FILESTREAM_ON { filestream_filegroup_name | partition_scheme_name | \"NULL\" } ] /*指定FILESTREAM数据的位置*/ [ ; ] 其中， ::= { PAD_INDEX = { ON | OFF } | FILLFACTOR = fillfactor | SORT_IN_TEMPDB = { ON | OFF } | IGNORE_DUP_KEY = { ON | OFF } | STATISTICS_NORECOMPUTE = { ON | OFF } | DROP_EXISTING = { ON | OFF } | ONLINE = { ON | OFF } | ALLOW_ROW_LOCKS = { ON | OFF } | ALLOW_PAGE_LOCKS = { ON | OFF } | MAXDOP = max_degree_of_parallelism } 【例6.1】 为KCB表的“课程名”列创建索引。 USE PXSCJ GO CREATE INDEX kc_name_ind ON KCB(课程名) /* 默认不唯一，非聚集，升序 */ 【例6.2】 根据KCB表的“课程号”列创建唯一聚集索引，因为指定了CLUSTERED，所以该索引将对磁盘上的数据进行物理排序。 CREATE UNIQUE CLUSTERED INDEX kc_id_ind /* 唯一 聚集 */ ON KCB (课程号) 【例6.3】 根据CJB表的“学号”列和“课程号”列创建复合索引。 /*有主键没别要，只是说明可以*/ CREATE INDEX CJB_ind ON CJB(学号, 课程号) WITH(DROP_EXISTING= ON) 【例6.4】 根据XSB表中的“总学分”列创建索引，例中使用了FILLFACTOR子句。 CREATE NONCLUSTERED INDEX score_ind ON XSB(总学分) WITH FILLFACTOR = 60 【例6.5】 根据XSB表中“学号”列创建唯一聚集索引。如果输入了重复的键，将忽略该INSERT或UPDATE语句。 /*主键--非空，聚集，唯一*/ CREATE UNIQUE CLUSTERED INDEX xs_ind ON XSB(学号) WITH IGNORE_DUP_KEY 创建索引有如下几点要说明： （1）在计算列上创建索引。对于UNIQUE或PRIMARY KEY索引，只要满足索引条件，就可以包含计算列，但计算列必须具有确定性，必须精确。若计算列中带有函数，则使用该函数时有相同的参数输入，输出的结果也一定相同时，该计算列是确定的。而有些函数，如getdate()，每次调用时都输出不同的结果，这时就不能在计算列上定义索引。 总分可以，加入一个人每次查询总分都一样结果 而时间，每次都不一样 计算列为text、ntext或image列时也不能在该列上创建索引。 大文件不可以建索引 （2）在视图上创建索引。可以在视图上定义索引。索引视图是一种在数据库中存储视图结果集的方法，可减少动态生成结果集的开销。索引视图还能自动反映出创建索引后对基表数据所做的修改。（前提可更新视图） 【例6.6】 创建一个视图，并为该视图创建索引。 /*定义视图，在以下例子中使用了WITH SCHEMABINDING子句，因此定义视图时，SELECT子句中表名必须为“架构名.表名”的形式*/ CREATE VIEW View_stu WITH SCHEMABINDING /*WITH SCHEMABINDING要指定哪个架构哪个表*/ AS SELECT 学号, 姓名 FROM dbo.XSB GO /*在视图上创建索引*/ CREATE UNIQUE CLUSTERED INDEX Inx1 ON View_stu(学号) GO 界面方式创建索引 启动“SQL Server Management Studio”，在对象资源管理器中展开“数据库”，选择“表” ，右击其中的“索引”项，在弹出的快捷菜单上选择“新建索引(N)…”菜单项。 这时，用户可以在弹出的“新建索引”窗口中输入索引名称（索引名在表中必须唯一），如PX_XSB，选择索引类型为“聚集”，勾选“唯一”复选框，单击新建索引窗口的“添加”按钮，在弹出的“选择要添加到索引键的表列”窗口（如图6.1所示）中选择要添加的列，添加完毕后，单击“确定”按钮，在主界面中为索引键列设置相关的属性，单击“确定”按钮，即完成索引的创建工作。 在“表设计器”窗口创建索引的方法如下。 第1步：右击PXSCJ数据库中的“dbo.XSB”表，在弹出的快捷菜单中选择“设计”菜单项，打开“表设计器”窗口。 第2步：在“表设计器”窗口中，选择“学号”属性列，右击鼠标，在弹出的快捷菜单中选择“索引/键”菜单项。在打开的“索引/键”窗口中单击“添加”按钮，并在右边的“标识”属性区域的“名称”一栏中确定新索引的名称（用系统默认的名或重新取名）。在右边的常规属性区域中的“列”一栏后面单击“ ”按钮，可以修改要创建索引的列。如果将“是唯一的”一栏设定为“是”则表示索引是唯一索引。在“表设计器”栏下的“创建为聚集的”选项中，可以设置是否创建为聚集索引，由于XSB表中已经存在聚集索引，所以这里的这个选项不可修改，如图6.2所示。 第3步：最后关闭该窗口，单击面板上的“保存”按钮，在弹出的对话框中单击“是”按钮，索引创建即完成。 索引创建完后，只需返回SSMS主窗口，在对象资源管理器中展开“dbo.XSB”表中的“索引”项，就可以查看已建立的索引。其他索引的创建方法与之类似。 "},"page/11066.html":{"url":"page/11066.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11023.html":{"url":"page/11023.html","title":"视图","keywords":"","body":"视图 "},"page/11067.html":{"url":"page/11067.html","title":"MSSQL","keywords":"","body":"SQL Server 使用CREATE VIEW语句创建视图 T-SQL中用于创建视图的语句是CREATE VIEW语句，例如，用该语句创建视图CS_XS，其表示形式为 USE PXSCJ GO CREATE VIEW CS_XS AS SELECT * FROM XSB WHERE 专业= '计算机' 语法格式： CREATE VIEW [ schema_name . ] view_name [ (column [ ,...n ] ) ] [ WITH [ ,...n ] ] AS select_statement [ ; ] [ WITH CHECK OPTION ] 其中， ::= { [ ENCRYPTION ] [ SCHEMABINDING ] [ VIEW_METADATA ] } 说明如下 （1）scheme：数据库架构名；view_name是视图名。 （2）column：列名，它是视图中包含的列，可以有多个列名。若使用与源表或视图相同的列名，则不必给出列名。 （3）WITH ：指出视图的属性，view_attribute可以取以下值。 ① ENCRYPTION：说明在系统表syscomments中存储CREATE VIEW语句时进行加密。 ② SCHEMABINDING：说明将视图与其所依赖的表或视图结构相关联。 ③ VIEW_METADATA：当引用视图的浏览模式元数据时 ，向DBLIB、ODBC或OLEDB API返回有关视图的元数据信息，而不返回基表的元数据信息。 （4）select_statement：用来创建视图的SELECT语句，可在SELECT语句中查询多个表或视图，以表明新创建的视图所参照的表或视图。但对SELECT语句有以下限制： ① 定义视图的用户必须对所参照的表或视图有查询（即可执行SELECT语句）权限； ② 不能使用COMPUTE或COMPUTE BY子句； ③ 不能使用ORDER BY子句； ④ 不能使用INTO子句； ⑤ 不能在临时表或表变量上创建视图。 （5）WITH CHECK OPTION：指出在视图上所进行的修改都要符合select_statement所指定的限制条件，这样可以确保数据修改后，仍可通过视图看到修改的数据。例如对于CS_XS视图，只能修改除“专业”字段以外的字段值，而不能把“专业”字段的值改为“计算机”以外的值，以保证仍可通过CS_XS查询到修改后的数据。 【例4.75】 创建CS_KC视图，包括计算机专业各学生的学号、其选修的课程号及成绩。要保证对该视图的修改都符合“专业为计算机”这一条件。 USE PXSCJ GO CREATE VIEW CS_KC WITH ENCRYPTION AS SELECT XSB.学号, 课程号, 成绩 FROM XSB, CJB WHERE XSB.学号 =CJB.学号 AND 专业 = '计算机' WITH CHECK OPTION 【例4.76】 创建计算机专业学生的平均成绩视图CS_KC_AVG，包括学号（在视图中列名为num）和平均成绩（在视图中列名为score_avg）。 CREATE VIEW CS_KC_AVG(num,score_avg) AS SELECT 学号, AVG(成绩) FROM CJB GROUP BY 学号 在一般情况下，如果视图为下列格式，则称其为分区视图。 CREATE VIEW view_name AS SELECT FROM T1 UNION ALL SELECT FROM T2 UNION ALL ... SELECT FROM Tn 【例4.77】 使用视图CS_KC查找计算机专业的学生学号和选修的课程号。 SELECT 学号, 课程号 FROM CS_KC 【例4.78】 查找平均成绩在80分以上的学生的学号和平均成绩。 本例首先创建学生平均成绩视图XS_KC_AVG，包括学号（在视图中列名为num）和平均成绩（在视图中列名为score_avg）。 CREATE VIEW XS_KC_AVG ( num,score_avg ) AS SELECT 学号, AVG(成绩) FROM CJB GROUP BY 学号 再对XS_KC_AVG视图进行查询。 SELECT * FROM XS_KC_AVG WHERE score_avg >= 80 执行结果如下： 界面创建视图 1．在“SQL Server Management Studio”中创建视图 其主要步骤如下。 第1步：启动“SQL Server Management Studio”，在对象资源管理器中展开“数据库→PXSCJ”，选择其中的“视图”项，右击鼠标，在弹出的快捷菜单上选择“新建视图(N)”菜单项。 第2步：在随后出现的“添加表”窗口中，添加所需要关联的基本表、视图、函数、同义词。这里只使用“表”选项卡，选择表“XSB”，如图4.6所示，单击“添加”按钮。如果还需要添加其他表，则可以继续选择添加基表，如果不再需要添加，可以单击“关闭”按钮关闭该窗口。 图4.6 “添加表”快捷菜单 第3步：基表添加完后，在“视图”窗口的“关系图”窗口中显示了基表的全部列信息，如图4.7所示。根据需要在图4.7所示的窗口中选择创建视图所需的字段，可以在子窗口中的“列”一栏指定与视图关联的列，在“排序类型”一栏指定列的排序方式，在“筛选器”一栏指定创建视图的规则（本例在“专业”字段的“筛选器”栏中填写“计算机”）。 图4.7 创建视图 第4步：上一步完成后，单击面板上的“保存”按钮，出现“保存视图”对话框在其中输入视图名“CS_XS”，并单击“确定”按钮，便完成了视图的创建。 视图创建成功后便包含了所选择的列数据。例如，若创建了CS_XS视图，则可查看其结构及内容。 查看的方法是：启动“SQL Server Management Studio”，在对象资源管理器中展开“数据库→PXSCJ→视图”，选择“dbo.CS_XS”，右击鼠标，在弹出的快捷菜单中选择“设计”菜单项，可以查看并修改视图结构，选择“编辑前200行”菜单项，将可查看视图数据内容。 "},"page/11068.html":{"url":"page/11068.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11024.html":{"url":"page/11024.html","title":"存储过程","keywords":"","body":"存储过程 "},"page/11069.html":{"url":"page/11069.html","title":"MSSQL","keywords":"","body":"SQL Server 1．使用T-SQL命令创建存储过程 创建存储过程的语句是CREATE PROCEDURE或CREATE PROC，两者同义。 语法格式： CREATE { PROC | PROCEDURE } [schema_name.] procedure_name [ ; number] /*定义过程名*/ [ { @parameter [ type_schema_name. ] data_type } /*定义参数的类型*/ [ VARYING ] [ = default ] [ OUT | OUTPUT ] [READONLY] /*定义参数的属性*/ ][ ,...n ] [ WITH ] [ ,...n ] /*定义存储过程的处理方式*/ [ FOR REPLICATION ] AS { [;][ ...n ] /*执行的操作*/ | EXTERNAL NAME asse MBly_name.class_name.method_name } [;] 其中， ::= [ ENCRYPTION ] [ RECOMPILE ] 2．存储过程的执行 通过EXECUTE或EXEC命令可以执行一个已定义的存储过程，EXEC是EXECUTE的简写。语法格式： [ { EXEC | EXECUTE } ] { [ @return_status = ] { module_name [ ;number] | @module_name_var } [ [ @parameter = ] { value | @variable [ OUTPUT ] | [ DEFAULT ] }] [ ,...n ] [ WITH RECOMPILE ] } [;] 3．举例 （1）设计简单的存储过程。 【例7.1】 返回081101号学生的成绩情况。该存储过程不使用任何参数。 USE PXSCJ GO CREATE PROCEDURE student_info AS SELECT * FROM CJB WHERE 学号= '081101' GO 存储过程定义后，执行存储过程student_info： EXECUTE student_info 如果该存储过程是批处理中的第一条语句，则可使用 student_info 执行结果如下： （2）使用带参数的存储过程。 【例7.2】 从PXSCJ数据库的三个表中查询某人指定课程的成绩和学分。该存储过程接收与传递参数精确匹配的值。 USE PXSCJ GO CREATE PROCEDURE student_info1 @name char (8), @cname char(16) AS SELECT a.学号, 姓名, 课程名, 成绩, t.学分 FROM XSB a INNER JOIN CJB b ON a.学号 = b.学号 INNER JOIN KCB t ON b.课程号= t.课程号 WHERE a.姓名=@name and t.课程名=@cname GO 执行存储过程student_info1： EXECUTE student_info1 '王林', '计算机基础' 执行结果如下： 以下命令的执行结果与上面的相同： EXECUTE student_info1 @name='王林', @cname='计算机基础' 或者 DECLARE @proc char(20) SET @proc= 'student_info1' EXECUTE @proc @name='王林', @cname='计算机基础' （3）使用带OUPUT参数的存储过程。 【例7.3】 创建一个存储过程do_insert，作用是向XSB表中插入一行数据。创建另外一个存储过程do_action，在其中调用第一个存储过程，并根据条件处理该行数据，处理后输出相应的信息。 第一个存储过程： CREATE PROCEDURE dbo.do_insert AS INSERT INTO XSB VALUES('091201', '陶伟', 1, '1990-03-05', '软件工程',50, NULL); 第二个存储过程： CREATE PROCEDURE do_action @X bit, @STR CHAR(8) OUTPUT AS BEGIN EXEC do_insert IF @X=0 BEGIN UPDATE XSB SET 姓名='刘英', 性别=0 WHERE 学号='091201' SET @STR='修改成功' END ELSE IF @X=1 BEGIN DELETE FROM XSB WHERE 学号='091201' SET @STR='删除成功' END END 接下来执行存储过程do_action来查看结果： DECLARE @str char(8) EXEC dbo.do_action 0, @str OUTPUT SELECT @str; 执行结果如下： 无列名 ----- 修改成功 （4）使用带有通配符参数的存储过程。 【例7.4】 从三个表的连接中返回指定学生的学号、姓名、所选课程名称及该课程的成绩。该存储过程在参数中使用了模式匹配，如果没有提供参数，则使用预设的默认值。 CREATE PROCEDURE st_info @name varchar(30) = '李%' /*默认值是李%*/ AS SELECT a.学号,a.姓名,c.课程名,b.成绩 FROM XSB a INNER JOIN CJB b ON a.学号 =b.学号 INNER JOIN KCB c ON c.课程号= b.课程号 WHERE 姓名 LIKE @name GO 执行存储过程： EXECUTE st_info /*参数使用默认值*/ 或者 EXECUTE st_info '王%' /*传递给@name 的实参为'王%'*/ （5）使用OUTPUT游标参数的存储过程。OUTPUT游标参数用于返回存储过程的局部游标。 【例7.5】 在 PXSCJ数据库的XSB表上声明并打开一个游标。 CREATE PROCEDURE st_cursor @st_cursor cursor VARYING OUTPUT AS SET @st_cursor = CURSOR FORWARD_ONLY STATIC FOR SELECT * FROM XSB OPEN @st_cursor 在如下的批处理中，声明一个局部游标变量，执行上述存储过程，并将游标赋值给局部游标变量，然后通过该游标变量读取记录。 DECLARE @MyCursor cursor EXEC st_cursor @st_cursor = @MyCursor OUTPUT /*执行存储过程*/ FETCH NEXT FROM @MyCursor WHILE (@@FETCH_STATUS = 0) BEGIN FETCH NEXT FROM @MyCursor END CLOSE @MyCursor DEALLOCATE @MyCursor （6）使用WITH ENCRYPTION选项。WITH ENCRYPTION子句用于对用户隐藏存储过程的文本。 【例7.6】 创建加密过程，使用 sp_helptext 系统存储过程获取关于加密过程的信息，然后尝试直接从 syscomments 表中获取关于该过程的信息。 CREATE PROCEDURE encrypt_this WITH ENCRYPTION AS SELECT * FROM XSB 通过系统存储过程sp_helptext可显示规则、默认值、未加密的存储过程、用户定义函数、触发器或视图的文本。 执行如下语句： EXEC sp_helptext encrypt_this 结果集为提示信息“对象'encrypt_this'的文本已加密”。 （1）创建存储过程。例如，如果要通过图形向导方式定义一个存储过程来查询PXSCJ数据库中每个同学各门功课的成绩，那么其主要步骤如下： 启动SQL Server Management Studio，在对象资源管理器中展开“数据库→PXSCJ”，选择其中的“可编程性”，右击“存储过程”，在弹出的快捷菜单中选择“新建存储过程”菜单项，打开“存储过程脚本编辑”窗口，如图7.1所示。在该窗口中输入要创建的存储过程的代码，输入完成后单击“执行”按钮，若执行成功则创建完成。 （2）执行存储过程。在PXSCJ数据库的“存储过程”目录下选择要执行的存储过程，例如student_info1，右击鼠标，选择“执行存储过程”菜单项。在弹出的“执行过程”窗口中会列出存储过程的参数形式，如果“输出参数”栏为“否”，则表示该参数为输入参数，用户需要设置输入参数的值，在“值”一栏中输入即可，如图7.2所示。单击“确定”按钮，SSMS的结果显示窗口将列出存储过程运行的结果。 "},"page/11070.html":{"url":"page/11070.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11025.html":{"url":"page/11025.html","title":"触发器","keywords":"","body":"触发器 "},"page/11071.html":{"url":"page/11071.html","title":"MSSQL","keywords":"","body":"SQL Server 1．创建DML触发器 语法格式： CREATE TRIGGER [ schema_name . ]trigger_name ON { table | view } /*指定操作对象*/ [ WITH ENCRYPTION ] /*说明是否采用加密方式*/ { FOR |AFTER | INSTEAD OF } { [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] } [ WITH APPEND ] [ NOT FOR REPLICATION ] /*说明该触发器不用于复制*/ AS { sql_statement [ ; ] [ ...n ] | EXTERNAL NAME asse MBly_name.class_name.method_name } 【例7.10】 创建一个表table1，其中只有一列a。在表上创建一个触发器，每次插入操作时，将变量@str的值设为“TRIGGER IS WORKING”并显示。 USE PXSCJ GO CREATE TABLE table1(a int) GO CREATE TRIGGER table1_insert ON table1 AFTER INSERT AS /*真正执行*/ BEGIN /*由多条语句构成用begin end*/ DECLARE @str char(50) SET @str='TRIGGER IS WORKING' PRINT @str END 向table1中插入一行数据： INSERT INTO table1 VALUES(10) 执行结果如下： 【例7.11】 创建触发器，当向CJB表中插入一个学生的成绩时，将XSB表中该学生的总学分加上添加的课程的学分。 CREATE TRIGGER cjb_insert ON CJB AFTER INSERT AS BEGIN DECLARE @num char(6), @kc_num char(3) DECLARE @xf int SELECT @num=学号, @kc_num=课程号 from inserted /*已写入语句保存在哪*/ SELECT @xf=学分 FROM KCB WHERE 课程号=@kc_num UPDATE XSB SET 总学分=总学分+@xf WHERE 学号=@num PRINT '修改成功' END （4）创建UPDATE触发器。UPDATE触发器在对触发器表执行UPDATE语句后触发。在执行UPDATE触发器时，将触发器表的原记录保存到deleted临时表中，将修改后的记录保存到inserted临时表中。 【例7.12】 创建触发器，当修改XSB表中的学号时，同时也要将CJB表中的学号修改成相应的学号（假设XSB表和CJB表之间没有定义外键约束）。 CREATE TRIGGER xsb_update ON XSB AFTER UPDATE AS BEGIN DECLARE @old_num char(6), @new_num char(6) SELECT @old_num=学号 FROM deleted /*更新的本质，删除以前的，出入新的*/ SELECT @new_num=学号 FROM inserted UPDATE CJB SET 学号=@new_num WHERE 学号=@old_num END 接着修改XSB表中的一行数据，并查看触发器执行结果： UPDATE XSB SET 学号='081120' WHERE 学号='081101' GO SELECT * FROM CJB WHERE 学号='081120' 执行结果如下： （5）创建DELETE触发器。 【例7.13】 在删除XSB表中的一条学生记录时将CJB表中该学生的相应记录也删除。 CREATE TRIGGER xsb_delete ON XSB AFTER DELETE AS BEGIN DELETE FROM CJB WHERE 学号 IN(SELECT 学号 FROM deleted) END 【例7.14】 在KCB表中创建UPDATE和DELETE触发器，当修改或删除KCB表中的“课程号”字段时，同时修改或删除CJB表中的该课程号。 CREATE TRIGGER kcb_trig ON KCB AFTER UPDATE, DELETE AS BEGIN IF (UPDATE(课程号)) UPDATE CJB SET 课程号=(SELECT 课程号 FROM inserted) WHERE 课程号=(SELECT 课程号 FROM deleted) ELSE DELETE FROM CJB WHERE 课程号 IN(SELECT 课程号 FROM deleted) END （6）创建INSTEAD OF触发器。AFTER触发器是在触发语句执行后触发的，与AFTER触发器不同的是，INSTEAD OF触发器触发时只执行触发器内部的SQL语句，而不执行激活该触发器的SQL语句。一个表或视图中只能有一个INSTEAD OF触发器。 【例7.15】 创建表table2，值包含一列a，在表中创建INSTEAD OF INSERT触发器，当向表中插入记录时显示相应消息。 USE PXSCJ GO CREATE TABLE table2(a int) GO CREATE TRIGGER table2_insert ON table2 INSTEAD OF INSERT AS PRINT 'INSTEAD OF TRIGGER IS WORKING' 向表中插入一行数据： INSERT INTO table2 VALUES(10) 执行结果如下： 【例7.16】 在PXSCJ数据库中创建视图stu_view，包含学生学号、专业、课程号、成绩。该视图依赖于表XSB和CJB，是不可更新视图。可以在视图上创建INSTEAD OF触发器，当向视图中插入数据时分别向表XSB和CJB插入数据，从而实现向视图插入数据的功能。 首先创建视图： CREATE VIEW stu_view AS SELECT XSB.学号, 专业, 课程号, 成绩  FROM XSB, CJB  WHERE XSB.学号=CJB.学号 创建INSTEAD OF触发器： CREATE TRIGGER InsteadTrig ON stu_view INSTEAD OF INSERT /*替代视图原有insert操作*/ AS BEGIN DECLARE @XH char(6), @XM char(8), @ZY char(12), @KCH char(3), @CJ int SET @XM='佚名' SELECT @XH=学号, @ZY=专业, @KCH=课程号, @CJ=成绩 FROM inserted INSERT INTO XSB(学号, 姓名, 专业) VALUES(@XH, @XM, @ZY) INSERT INTO CJB VALUES(@XH, @KCH, @CJ) END 向视图插入一行数据： INSERT INTO stu_view VALUES('091102', '计算机', '101', 85 ) 查看数据是否插入： SELECT * FROM stu_view WHERE 学号= '091102' 执行结果如下： 查看与视图关联的XSB表的情况： SELECT * FROM XSB WHERE 学号= '091102' 执行结果如下： 2．创建DDL触发器 语法格式： CREATE TRIGGER trigger_name ON { ALL SERVER | DATABASE } [ WITH ENCRYPTION ] { FOR | AFTER } { event_type | event_group } [ ,...n ] AS { sql_statement [ ; ] [ ...n ] | EXTERNAL NAME asse MBly_name.class_name.method_name } 【例7.17】 创建PXSCJ数据库作用域的DDL触发器，当删除一个表时，提示禁止该操作，然后回滚删除表的操作。 USE PXSCJ GO CREATE TRIGGER safety ON DATABASE AFTER DROP_TABLE AS PRINT '不能删除该表' ROLLBACK TRANSACTION 尝试删除表table1： DROP TABLE table1 执行结果如下： 【例7.18】 创建服务器作用域的DDL触发器，当删除一个数据库时，提示禁止该操作并回滚删除数据库的操作。 CREATE TRIGGER safety_server ON ALL SERVER AFTER DROP_DATABASE AS PRINT '不能删除该数据库' ROLLBACK TRANSACTION DDL注意作用域，DML一定针对表 （1）通过界面方式只能创建DML触发器。 以在表XSB上创建触发器为例，利用对象资源管理器创建DML触发器步骤如下：启动SQL Server Management Studio，在对象资源管理器中展开“数据库→PXSCJ→表→dbo.XSB”，选择其中的“触发器”目录，在该目录下可以看到之前已经创建的XSB表的触发器。右击“触发器”，在弹出的快捷菜单中选择“新建触发器”菜单项。在打开的“触发器脚本编辑”窗口输入相应的创建触发器的命令。输入完成后，单击“执行”按钮，若执行成功，则触发器创建完成。 （2）查看DDL触发器。DDL触发器不可以使用界面方式创建，DDL触发器分为数据库触发器和服务器触发器，展开“数据库→PXSCJ→可编程性→数据库触发器”，就可以查看到有哪些数据库触发器。展开“数据库→服务器对象→触发器”，就可以查看到有哪些服务器触发器。 "},"page/11072.html":{"url":"page/11072.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11040.html":{"url":"page/11040.html","title":"游标","keywords":"","body":"其他查询 "},"page/11275.html":{"url":"page/11275.html","title":"MSSQL","keywords":"","body":"MSSQL 声明游标 1．SQL-92语法 语句格式： DECLARE cursor_name [ INSENSITIVE ] [ SCROLL ] CURSOR FOR select_statement [ FOR { READ ONLY | UPDATE [ OF column_name [ ,...n ] ] } ] [;] 说明如下。 cursor_name：游标名，它是与某个查询结果集相联系的符号名，要符合SQL Server标识符命名规则。 INSENSITIVE：指定系统将创建供所定义的游标使用的数据的临时复本 ，对游标的所有请求都从tempdb中的该临时表中得到应答。 SCROLL：说明所声明的游标可以前滚、后滚，可使用所有的提取选项（FIRST、LAST、PRIOR、NEXT、RELATIVE、ABSOLUTE）。 select_statement：SELECT语句，由该查询产生与所声明的游标相关联的结果集。该SELECT语句中不能出现COMPUTE、COMPUTE BY、INTO或FOR BROWSE关键字。 READ ONLY：说明所声明的游标为只读的。UPDATE指定游标中可以更新的列，若有参数OF column_name [ ,…n ]，则只能修改给出的这些列。 以下是一个符合SQL-92标准的游标声明： DECLARE XS_CUR1 CURSOR FOR SELECT 学号,姓名,性别,出生时间,总学分 FROM XSB WHERE 专业= '计算机' FOR READ ONLY 2．T-SQL扩展 语法格式： DECLARE cursor_name CURSOR [ LOCAL | GLOBAL ] /*游标作用域*/ [ FORWORD_ONLY | SCROLL ] /*游标移动方向*/ [ STATIC | KEYSET | DYNAMIC | FAST_FORWARD ] /*游标类型*/ [ READ_ONLY | SCROLL_LOCKS | OPTIMISTIC ] /*访问属性*/ [ TYPE_WARNING ] /*类型转换警告信息*/ FOR select_statement /*SELECT查询语句*/ [ FOR UPDATE [ OF column_name [ ,…n ] ] ] /*可修改的列*/ [;] 以下是一个T-SQL扩展游标声明： DECLARE XS_CUR2 CURSOR DYNAMIC FOR SELECT 学号,姓名,总学分 FROM XSB WHERE 专业= '计算机' FOR UPDATE OF 总学分 打开游标 声明游标后，要使用游标从中提取数据，就必须先打开游标。在T-SQL中，使用OPEN语句打开游标，其格式为 OPEN { { [ GLOBAL ] cursor_name } | cursor_variable_name } 其中，cursor_name是要打开的游标名，cursor_variable_name是游标变量名，该名称引用一个游标。GLOBAL说明打开的是全局游标，否则打开局部游标。 OPEN语句打开游标，然后通过执行在DECLARE CURSOR（或 SET cursor_variable）语句中指定的T-SQL语句来填充游标（即生成与游标相关联的结果集）。 例如，语句 OPEN XS_CUR1 打开游标XS_CUR1。该游标被打开后，就可以提取其中的数据。 打开游标后，可以使用全局变量@@CURSOR_ROWS查看游标中数据行的数目。全局变量@@CURSOR_ROWS中保存着最后打开的游标中的数据行数。当其值为0时，表示没有游标打开；当其值为-1时，表示游标为动态的；当其值为-m（m为正整数）时，游标采用异步方式填充，m为当前键集中已填充的行数；当其值为m（m为正整数）时，游标已被完全填充，m是游标中的数据行数。 【例4.86】 定义游标XS_CUR3，然后打开该游标，输出其行数。 DECLARE XS_CUR3 CURSOR LOCAL SCROLL SCROLL_LOCKS FOR SELECT 学号, 姓名, 总学分 FROM XSB FOR UPDATE OF 总学分 OPEN XS_CUR3 SELECT '游标XS_CUR3数据行数' = @@CURSOR_ROWS 读取数据 游标打开后，就可以使用FETCH语句从中读取数据了。 语法格式： FETCH [ [ NEXT | PRIOR | FIRST | LAST | ABSOLUTE { n | @nvar } | RELATIVE { n | @nvar} ] FROM ] { { [ GLOBAL ] cursor_name } | @cursor_variable_name } [ INTO @variable_name [ ,…n ] ] 【例4.87】 从游标XS_CUR1中提取数据。设该游标已经声明并打开。 FETCH NEXT FROM XS_CUR1 执行结果如下： 【例4.88】 从游标XS_CUR2中提取数据。设该游标已经声明。 OPEN XS_CUR2 FETCH FIRST FROM XS_CUR2 读取游标第一行（当前行为第一行），结果如下： FETCH NEXT FROM XS_CUR2 读取下一行（当前行为第二行），结果如下： FETCH PRIOR FROM XS_CUR2 读取上一行（当前行为第一行），结果如下： FETCH LAST FROM XS_CUR2 读取最后一行（当前行为最后一行），结果如下： FETCH RELATIVE -2 FROM XS_CUR2 读取当前行的上两行（当前行为倒数第三行），结果如下： FETCH语句的执行状态保存在全局变量@@FETCH_STATUS中，其值为0表示上一个FETCH执行成功；为-1表示所要读取的行不在结果集中；为-2表示被提取的行已不存在（已被删除）。 例如，接着上例继续执行如下语句： FETCH RELATIVE 3 FROM XS_CUR2 SELECT 'FETCH执行情况' = @@FETCH_STATUS 执行结果如下： 关闭游标 游标使用完以后要及时关闭。关闭游标使用CLOSE语句，格式为 CLOSE { { [ GLOBAL ] cursor_name } | @cursor_variable_name } 语句参数的含义与OPEN语句中的相同。例如， CLOSE XS_CUR2 将关闭游标XS_CUR2。 删除游标 游标关闭后，其定义仍在，需要时可用OPEN语句打开它再使用。若确认游标不再需要，就要释放其定义占用的系统空间，即删除游标。删除游标使用DEALLOCATE语句，格式为 DEALLOCATE { { [ GLOBAL ] cursor_name } | @cursor_variable_name } 语句参数的含义与OPEN和CLOSE语句中的相同。 例如， DEALLOCATE XS_CUR2 将删除游标XS_CUR2。 "},"page/11170.html":{"url":"page/11170.html","title":"删除","keywords":"","body":"删除 "},"page/11250.html":{"url":"page/11250.html","title":"数据库","keywords":"","body":"数据库 "},"page/11171.html":{"url":"page/11171.html","title":"MSSQL","keywords":"","body":"数据库 命令 删除数据库使用DROP DATABASE命令。 语法格式： DROP DATABASE database_name[,…n][;] 其中，database_name是要删除的数据库名。 例如，要删除数据库TEST2，使用命令： DROP DATABASE TEST2 GO 界面 1.选择对应表-->右击-->删除 通常的做法是，把一些不需要的数据库删除，以释放被其占用的系统空间和消耗。用户可以利用图形向导方式轻松地完成数据库系统的删除工作。 【例2.4】 删除PXSCJ数据库。 启动SQL Server Management Studio，在对象资源管理器中选择要删除的数据库“PXSCJ”，右击鼠标，在弹出的快捷菜单中选择“删除”菜单项，打开如图2.11所示的“删除对象”对话框，单击右下角的“确定”按钮，即可删除数据库PXSCJ。 “删除对象”对话框 "},"page/11172.html":{"url":"page/11172.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11173.html":{"url":"page/11173.html","title":"表","keywords":"","body":"表 "},"page/11174.html":{"url":"page/11174.html","title":"MSSQL","keywords":"","body":"命令 语法格式： DROP TABLE [ database_name . [ schema_name ] . | schema_name . ] table_name [ ,...n ] [ ; ] 其中，table_name是要被删除的表名。 例如，要删除表XSB，使用的T-SQL语句为： USE PXSCJ GO DROP TABLE XSB 例如，要删除表XSB，使用的T-SQL语句为： USE PXSCJ GO DROP TABLE XSB SQL Server 删除表 选中表-->右击删除-->确定 删除一个表时，表的定义、表中的所有数据以及表的索引、触发器、约束等均被删除。注意，不能删除系统表和外键约束所参照的表 。 "},"page/11175.html":{"url":"page/11175.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11176.html":{"url":"page/11176.html","title":"索引","keywords":"","body":"索引 "},"page/11177.html":{"url":"page/11177.html","title":"MSSQL","keywords":"","body":"SQL Server 索引的删除 通过SQL命令删除索引 从当前数据库中删除一个或多个索引。 语法格式： DROP INDEX { index_name ON table_or_view_name [ ,...n ] | table_or_view_name.index_name [ ,...n ] } DROP INDEX语句可以一次删除一个或多个索引。这个语句不适合删除通过定义PRIMARY KEY或UNIQUE约束创建的索引。若要删除PRIMARY KEY或UNIQUE约束创建的索引，必须通过删除约束实现。 另外，在系统表的索引上不能进行DROP INDEX操作。 【例6.7】 删除PXSCJ数据库中表KCB的一个索引名为kc_name_ind的索引。 IF EXISTS (SELECT name FROM sysindexes WHERE name = 'kc_name_ind') DROP INDEX KCB.kc_name_ind 通过图形界面方式删除索引 通过图形界面方式删除索引的主要步骤如下： 启动SQL Server Management Studio，在对象资源管理器中展开数据库“PXSCJ→表→dbo.XSB→索引”，选择其中要删除的索引，单击鼠标右键，在弹出的快捷菜单上选择“删除”菜单项。在打开的“删除对象”窗口中单击“确定”按钮即可。 "},"page/11178.html":{"url":"page/11178.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11179.html":{"url":"page/11179.html","title":"视图","keywords":"","body":"视图 "},"page/11180.html":{"url":"page/11180.html","title":"MSSQL","keywords":"","body":"SQL Server 删除视图 1．通过对象资源管理器删除视图 在对象资源管理器中删除视图的操作方法是： 在“视图”目录下选择需要删除的视图，右击鼠标，在弹出的快捷菜单上选择“删除”菜单项，出现“删除”对话框，单击“确定”按钮，即删除了指定的视图。 2．T-SQL命令方式删除视图 语法格式： DROP VIEW [ schema_name . ] view_name [ ...,n ] [ ; ] 其中，view_name是视图名，使用DROP VIEW可删除一个或多个视图。 例如， DROP VIEW CS_XS, CS_KC 将删除视图CS_XS和CS_KC。 "},"page/11181.html":{"url":"page/11181.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11182.html":{"url":"page/11182.html","title":"存储过程","keywords":"","body":"存储过程 "},"page/11183.html":{"url":"page/11183.html","title":"MSSQL","keywords":"","body":"SQL Server 当不再使用一个存储过程时，就要把它从数据库中删除。使用DROP PROCEDURE语句可永久地删除存储过程。在此之前，必须确认该存储过程没有任何依赖关系。语法格式： DROP { PROC | PROCEDURE } { [ schema_name. ] procedure } [ ,...n ] 【例7.9】 删除PXSCJ数据库中的student_info存储过程。 USE PXSCJ GO IF EXISTS(SELECT name FROM sysobjects WHERE name='student_info') DROP PROCEDURE student_info 删除存储过程。选择要删除的存储过程，右击鼠标，在弹出的快捷菜单中选择“删除”菜单项，根据提示删除该存储过程。 "},"page/11184.html":{"url":"page/11184.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11185.html":{"url":"page/11185.html","title":"触发器","keywords":"","body":"触发器 "},"page/11186.html":{"url":"page/11186.html","title":"MSSQL","keywords":"","body":"SQL Server 触发器本身是存在于表中的，因此，当表被删除时，表中的触发器也将一起被删除。删除触发器使用DROP TRIGGER语句。 语法格式： DROP TRIGGER schema_name.trigger_name [ ,...n ] [ ; ]/*删除DML触发器*/ DROP TRIGGER trigger_name [ ,...n ] ON { DATABASE | ALL SERVER }[ ; ] /*删除DDL触发器*/ 【例7.20】 删除DML触发器xsb_delete。 IF EXISTS (SELECT name FROM sysobjects WHERE name = 'xsb_delete') DROP TRIGGER xsb_delete 【例7.21】 删除DDL触发器safety。 DROP TRIGGER safety ON DATABASE （1）删除DML触发器。以XSB表的DML触发器为例，在对象资源管理器中展开“数据库→PXSCJ→表→dbo.XSB→触发器”，选择要删除的触发器名称，右击鼠标，在弹出的快捷菜单中选择“删除”菜单项，在弹出的“删除对象”窗口中单击“确定”按钮，即可完成触发器的删除操作。 （2）删除DDL触发器。删除DDL触发器与删除DML触发器的方法类似，首先找到要删除的触发器，右击鼠标，选择“删除”选项即可。 "},"page/11187.html":{"url":"page/11187.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11151.html":{"url":"page/11151.html","title":"修改","keywords":"","body":"修改 "},"page/11152.html":{"url":"page/11152.html","title":"数据库","keywords":"","body":"数据库 "},"page/11153.html":{"url":"page/11153.html","title":"MSSQL","keywords":"","body":"命令 使用ALTER DATABASE命令可对数据库进行以下修改： 增加或删除数据文件； 改变数据文件的大小和增长方式； 改变日志文件的大小和增长方式； 增加或删除日志文件； 增加或删除文件组。 语法格式 ALTER DATABASE database_name { ADD FILE [,…n][ TO FILEGROUP filegroup_name ] /*在文件组中增加数据文件*/ | ADD LOG FILE [,…n] /*增加日志文件*/ | REMOVE FILE logical_file_name /*删除数据文件*/ | ADD FILEGROUP filegroup_name [CONTAINS FILESTREAM] /*增加文件组*/ | REMOVE FILEGROUP filegroup_name /*删除文件组*/ | MODIFY FILE /*更改文件属性*/ | MODIFY NAME = new_dbname /*数据库更名*/ | MODIFY FILEGROUP filegroup_name { | DEFAULT | NAME = new_filegroup_name } /*更改文件组属性*/ | SET [ ,...n ] [ WITH ] /*设置数据库属性*/ | COLLATE collation_name /*指定数据库排序规则*/ } [;] 其中， ::= { { READONLY | READWRITE } | { READ_ONLY | READ_WRITE } } 【例2.8】 假设已经创建了例2.5中的数据库TEST1，它只有一个主数据文件，其逻辑文件名为TEST1_DATA，大小为5 MB，最大为50 MB，增长方式为按10%增长。 要求：修改数据库TEST1现有数据文件TEST1_DATA的属性，将主数据文件的最大大小改为100 MB，增长方式改为按每次5 MB增长。 在“查询分析器”窗口中输入如下Transact-SQL语句： ALTER DATABASE TEST1 MODIFY FILE ( NAME = TEST1_DATA, MAXSIZE =100 MB, /*将主数据文件的最大大小改为100 MB*/ FILEGROWTH = 5 MB /*将主数据文件的增长方式改为按5 MB增长*/ ) GO 单击“执行”按钮执行输入的T_SQL语句，右击“对象资源管理器”中的“数据库”，选择“刷新”菜单项，之后右击数据库TEST1的图标，选择“属性”菜单项，在“文件”页上查看修改后的数据文件。 【例2.9】 先为数据库TEST1增加数据文件TEST1BAK。然后删除该数据文件。 ALTER DATABASE TEST1 ADD FILE ( NAME = 'TEST1BAK', FILENAME = 'D:\\data\\TEST1BAK.ndf', SIZE = 10 MB, MAXSIZE = 50 MB, FILEGROWTH = 5% ) 通过查看“数据库属性”窗口中的文件属性来观察数据库“TEST1”是否增加数据文件TEST1BAK。 删除数据文件TEST1BAK的命令如下： ALTER DATABASE TEST1 REMOVE FILE TEST1BAK GO 【例2.10】 为数据库TEST1添加文件组FGROUP，并为此文件组添加两个大小均为10 MB的数据文件。 ALTER DATABASE TEST1 ADD FILEGROUP FGROUP GO ALTER DATABASE TEST1 ADD FILE ( NAME = 'TEST1_DATA2', FILENAME = 'D:\\data\\TEST1_Data2.ndf', SIZE = 10 MB ), ( NAME = 'TEST1_DATA3', FILENAME = 'D:\\data\\TEST1_Data3.ndf', SIZE = 10 MB ) TO FILEGROUP FGROUP GO 【例2.11】 从数据库中删除文件组，将例2.10中添加到TEST1数据库中的文件组FGROUP删除。注意：被删除的文件组中的数据文件必须先删除，且不能删除主文件组。 在查询分析器中输入如下Transact-SQL语句并执行： ALTER DATABASE TEST1 REMOVE FILE TEST1_DATA2 GO ALTER DATABASE TEST1 REMOVE FILE TEST1_DATA3 GO ALTER DATABASE TEST1 REMOVE FILEGROUP FGROUP GO 【例2.12】 为数据库TEST1添加一个日志文件。 在查询分析器中输入如下Transact-SQL语句并执行： ALTER DATABASE TEST1 ADD LOG FILE ( NAME = 'TEST1_LOG2', FILENAME = 'D:\\data\\TEST1_Log2.ldf', SIZE = 5 MB, MAXSIZE =10 MB, FILEGROWTH = 1 MB ) GO 【例2.13】 从数据库TEST1中删除一个日志文件，将日志文件TEST1_LOG2删除。注意，不能删除主日志文件。 将数据库TEST1的名称改为JUST_TEST。进行此操作时必须保证该数据库此时没有被其他任何用户使用。 在查询分析器中输入如下Transact-SQL语句并执行： ALTER DATABASE TEST1 REMOVE FILE TEST1_LOG2 GO ALTER DATABASE TEST1 MODIFY NAME = JUST_TEST GO SQL Server界面 简介 1.选择对应数据库-->右击-->选择属性 2.更改对应属性即可 详细 1. 数据库的修改 在数据库成功创建后，数据文件名和日志文件名就不能改变了。对已存在的数据库可以进行的修改包括以下几项。 增加或删除数据文件。 改变数据文件的大小和增长方式。 改变日志文件的大小和增长方式。 增加或删除日志文件。 增加或删除文件组。 重命名数据库。 下面以对数据库PXSCJ的修改为例，说明在SQL Server Management Studio中对数据库的定义进行修改的操作方法。 在进行任何界面操作以前，都要启动SQL Server Management Studio，后面启动SQL Server Management Studio的步骤将被省略，只介绍其主要的操作步骤。 第1步：选择需要进行修改的数据库PXSCJ，右击鼠标，在出现的快捷菜单中选择“属性”菜单项，如图所示。 选择“属性”菜单项 第2步：选择“属性”菜单项后，出现如图2.6所示的“数据库属性-PXSCJ”窗口。从图中的选项卡列表中可以看出，它包括9个选项卡。 图2.6 “数据库属性-PXSCJ”窗口 下面详细介绍一下对已经存在的数据库可以进行的修改操作。 （1）改变数据文件的大小和增长方式。在图2.6所示的“数据库属性-PXSCJ”窗口中的选项卡列表中选择“文件”，在右边的“初始大小”列中输入要修改的数据库的初始大小，如图所示。 修改数据库的大小 （2）增加或删除数据文件。当原有数据库的存储空间不够大时，除了可以采用扩大原有数据文件存储量的方法之外，还可以增加新的数据文件。或者，从系统管理的需求出发，采用多个数据文件来存储数据，以避免数据文件过大。此时，会用到向数据库中增加数据文件的操作。 【例2.2】 在PXSCJ数据库中增加数据文件PXSCJ_2，其属性均取系统默认值。 操作方法如下： 打开“数据库属性-PXSCJ”窗口，在选项卡列表中选择“文件”，单击窗口右下角的“添加”按钮，数据库文件下方会新增加一行文件项，如图所示。 图2.8 增加数据文件 删除辅助数据文件的操作方法如下。 打开“数据库属性”窗口，选择“文件”选项卡。选中需删除的辅助数据文件PXSCJ_2，单击对话框右下角的“删除”按钮，然后单击“确定”按钮即完成删除。 （3）增加或删除文件组。数据库管理员（DBA）从系统管理策略角度出发，有时可能需要增加或删除文件组。这里通过示例说明操作方法。 【例2.3】 假设要在数据库PXSCJ中增加一个名为FGroup的文件组。 操作方法如下。 打开“数据库属性”窗口，选择“文件组”选项卡。单击右下角的“添加”按钮，这时在PRIMARY行的下面会出现新的一行。在该行的“名称”列输入“FGroup”，单击“确定”按钮，如图2.9所示。 输入新增的文件组名 例如，在PXSCJ数据库新增的文件组FGroup中增加数据文件PXSCJ2。操作方法如下。 选择“文件”选项卡，按增加数据文件的操作方法添加数据文件。在“文件组”下拉框中选择“FGroup”，如图所示，单击“确定”按钮。 将数据文件加入新增的文件组中 删除文件组的操作方法如下。 选择“文件组”选项卡。选中需删除的文件组，单击对话框右下角的“删除”按钮，再单击“确定”按钮即可删除。 （4）数据库的重命名。使用图形界面修改数据库名称的方法是：启动“SQL Server Management Studio”，在“对象资源管理器”窗口中，展开“数据库”，选择要重命名的数据库，右击鼠标，在弹出的快捷菜单中选择“重命名”菜单项，输入新的数据库名称，即可更改数据库的名称。在一般情况下，不建议用户更改已经创建好的数据库名称，因为许多应用程序可能已经使用了该名称，在更改了数据库名称之后，还需要修改相应的应用程序。 "},"page/11154.html":{"url":"page/11154.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11155.html":{"url":"page/11155.html","title":"表","keywords":"","body":"表 "},"page/11156.html":{"url":"page/11156.html","title":"MSSQL","keywords":"","body":"命令 修改表结构可以使用ALTER TABLE语句。语法格式。 【例3.11】 设已经在数据库PXSCJ中创建了表XSB，先在表XSB中增加1个新列“奖学金等级”，然后在表XSB中删除名为“奖学金等级”的列。 在SSMS中新建一个查询，并输入如下脚本： USE PXSCJ GO ALTER TABLE XSB ADD 奖学金等级 tinyint NULL GO 输入完成后执行该脚本，然后可以在对象资源管理器中展开“PXSCJ”中的表dbo.XSB的结构，查看运行结果。 下面的脚本用于在表XSB中删除名为奖学金等级的列： USE PXSCJ GO ALTER TABLE XSB DROP COLUMN 奖学金等级 GO 使用ALTER TABLE语句一次还可以添加多个列，中间用逗号隔开。例如，向XSB表中添加奖学金等级1、奖学金等级2两个新列： USE PXSCJ GO ALTER TABLE XSB ADD 奖学金等级1 tinyint NULL, 奖学金等级2 tinyint NULL GO 【例3.12】 修改表XSB中已有列的属性：将名为“姓名”的列长度由原来的8改为10；将名为“出生时间”的列的数据类型由原来的date改为datetime。 新建一个查询，在查询分析器中输入并执行如下脚本： USE PXSCJ GO ALTER TABLE XSB ALTER COLUMN 姓名 char(10) GO ALTER TABLE XSB ALTER COLUMN 出生时间 smalldatetime SQL Server 修改表 设置权限 1.工具-->选项 2.设计器-->取消勾选【阻止保存要求重新创建表的更改】-->确定 修改表名 1.选中表-->重命名 2.输入修改后名字即可 修改列 1.选中表-->右击设计 修改列属性 1.选中列-->修改列属性 表中尚未有记录值时，可以修改表结构，如更改列名、列的数据类型、长度和是否允许空值等属性；但当表中有了记录后，建议不要轻易改变表结构，特别不要改变数据类型，以免产生错误。 （1）具有以下特性的列不能修改： 数据类型为timestamp的列； 计算列； 全局标识符列； 用于索引的列（但当用于索引的列为varchar、nvarchar或varbinary数据类型时，可以增加列的长度）； 用于由CREATE STATISTICS生成统计的列，如需修改这样的列，则必须先用DROP STATISTICS语句删除统计； 用于主键或外键约束的列； 用于CHECK或UNIQUE约束的列； 关联有默认值的列。 （2）当改变列的数据类型时，要求满足下列条件： 原数据类型必须能够转换为新数据类型。 新数据类型不能为timestamp类型。 如果被修改列属性中有“标识规范”属性，则新数据类型必须是有效的“标识规范”数据类型。 插入列 1.点击想要更改列的位置-->右击插入列 2.输入列名和属性 删除列 1.点击想要删除列-->右击删除 保存表 "},"page/11157.html":{"url":"page/11157.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11158.html":{"url":"page/11158.html","title":"索引","keywords":"","body":"索引 "},"page/11159.html":{"url":"page/11159.html","title":"MSSQL","keywords":"","body":"SQL Server 重建索引 索引使用一段时间后，可能需要重新创建，这时可以使用ALTER INDEX语句来重新生成原来的索引。 语法格式： ALTER INDEX { index_name | ALL } ON [ database_name. [ schema_name ] . | schema_name. ]table_or_view_name { REBUILD [ [ WITH ( [ ,...n ] ) ] | [ PARTITION = partition_number [ WITH ( [ ,...n ] ) ] ] ] | DISABLE | REORGANIZE [ PARTITION = partition_number ] [ WITH ( LOB_COMPACTION = { ON | OFF } ) ] | SET ( [ ,...n ] ) } [ ; ] 其中，、、中的选项含义与CREATE INDEX中的选项相同。 例如，重建KCB表上的所有索引： USE PXSCJ GO ALTER INDEX ALL ON KCB REBUILD 重建KCB表上的kc_name_id索引： ALTER INDEX kc_name_ind ON KCB REBUILD "},"page/11160.html":{"url":"page/11160.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11161.html":{"url":"page/11161.html","title":"视图","keywords":"","body":"视图 "},"page/11162.html":{"url":"page/11162.html","title":"MSSQL","keywords":"","body":"修改视图的定义 1．通过SQL Server Enterprise Manager修改视图 在对象资源管理器中右击视图“dbo.CS_XS”，在弹出的快捷菜单中选择“设计”菜单项，进入视图修改窗口。该窗口与创建视图的窗口类似，其中可以查看并可修改视图结构，修改完后单击“保存图标”按钮即可。 2．使用ALTER VIEW语句修改视图 语法格式： ALTER VIEW [ schema_name . ] view_name [ ( column [ ,...n ] ) ] [ WITH [ ,...n ] ] AS select_statement [ ; ] [ WITH CHECK OPTION ] 其中，view_attribute、select_statement等参数与CREATE VIEW语句中的含义相同。 【例4.84】 将CS_XS视图修改为只包含计算机专业学生的学号、姓名和总学分。 USE PXSCJ GO ALTER VIEW CS_XS AS SELECT 学号, 姓名, 总学分 FROM XSB WHERE 专业= '计算机' 使用ENCRYPTION属性定义的视图可以使用ALTER VIEW语句修改。 【例4.85】 视图CS_KC是加密存储视图，修改其定义，包括学号、姓名、选修的课程号、课程名和成绩。 ALTER VIEW CS_KC WITH ENCRYPTION AS SELECT XSB.学号,XSB.姓名,CJB.课程号,KCB.课程名,成绩 FROM XSB, CJB, KCB WHERE XSB.学号 = CJB.学号 AND CJB.课程号 = KCB.课程号 AND 专业= '计算机' WITH CHECK OPTION "},"page/11163.html":{"url":"page/11163.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11164.html":{"url":"page/11164.html","title":"存储过程","keywords":"","body":"存储过程 "},"page/11165.html":{"url":"page/11165.html","title":"MSSQL","keywords":"","body":"SQL Server 使用ALTER PROCEDURE命令可修改已存在的存储过程并保留以前赋予的许可。 语法格式： ALTER { PROC | PROCEDURE } [schema_name.] procedure_name [ ; number] [ { @parameter [ type_schema_name. ] data_type } [ VARYING ] [ = default ] [ OUT[PUT] ] ][ ,...n ] [ WITH ] [ ,...n ] [ FOR REPLICATION ] AS { [;][ ...n ] | EXTERNAL NAME asse MBly_name.class_name.method_name } [;] 【例7.7】 对例7.2中创建的存储过程student_info1进行修改，将第一个参数改成学生的学号。 USE PXSCJ GO ALTER PROCEDURE student_info1 @number char(6),@cname char(16) AS SELECT 学号, 课程名, 成绩 FROM CJB, KCB WHERE CJB.学号=@number AND KCB.课程名=@cname GO 【例7.8】 创建名为select_students的存储过程，在默认情况下，该存储过程可查询所有学生信息，随后授予权限。当该存储过程需更改为能检索计算机专业的学生信息时，用ALTER PROCEDURE重新定义该存储过程。 创建select_students存储过程。 CREATE PROCEDURE select_students /*创建存储过程*/ AS SELECT * FROM XSB ORDER BY 学号 GO 修改存储过程select_students。 ALTER PROCEDURE select_students WITH ENCRYPTION AS SELECT * FROM XSB WHERE 专业= '计算机' ORDER BY 学号 GO 修改存储过程。在“存储过程”目录下选择要修改的存储过程，右击鼠标，在弹出的快捷菜单中选择“修改”菜单项，打开“存储过程脚本编辑”窗口，在该窗口中修改相关的T-SQL语句。修改完成后，执行修改后的脚本，若执行成功，则修改了存储过程。 "},"page/11166.html":{"url":"page/11166.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11167.html":{"url":"page/11167.html","title":"触发器","keywords":"","body":"触发器 "},"page/11168.html":{"url":"page/11168.html","title":"MSSQL","keywords":"","body":"SQL Server 触发器的修改 （1）修改DML触发器的语法格式： ALTER TRIGGER schema_name.trigger_name ON ( table | view ) [ WITH ENCRYPTION ] ( FOR | AFTER | INSTEAD OF ) { [ DELETE ] [ , ] [ INSERT ] [ , ] [ UPDATE ] } [ NOT FOR REPLICATION ] AS { sql_statement [ ; ] [ ...n ] | EXTERNAL NAME asse MBly_name.class_name.method_name } （2）修改DDL触发器的语法格式： ALTER TRIGGER trigger_name ON { DATABASE | ALL SERVER } [ WITH ENCRYPTION ] { FOR | AFTER } { event_type [ ,...n ] | event_group } AS { sql_statement [ ; ] | EXTERNAL NAME asse MBly_name.class_name.method_name[ ; ] } 【例7.19】 修改PXSCJ数据库中在XSB表上定义的触发器xsb_delete，将其修改为UPDATE触发器。 USE PXSCJ GO ALTER TRIGGER xsb_delete ON XSB FOR UPDATE AS PRINT '执行的操作是修改' DML触发器能够使用界面方式修改，DDL触发器则不可以。进入对象资源管理器，修改触发器的步骤与创建的步骤相同，在对象资源管理器中选择要修改的触发器，右击鼠标，在弹出的快捷菜单中选择“修改”菜单项，打开“触发器脚本编辑”窗口，在该窗口中可以进行触发器的修改，修改后单击“执行”按钮重新执行即可；但是被设置成“WITH ENCRYPTION”的触发器是不能被修改的。 "},"page/11169.html":{"url":"page/11169.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11319.html":{"url":"page/11319.html","title":"查询","keywords":"","body":"查询 "},"page/11320.html":{"url":"page/11320.html","title":"数据库","keywords":"","body":"数据库 "},"page/11321.html":{"url":"page/11321.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11322.html":{"url":"page/11322.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11323.html":{"url":"page/11323.html","title":"表","keywords":"","body":"表 "},"page/11324.html":{"url":"page/11324.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11325.html":{"url":"page/11325.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11326.html":{"url":"page/11326.html","title":"索引","keywords":"","body":"索引 "},"page/11327.html":{"url":"page/11327.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11328.html":{"url":"page/11328.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11329.html":{"url":"page/11329.html","title":"视图","keywords":"","body":"视图 "},"page/11330.html":{"url":"page/11330.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11331.html":{"url":"page/11331.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11332.html":{"url":"page/11332.html","title":"存储过程","keywords":"","body":"存储过程 "},"page/11333.html":{"url":"page/11333.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11334.html":{"url":"page/11334.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11335.html":{"url":"page/11335.html","title":"触发器","keywords":"","body":"触发器 "},"page/11336.html":{"url":"page/11336.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11337.html":{"url":"page/11337.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11026.html":{"url":"page/11026.html","title":"数据操纵语言DML","keywords":"","body":"数据操纵语言DML "},"page/11299.html":{"url":"page/11299.html","title":"MSSQL数据操纵语言DML","keywords":"","body":"MSSQL数据操纵语言DML "},"page/11027.html":{"url":"page/11027.html","title":"插入--增","keywords":"","body":"插入 "},"page/11263.html":{"url":"page/11263.html","title":"MSSQL","keywords":"","body":"MSSQL 插入记录 插入记录使用INSERT语句。语法格式。 [ WITH [ ,...n ] ] /*指定临时结果集，在SELECT语句中介绍*/ INSERT [ TOP ( expression ) [ PERCENT ] ] [ INTO ] { table_name /*表名*/ | view_name /*视图名*/ | rowset_function_limited /*可以是OPENQUERY 或 OPENROWSET 函数*/ [WITH ([…n])] /*指定表提示，可省略*/ } { [ ( column_list ) ] /*列列表*/ [ ] /*OUTPUT子句*/ { VALUES ( ( { DEFAULT | NULL | expression } [ ,...n ] ) [ ,...n ] ) /*指定列值的value子句*/ | derived_table /*结果集*/ | execute_statement /*有效的EXECUTE语句*/ | | DEFAULT VALUES /*强制新行包含为每个列定义的默认值*/ } } 说明如下。 （1）table_name：被操作的表名。前面可以指定数据库名和架构名。 （2）view_name：视图名。有关视图的内容将在第4章中介绍。 （3）column_list：需要插入数据的列的列表。包含了新插入行的各列的名称。当只给表的部分列插入数据时，需要用column_list指出这些列。 （4）OUTPUT子句：用于在执行插入数据操作时返回插入的行，可用于数据比较等场合，可省略。 （5）VALUES子句: 包含各列需要插入的数据清单，数据的顺序要与列的顺序相对应。若省略colume_list，则VALUES子句给出每一列（除IDENTITY属性和timestamp类型以外的列）的值。VALUES子句中的值可有以下三种。 ① DEFAULT：指定为该列的默认值。这要求定义表时必须指定该列的默认值。 ② NULL：指定该列为空值。 ③ expression：可以是一个常量、变量或一个表达式，其值的数据类型要与列的数据类型一致。例如，列的数据类型为int，若插入的数据是'aaa'就会出错。当数据为字符型时要用单引号括起来。 （6）derived_table：这是一个由SELECT语句查询所得到的结果集。利用该参数，可把一个表中的部分数据插入到另一个表中。结果集中每行数据的字段数、字段的数据类型要与被操作的表完全一致。使用结果集向表中插入数据时可以使用TOP (expression) [ PERCENT ]选项，这个选项可以在结果集中选择指定的行数或占指定百分比数的行插入表中。expression可以是行数或行的百分比，使用百分比时要加PERCENT关键字。有关SELECT语句的内容将在后面介绍。 （7）：指定插入目标表的行是INSERT、UPDATE、DELETE或 MERGE 语句的OUTPUT子句返回的行。 （8）DEFAULT VALUES：该关键字说明向当前表中所有列均插入其默认值。此时，要求所有列均定义了默认值。 【例3.13】 向PXSCJ数据库的表XSB中插入如下一行数据： 081101, 王林, 1, 1990-02-10, 计算机, 50 , NULL（假设XSB表中该行数据已被删除） INSERT INTO XSB VALUES('081101', '王林' , 1, '1990-02-10', '计算机',50, NULL) 语句的运行结果如图3.19所示。 图3.19 使用T-SQL语句向表中插入数据 【例3.14】 假设上表XSB中专业的默认值为“计算机”，备注默认值为NULL，则插入上例数据可以使用以下命令： INSERT INTO XSB (学号, 姓名, 性别, 出生时间, 总学分) VALUES('081101', '王林', 1, '1990-02-10', 50) 下列命令效果相同： INSERT INTO XSB VALUES('081101', '王林', 1, '1990-02-10', DEFAULT,50, NULL); 【例3.15】 一次向XSB表中插入两行数据：（'091101', '王海', 1, '1991-05-10', '软件工程', 50, NULL）和（'091102', '李娜', 0, '1991-04-12', '软件工程', 52, NULL）。 INSERT INTO XSB VALUES ('091101', '王海', 1, '1991-05-10', '软件工程', 50, NULL), ('091102', '李娜', 0, '1991-04-12', '软件工程', 52, NULL) 【例3.16】 向学生管理系统涉及的其他表中插入数据。 向KCB表加入数据的T-SQL语句示例如下： INSERT INTO KCB VALUES('101','计算机基础',1,80,5) 向CJB表加入数据的T-SQL语句示例如下： INSERT INTO CJB VALUES('081101',101,80) 【例3.17】 从表XSB中生成计算机专业的学生表，包括学号、姓名、专业，要求新表中的数据为结果集中前5行。 用CREATE语句建立表XSB1： USE PXSCJ GO CREATE TABLE XSB1 ( num char(6) NOT NULL PRIMARY KEY, name char(8) NOT NULL, speiality char(10) NULL ) 用INSERT语句向XSB1表中插入数据： INSERT TOP(5) INTO XSB1 SELECT 学号, 姓名, 专业 FROM XSB WHERE 专业= '计算机' 使用SELECT语句从XSB1表中查询结果： SELECT * FROM XSB1 /* XSB1表的内容*/ 执行结果如图3.20所示： 图3.20 执行结果 界面 插入记录 用户可以自己根据需要向表中插入数据，插入的数据要符合列的约束条件，例如，不可以向非空的列插入NULL值。下图所示是插入数据后的XSB表。 向表中插入记录 命令 1．可更新视图 要通过视图更新基本表数据，必须保证视图是可更新视图。一个可更新视图可以是以下情形之一。 （1）满足以下条件的视图。 创建视图的SELECT语句中没有聚合函数，且没有TOP、GROUP BY、UNION子句及DISTINCT关键字。 创建视图的SELECT语句中不包含从基本表列通过计算所得的列。 创建视图的SELECT语句的FROM子句中至少要包含一个基本表。 （2）可更新的分区视图。 在实现分区视图之前，必须先实现水平分区表。原始表被分成若干个较小的成员表，每个成员表包含与原始表相同数量的列，并且每一列具有与原始表中的相应列同样的特性（如数据类型、大小、排序规则）。 （3）通过INSTEAD OF触发器创建的可更新视图。INSTEAD OF 触发器将在后面介绍。 例如，前面创建的视图CS_XS、CS_KC是可更新视图，而CS_KC_AVG是不可更新的视图。 在对视图进行更新操作时，要注意基本表对数据的各种约束和规则要求。 2．插入数据 使用INSERT语句通过视图向基本表插入数据，有关INSERT语句的语法介绍后面介绍。 【例4.79】 向CS_XS视图中插入以下记录： ('081115', '刘明仪', 1, '1998-3-2', '计算机', 50 , NULL) INSERT INTO CS_XS VALUES('081115', '刘明仪', 1,'1998-3-2', '计算机',50,NULL) 使用SELECT语句查询CS_XS依据的基本表XSB： SELECT * FROM XSB 将会看到该表已添加了('081115', '刘明仪', 1,'1998-3-2', '计算机',50,NULL)行。 当视图所依赖的基本表有多个时，不能向该视图插入数据，因为这将会影响多个基表。例如，不能向视图CS_KC插入数据，因为CS_KC依赖两个基本表：XSB和CJB。 界面 操作方法： （1）在对象资源管理器中展开“数据库→PXSCJ→视图”，选择“CS_XS”，右击鼠标，在弹出的快捷菜单上选择“编辑前200行”菜单项，在出现的如图4.8所示的数据窗口中添加新记录，输入新记录各字段的值。 图4.8 通过视图插入和删除数据 （2）定位到需修改的学号为“081115”的行的总学分字段，删除原值50，输入新值52。 （3）定位到需删除的学号为“081115”的行，单击鼠标右键，在弹出的快捷菜单上选择“删除”，弹出“确认删除”对话框，在其中单击“是”按钮完成删除操作。 "},"page/11029.html":{"url":"page/11029.html","title":"删除--删","keywords":"","body":"删除 "},"page/11265.html":{"url":"page/11265.html","title":"MSSQL","keywords":"","body":"MSSQL 使用DELETE语句删除数据 语法格式如下。 说明如下。 （1）[ TOP ( expression ) [ PERCENT ] ]：指定将要删除的任意行数或任意行的百分比。 （2）FROM子句：说明从何处删除数据。可以从以下四种类型的对象中删除数据。 ① 表：由table_name指定要从其中删除数据的表名，关键字WITH指定目标表所允许的一个或多个表提示，一般情况下不需要使用WITH关键字。 ② 视图：由view_name指定要从其中删除数据的视图名，注意该视图必须可以更新，并且正确引用了一个基本表。 ③ OPENQUERY和OPENROWSET函数：由rowset_function_limited指定。 ④ table_source：将在介绍SELECT语句时详细讨论。 （3）WHERE子句：WHERE子句为删除操作指定条件，给出了条件，其格式将在介绍SELECT语句时详细讨论。 若省略WHERE子句，则DELETE语句将删除所有数据。 关键字CURRENT OF说明在指定游标的当前位置完成删除操作。 关键字GLOBAL说明cursor_name指定的游标是全局游标。 游标变量必须引用允许更新的游标。cursor_variable_name是游标变量的名称。 【例3.18】 将PXSCJ数据库的XSB表中总学分大于52的行删除，使用如下语句： USE PXSCJ GO DELETE FROM XSB WHERE 总学分>52 GO 【例3.19】 将PXSCJ数据库的XSB表中备注为空的行删除（实际不做操作）： DELETE FROM XSB WHERE 备注 IS NULL 删除PXSCJ数据库的XSB表中的所有行（实际不做操作）： DELETE XSB 使用TRUNCATE TABLE语句删除表数据 使用TRUNCATE TABLE语句将删除指定表中的所有数据，因此也称为清除表数据语句。 语法格式： TRUNCATE TABLE tb_name 使用TRUNCATE TABLE语句删除了指定表中的所有行，但表的结构及其列、约束、索引等保持不变，而新行标识所用的计数值重置为该列的初始值。如果要保留标识计数值，则要使用DELETE语句。 TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同，二者均删除表中的全部行； 但TRUNCATE TABLE比DELETE速度快，且使用的系统和事务日志资源少。 DELETE语句每次删除一行，并在事务日志中为所删除的每一行记录一项。 而TRUNCATE TABLE通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 界面 当表中的某些记录不再需要时，要将其删除。在对象资源管理器中删除记录的方法是：在表数据窗口中定位需删除的记录行，单击该行最前面的黑色箭头处选择全行，右击鼠标，选择“删除”菜单项，如图所示。 删除记录 4．删除数据 使用DELETE语句可以通过视图删除基本表的数据，不能使用DELETE语句。例如，不能通过对CS_KC视图执行DELETE语句而删除与之相关的基本表XSB及CJB表的数据。 【例4.82】 删除CS_XS中女同学的记录。 DELETE FROM CS_XS WHERE 性别 = 0 对视图的更新操作也可通过SQL Server Management Studio的界面进行，操作方法与对表数据的插入、修改和删除的界面操作方法基本相同，在此仅举一例加以说明。 【例4.83】 在对象资源管理器中对视图CS_XS进行如下操作： （1）增加一条记录('081115', '刘明仪', 1, '1998-3-2', '计算机', 50 , NULL)。 （2）将学号为081115的学生的总学分改为55。 （3）删除学号为081115的学生记录。 操作方法： （1）在对象资源管理器中展开“数据库→PXSCJ→视图”，选择“CS_XS”，右击鼠标，在弹出的快捷菜单上选择“编辑前200行”菜单项，在出现的如图4.8所示的数据窗口中添加新记录，输入新记录各字段的值。 图4.8 通过视图插入和删除数据 （2）定位到需修改的学号为“081115”的行的总学分字段，删除原值50，输入新值52。 （3）定位到需删除的学号为“081115”的行，单击鼠标右键，在弹出的快捷菜单上选择“删除”，弹出“确认删除”对话框，在其中单击“是”按钮完成删除操作。 "},"page/11028.html":{"url":"page/11028.html","title":"更新--改","keywords":"","body":"更新 "},"page/11264.html":{"url":"page/11264.html","title":"MSSQL","keywords":"","body":"MSSQL 在T-SQL中，UPDATE语句可以用来修改表中的数据行。 语法格式。 [ WITH [...n] ] UPDATE [ TOP ( expression ) [ PERCENT ] ] { table_name /*修改表数据*/ | view_name /*修改视图数据*/ | rowset_function_limited WITH ( [ ...n ] ) } SET /*赋予新值*/ { column_name = { expression | DEFAULT | NULL } /*为列重新指定值*/ | column_name { .WRITE ( expression , @Offset , @Length ) } | @variable = expression /*指定变量的新值*/ | @variable = column = expression /*指定列和变量的新值*/ | column_name { += | ?= | *= | /= | %= | &= | ^= | |= } expression | @variable { += | ?= | *= | /= | %= | &= | ^= | |= } expression | @variable = column { += | ?= | *= | /= | %= | &= | ^= | |= } expression } [ ,...n ] [ ] [ FROM{ } [ ,...n ] ] [ WHERE { /*指定条件*/ | { [ CURRENT OF /*有关游标的说明*/ { { [ GLOBAL ] cursor_name } | cursor_variable_name } ]} } ] [ OPTION ( [ ,...n ] ) ] /*使用优化程序*/ [ ; ] 据窗口，可以发现表中学号为“081101”的行的备注字段值已被修改，如图3.21所示。 图3.21 修改数据以后的表 【例3.21】 将XSB表（数据以附录A中XSB表的样本数据为准）中所有学生的总学分都增加10。将姓名为“罗林琳”的同学的专业改为“软件工程”，备注改为“提前修完学分”，学号改为081261。 USE PXSCJ GO UPDATE XSB SET 总学分 = 总学分+10 GO UPDATE XSB SET 专业 = '软件工程', 备注 = '提前修完学分', 学号 = '081261' WHERE 姓名 = '罗林琳' GO SELECT * FROM XSB 图3.22 修改结果 MERGE语句更新记录 在SQL Server 2008中，新增加了一个MERGE语句，用于根据与源表连接的结果，对目标表执行插入、更新或删除操作。例如，根据一个表的数据在 另一个表中插入、更新或删除有差异的行，可以对两个表进行信息同步。 语法格式如下。 [ WITH [,...n] ] MERGE [ TOP ( expression ) [ PERCENT ] ] [ INTO ] target_table [ [ AS ] table_alias ] USING ON [ WHEN MATCHED [ AND ] THEN { UPDATE SET | DELETE } ] [ WHEN NOT MATCHED [ BY TARGET ] [ AND ] THEN INSERT [ ( column_list ) ] { VALUES ( values_list ) | DEFAULT VALUES } ] [ WHEN NOT MATCHED BY SOURCE [ AND ] THEN { UPDATE SET | DELETE }] 【例3.22】 创建表a，要求表中数据与XSB表同步。 创建学生表的语句如下。 USE PXSCJ GO CREATE TABLE a ( 学号 char(6) NOT NULL PRIMARY KEY, 姓名 char(8) NOT NULL, 性别 bit NULL DEFAULT 1, 出生时间 date NULL, 专业 char(12) NULL, 总学分 int NULL, 备注 varchar(500) NULL ) 进行信息同步使用如下语句。 MERGE INTO a USING XSB ON a.学号=XSB.学号 WHEN MATCHED THEN UPDATE SET a.姓名=XSB.姓名,a.性别=XSB.性别,a.出生时间=XSB.出生时间, a.专业=XSB.专业,a.总学分=XSB.总学分,a.备注=XSB.备注 WHEN NOT MATCHED THEN INSERT VALUES(XSB.学号,XSB.姓名,XSB.性别,XSB.出生时间,XSB.专业, XSB.总学分,XSB.备注) WHEN NOT MATCHED BY SOURCE THEN DELETE; 界面 修改记录 在操作表数据的窗口中修改记录数据的方法是，先定位被修改的记录字段，然后对该字段值进行修改，修改之后将光标移到下一行即可保存修改的内容。 界面 操作方法： （1）在对象资源管理器中展开“数据库→PXSCJ→视图”，选择“CS_XS”，右击鼠标，在弹出的快捷菜单上选择“编辑前200行”菜单项，在出现的如图4.8所示的数据窗口中添加新记录，输入新记录各字段的值。 图4.8 通过视图插入和删除数据 （2）定位到需修改的学号为“081115”的行的总学分字段，删除原值50，输入新值52。 （3）定位到需删除的学号为“081115”的行，单击鼠标右键，在弹出的快捷菜单上选择“删除”，弹出“确认删除”对话框，在其中单击“是”按钮完成删除操作。 "},"page/11030.html":{"url":"page/11030.html","title":"数据查询语言DQL--查","keywords":"","body":"数据查询语言DQL "},"page/11300.html":{"url":"page/11300.html","title":"MSSQL数据查询语言DQL","keywords":"","body":"MSSQL数据查询语言DQL "},"page/11031.html":{"url":"page/11031.html","title":"SELECT","keywords":"","body":"SELECT "},"page/11266.html":{"url":"page/11266.html","title":"MSSQL","keywords":"","body":"MSSQL 当用户登录到SQL Server后，即被指定一个默认数据库，通常是master数据库。使用USE database_name语句可以选择当前要操作的数据库。其中，database_name是要选为当前数据库的数据库名。例如，要选择PXSCJ为当前数据库，可以使用如下语句实现： USE PXSCJ GO 下面介绍SELECT语句，它是T-SQL的核心。语法格式如下： [ WITH ] /*指定临时命名的结果集*/ SELECT [ ALL | DISTINCT ] [ TOP expression [ PERCENT ] [ WITH TIES ] ] /*指定要选择的列及其限定,对列操作*/ [ INTO new_table ] /*INTO子句，指定结果存入新表*/ [ FROM table_source ] /*FROM子句，指定表或视图*/ [ WHERE search_condition ] /*WHERE子句，指定查询条件*/ [ GROUP BY group_by_expression] /*GROUP BY子句，指定分组表达式*/ [ HAVING search_condition] /*HAVING子句，指定分组统计条件*/ [ ORDER BY order_expression [ ASC | DESC ] ] /*ORDER子句，指定排序表达式和顺序*/ 通过SELECT语句的项组成结果表的列。语法格式如下： ::= { * /*选择当前表或视图的所有列*/ | { table_name | view_name | table_alias }.* /*选择指定的表或视图的所有列*/ | { column_name | [ ] expression | $IDENTITY | $ROWGUID } /*选择指定的列*/ | udt_column_name [ { . | :: } { { property_name | field_name } | method_name(argument [,...n] ) } ] /*选择用户定义数据类型的属性、方法和字段*/ | expression [ [ AS ] column_alias ] /*AS子句，定义列别名*/ | column_alias = expression /*选择指定列并更改列标题*/ } [ ,...n ] 1．选择所有列 使用“*”表示选择一个表或视图中的所有列。 【例4.1】 查询PXSCJ数据库中XSB表的所有数据。 USE PXSCJ GO SELECT * FROM XSB GO 执行完后SQL Server Management Studio的结果窗口中将显示XSB表的所有数据。 2．选择一个表中指定的列 使用SELECT语句选择一个表中的某些列，各列名之间要以逗号分隔。其中，IDENTITY表示选择标识列，ROWGUID表示选择ROWGUIDCOL属性的全局标识列。如果在FROM子句中有多个表具有ROWGUIDCOL属性，则必须用特定的表名限定$ROWGUID，如T1.$ROWGUID。 【例4.2】 查询PXSCJ数据库的XSB表中各个同学的姓名、专业和总学分。 USE PXSCJ GO SELECT 姓名,专业,总学分 FROM XSB GO SQL Server 2008中还能一次执行多个查询。 【例4.3】 查询XSB表中计算机专业同学的学号、姓名和总学分，查询XSB表中所有列。 SELECT 学号, 姓名, 总学分 FROM XSB WHERE 专业 = '计算机' GO SELECT * FROM XSB 执行后在结果窗口中将分别列出两个查询语句的结果，如图4.1所示： 图4.1 一次执行多个查询 3．定义列别名 当希望查询结果中的某些列或所有列显示时使用自己选择的列标题时，可以在列名之后使用AS子句来更改查询结果的列标题名。其中，column_alias是指定的列别名。 更改查询结果中的列标题也可以使用column_alias=expression的形式。 当自定义的列标题中含有空格时，必须使用引号将标题括起来。 【例4.4】 查询XSB表中计算机系同学的学号、姓名和总学分，结果中各列的标题分别指定为number、name和mark。 USE PXSCJ GO SELECT 学号 AS number, 姓名 AS name, 总学分 AS mark FROM XSB WHERE 专业= '计算机' 更改查询结果中的列标题也可以使用column_alias=expression的形式。例如， SELECT number= 学号, name = 姓名, mark = 总学分 FROM XSB WHERE 专业= '计算机' 该语句的执行结果与上例的结果完全相同。 当自定义的列标题中含有空格时，必须使用引号将标题括起来。例如， SELECT 'Student number' = 学号,姓名 AS 'Student name', mark = 总学分 FROM XSB WHERE 专业= '计算机' 4．替换查询结果中的数据 在对表进行查询时，有时希望对所查询的某些列得到的是一种概念而不是具体的数据。例如，查询XSB表的总学分，希望知道的是学习的总体情况，这时，就可以用等级来替换总学分的具体数字。 要替换查询结果中的数据，则要使用查询中的CASE表达式，格式为 CASE WHEN 条件1 THEN 表达式1 WHEN 条件2 THEN 表达式2 …… ELSE 表达式 END 【例4.5】 查询XSB表中计算机系各同学的学号、姓名和总学分，对其总学分按以下规则进行替换：若总学分为空值，则替换为“尚未选课”；若总学分小于50，则替换为“不及格”；若总学分在50与52之间，则替换为“合格”；若总学分大于52，则替换为“优秀”。列标题更改为“等级”。 USE PXSCJ GO SELECT 学号, 姓名, 等级= CASE WHEN 总学分 IS NULL THEN '尚未选课' WHEN 总学分 =50 and 总学分 5．计算列值 使用SELECT对列进行查询时，在结果中可以输出对列值计算后的值，即SELECT子句可使用表达式作为结果，格式为 SELECT expression [ , expression ] 【例4.6】 按120分计算成绩并显示学号为081101的学生的成绩情况。 USE PXSCJ GO SELECT 学号, 课程号, 成绩120=成绩*1.20 FROM CJB WHERE 学号= '081101' 执行结果如下： 6．消除结果集中的重复行 对表只选择其某些列时，可能会出现重复行。例如，若对PXSCJ数据库的XSB表只选择专业和总学分，则出现多行重复的情况。可以使用DISTINCT关键字消除结果集中的重复行，其格式是 SELECT DISTINCT | ALL column_name [ , column_name…] 关键字DISTINCT的含义是，对结果集中的重复行只选择一个，保证行的唯一性。 【例4.7】 对PXSCJ数据库的XSB表只选择专业和总学分，消除结果集中的重复行。 USE PXSCJ GO SELECT DISTINCT 专业,总学分 FROM XSB 执行结果如下： 7．限制结果集返回行数 如果SELECT语句返回的结果集的行数非常多，那么可以使用TOP选项限制其返回的行数。TOP选项的基本格式为 [ TOP expression [ PERCENT ] [ WITH TIES ] ] 指示只能从查询结果集返回指定的第一组行或指定的百分比数目的行。expression可以是指定数目或百分比数目的行。若带PERCENT关键字，则表示返回结果集的前expression%行。TOP 子句可以用于 SELECT、INSERT、UPDATE 和 DELETE 语句中。 【例4.8】 对PXSCJ数据库的XSB表选择姓名、专业和总学分，返回结果集的前6行。 SELECT TOP 6 姓名,专业,总学分 FROM XSB 8．选择用户定义数据类型列 udt_column_name为要指定的用户定义类型列的名称。{ . | :: } 指定用户定义类型的方法、属性或字段，将“.”用于实例（非静态）方法、属性或字段，“::”用于静态方法、属性或字段。property_name为udt_column_name的公共属性。field_name为udt_column_name 的公共数据成员。method_name 是采用一个或多个参数的udt_column_name的公共方法。 9．聚合函数 SELECT子句中的表达式中还可以包含所谓的聚合函数。聚合函数常常用于对一组值进行计算，然后返回单个值。聚合函数通常与GROUP BY子句一起使用。如果一个SELECT语句中有一个GROUP BY子句，则这个聚合函数对所有列起作用，如果没有，则SELECT语句只产生一行作为结果。SQL Server 2008所提供的聚合函数列于表4.10中。 聚合函数表 函 数 名 说 明 AVG 求组中值的平均值 BINARY_CHECKSUM 返回对表中的行或表达式列表计算的二进制校验值，可用于检测表中行的更改 CHECKSUM 返回在表的行上或在表达式列表上计算的校验值，用于生成哈希索引 CHECKSUM_AGG 返回组中值的校验值 COUNT 求组中项数，返回int类型整数 COUNT_BIG 求组中项数，返回bigint类型整数 GROUPING 产生一个附加的列 GROUPING_ID 为聚合列列表中的每一行创建一个值以标识聚合级别 MAX 求最大值 MIN 求最小值 SUM 返回表达式中所有值的和 STDEV 返回给定表达式中所有值的统计标准偏差 STDEVP 返回给定表达式中所有值的填充统计标准偏差 VAR 返回给定表达式中所有值的统计方差 VARP 返回给定表达式中所有值的填充统计方差 查询视图 例如，若限定某用户只能查询视图CS_XS，实际上就是限制了它只能访问XSB表的专业字段值为“计算机”的行。在创建视图时可以指定列，实际上也就是限制了用户只能访问这些列，从而视图也可看做数据库的安全措施。 在使用视图查询时，若其关联的基本表中添加了新字段，则必须重新创建视图才能查询到新字段。例如，若XSB表新增了“籍贯”字段，那么在其上创建的视图CS_XS若不重建视图，则查询 SELECT * FROM CS_XS 结果将不包含“籍贯”字段。只有重建CS_XS视图后再对它进行查询，结果才会包含“籍贯”字段。如果与视图相关联的表或视图被删除，则该视图将不能再使用。 【例4.77】 使用视图CS_KC查找计算机专业的学生学号和选修的课程号。 SELECT 学号, 课程号 FROM CS_KC 【例4.78】 查找平均成绩在80分以上的学生的学号和平均成绩。 本例首先创建学生平均成绩视图XS_KC_AVG，包括学号（在视图中列名为num）和平均成绩（在视图中列名为score_avg）。 CREATE VIEW XS_KC_AVG ( num,score_avg ) AS SELECT 学号, AVG(成绩) FROM CJB GROUP BY 学号 再对XS_KC_AVG视图进行查询。 SELECT * FROM XS_KC_AVG WHERE score_avg >= 80 执行结果如下： "},"page/11032.html":{"url":"page/11032.html","title":"基本子句","keywords":"","body":"基本子句 "},"page/11267.html":{"url":"page/11267.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11033.html":{"url":"page/11033.html","title":"FROM","keywords":"","body":"FROM "},"page/11268.html":{"url":"page/11268.html","title":"MSSQL","keywords":"","body":"MSSQL FROM子句 SELECT的查询对象由FROM子句指定，其格式为 [ FROM {} [,…n] ] 其中，table_source指出了要查询的表或视图。 ::= { table_or_view_name [ [ AS ] table_alias ] /*查询表或视图，可指定别名*/ [ WITH ( [ [ , ]...n ] ) ] | rowset_function [ [ AS ] table_alias ] /*行集函数*/ [ ( bulk_column_alias [ ,...n ] ) ] | user_defined_function [ [ AS ] table_alias ] /*指定表值函数*/ | OPENXML /*XML文档*/ | derived_table [ AS ] table_alias [ ( column_alias [ ,...n ] ) ] /*子查询*/ | /*连接表*/ | /*将行转换为列*/ | /*将列转换为行*/ } 1．table_or_view_name table_or_view_name指定SELECT语句要查询的表或视图，表和视图可以是一个或多个 【例4.35】 查找表KCB中101号课程的开课学期。 USE PXSCJ GO SELECT 开课学期 FROM KCB WHERE 课程号= '101' 查询结果为1。 【例4.36】 查找081101号学生计算机基础课的成绩。 SELECT 成绩 FROM CJB, KCB WHERE CJB.课程号=KCB.课程号 AND 学号='081101' AND 课程名='计算机基础' 【例4.37】 查找选修了学号为081102的同学所选修的全部课程的同学的学号。 SELECT DISTINCT 学号 FROM CJB AS CJ1 WHERE NOT EXISTS ( SELECT * FROM CJB AS CJ2 WHERE CJ2.学号 = '081102' AND NOT EXISTS ( SELECT * FROM CJB AS CJ3 WHERE CJ3. 学号= CJ1.学号 AND CJ3.课程号 = CJ2.课程号 ) ) 2．rowset_function rowset_function是一个行集函数，行集函数通常返回一个表或视图。bulk_column_alias是替代结果集内列名的可选别名。 主要的行集函数有CONTAINSTABLE、FREETEXTTABLE、OPENDATASOURCE、OPENQUERY、OPENROWSET和OPENXML。 （1）CONTAINSTABLE函数。该函数与CONTAINS谓词相对应，用于对表进行全文查询，并且要求所查询的表上建立了全文索引。CONTAINSTABLE函数的语法格式为： CONTAINSTABLE(table , {column | column_list | * } , '' [ , top_n_by_rank ] ) 其中，table是进行全文查询的表，column指定被查询的列，column_list可以指定多个列，*指对所有列进行查询。contains_search_condition与CONTAINS谓词中的搜索条件完全相同。 （2）FREETEXTTABLE函数。FREETEXTTABLE函数与FREETEXT谓词相对应，它的使用与CONTAINSTABLE函数类似，格式为： FREETEXTTABLE ( table , { column | column_list | * } , 'freetext_string' [ , top_n_by_rank ] ) 该函数使用与FREETEXT谓词相同的搜索条件。 （3）OPENDATASOURCE函数。该函数使用户连接到服务器。格式为： OPENDATASOURCE ( provider_name , init_string ) 其中，provider_name是用于访问数据源OLE DB访问接口的PROGID的名称， init_string是连接字符串，这些字符串将要传递给目标提供程序的 IDataInitialize 接口。 （4）OPENQUERY函数。该函数在给定的链接服务器（一个OLE DB数据源）上执行指定的直接传递查询，返回查询的结果集。 （5）OPENROWSET函数。该函数与OPENQUERY函数功能相同，只是语法格式不同。 （6）OPENXML函数。OPENXML 通过XML文档提供行集视图。 3．user_defined_function user_defined_function是表值函数，所谓表值函数就是返回一个表的用户自定义函数 4．derived_table 子查询可以用在FROM子句中，derived_table表示由子查询中SELECT语句的执行而返回的表，但必须使用AS关键字为子查询产生的中间表定义一个别名。 【例4.38】 从XSB表中查找总学分大于50的男同学的姓名和学号。 SELECT 姓名,学号,总学分 FROM ( SELECT 姓名, 学号, 性别, 总学分 FROM XSB WHERE 总学分>50 ) AS STUDENT WHERE 性别=1; 执行结果如下： 【例4.39】 在XSB表中查找1990年1月1日以前出生的学生的姓名和专业，分别使用别名stu_name和speciality表示。 SELECT m.stu_name, m.speciality FROM ( SELECT * FROM XSB WHERE 出生时间 5．pivoted_table和unpivoted_table 的格式如下： ::= table_source PIVOT [AS] table_alias 其中， ::= ( aggregate_function ( value_column ) FOR pivot_column IN () ) 【例4.40】 查找XSB表中1990年1月1日以前出生的学生的姓名和总学分，并列出其属于计算机专业还是通信工程专业的情况，1表示是，0表示否。 SELECT 姓名,总学分,计算机,通信工程 FROM XSB PIVOT ( COUNT(学号) FOR 专业 IN(计算机,通信工程) )AS pvt WHERE 出生时间 格式如下： ::= table_source UNPIVOT table_alias 其中， ::= ( value_column FOR pivot_column IN ( ) ) 【例4.41】 将KCB表中的开课学期和学分列转换为行输出。 SELECT 课程号,课程名,选项,内容 FROM KCB UNPIVOT ( 内容 FOR 选项 IN (学分,开课学期) )unpvt 执行结果如下： "},"page/11034.html":{"url":"page/11034.html","title":"WHERE","keywords":"","body":"WHERE "},"page/11269.html":{"url":"page/11269.html","title":"MSSQL","keywords":"","body":"MSSQL 在SQL Server 2008中，选择行是通过在SELECT语句的WHERE子句中指定选择的条件来实现的。这一节将详细讨论WHERE子句中查询条件的构成。WHERE子句必须紧跟在FROM子句之后，其基本格式为 WHERE 其中，search_condition为查询条件。 ::= { [ NOT ] | ( ) } [ { AND | OR } [ NOT ] { | () } ] [ ,…n ] 其中，为判定运算，结果为TRUE、FALSE或UNKNOWN。NOT表示对判定的结果取反，AND用于组合两个条件，两个条件都为TRUE时值才为TRUE。OR也用于组合两个条件，两个条件有一个条件为TRUE时值就为TRUE。 ::= { expression { = | | >= | <> | != | ! } expression /*比较运算*/ | match_expression [ NOT ] LIKE pattern [ ESCAPE Escape_character ] /*字符串模式匹配*/ | expression [ NOT ] BETWEEN expression AND expression /*指定范围*/ | expression IS [ NOT ] NULL /*是否空值判断*/ | CONTAINS ( { column | * }, '') /*包含式查询*/ | FREETEXT ({ column | * }, 'freetext_string') /*自由式查询*/ | expression [ NOT ] IN ( subquery | expression [,…n] ) /*IN子句*/ | expression { = | | >= | <> | != | ! } { ALL | SOME | ANY } ( subquery ) /*比较子查询*/ | EXIST ( subquery ) /*EXIST子查询*/ } where是一行一行看的没法聚合 1．表达式比较 比较运算符用于比较两个表达式值，共有9个， 分别是 =（等于）、（大于）、>=（大于等于）、<>（不等于）、!=（不等于）、!（不大于）。 比较运算的格式为 expression { = | | >= | <> | != | ! } expression 其中，expression是除text、ntext和image以外类型的表达式。 当两个表达式值均不为空值（NULL）时，比较运算返回逻辑值TRUE（真）或FALSE（假）。而当两个表达式值中有一个为空值或都为空值时，比较运算将返回UNKNOWN。 【例4.16】 查询PXSCJ数据库XSB表中学号为081101的同学的情况。 USE PXSCJ GO SELECT 姓名,学号,总学分 FROM XSB WHERE 学号='081101'; 执行结果如下： 【例4.17】 查询XSB表中总学分大于50的同学的情况。 SELECT 姓名,学号,出生时间,总学分 FROM XSB WHERE 总学分>50; 执行结果如下： 【例4.18】 查询XSB表中通信工程专业总学分大于等于42的同学的情况。 USE PXSCJ GO SELECT * FROM XSB WHERE 专业= '通信工程' AND 总学分 >= 42 2．模式匹配 LIKE谓词用于指出一个字符串是否与指定的字符串相匹配，返回逻辑值TRUE或FALSE。LIKE谓词表达式的格式为 match_expression [ NOT ] LIKE pattern [ ESCAPE Escape_character ] 说明如下。 match_expression：匹配表达式，一般为字符串表达式，在查询语句中可以是列名。 pattern：在match_expression 中的搜索模式串。在搜索模式串中可以使用通配符，下表列出了LIKE谓词可以使用的通配符及其说明。 通配符列表 通 配 符 说 明 % 代表0个或多个字符 _（下画线） 代表单个字符 [ ] 指定范围（如[a-f]、[0-9]）或集合（如[abcdef]）中的任何单个字符 指定不属于范围（如 [^a-f]、[^0-9]）或集合（如[^abcdef]）的任何单个字符 Escape_character：转义字符，应为有效的SQL Server字符，Escape_character没有默认值，且必须为单个字符。当模式串中含有与通配符相同的字符时，应通过该字符前的转义字符指明其为模式串中的一个匹配字符。使用ESCAPE可指定转义符。 NOT LIKE：使用NOT LIKE与LIKE的作用相反。 使用带%通配符的LIKE时，若使用LIKE 进行字符串比较，则模式字符串中的所有字符都有意义，包括起始或尾随空格。 【例4.19】 查询XSB表中姓“王”且单名的学生情况。 SELECT * FROM XSB WHERE 姓名 LIKE '王_ ' 执行结果如下： 【例4.20】 查询XSB表中学号倒数第3个数字为1，且倒数第1个数在1～5之间的学生学号、姓名及专业。 SELECT 学号,姓名,专业 FROM XSB WHERE 学号 LIKE '%1_[12345]' 如果需要查找一个通配符，则必须使用一个转义字符。 【例4.21】 查询XSB表中名字包含下划线的学生学号和姓名。 SELECT 学号,姓名 FROM XSB WHERE 学号 LIKE '%#_%' ESCAPE '#' 3．范围比较 用于范围比较的关键字有两个：BETWEEN和IN。当要查询的条件是某个值的范围时，可以使用BETWEEN关键字。BETWEEN关键字指出查询范围，格式为： expression [ NOT ] BETWEEN expression1 AND expression2 当不使用NOT时，若表达式expression的值在表达式expression1与expression2之间（包括这两个值），则返回TRUE，否则返回FALSE；当使用NOT时，返回值刚好相反。 使用IN关键字可以指定一个值表，值表中列出所有可能的值，当与值表中的任一个匹配时，即返回TRUE，否则返回FALSE。使用IN关键字指定值表的格式为： expression IN ( expression [,…n]) 【例4.22】 查询XSB表中不在1989年出生的学生情况。 SELECT 学号, 姓名, 专业, 出生时间 FROM XSB WHERE 出生时间 NOT BETWEEN '1989-1-1' and '1989-12-31' 【例4.23】 查询XSB表中专业为“计算机”、“通信工程”或“无线电”的学生情况。 SELECT * FROM XSB WHERE 专业 IN ('计算机', '通信工程', '无线电') 该语句与下列语句等价： SELECT * FROM XSB WHERE 专业= '计算机' or 专业= '通信工程' or 专业='无线电' 4．空值比较 当需要判定一个表达式的值是否为空值时，使用IS NULL关键字，格式为： expression IS [ NOT ] NULL 当不使用NOT时，若表达式expression的值为空值，则返回TRUE，否则返回FALSE；当使用NOT时，结果刚好相反。 【例4.24】 查询总学分尚不定的学生情况。 SELECT * FROM XSB WHERE 总学分 IS NULL 5．CONTAINS谓词 CONTAINS谓词的语法格式如下。 CONTAINS ( { column | * } , '' [ , LANGUAGE language_term ]) 其中，column表示在指定的列中搜索，可以指定多个列，类型为 char、varchar、nchar、nvarchar、text、ntext、image、xml 和 varbinary(max) 的列是可进行全文搜索的有效列。 *表示在所有列中搜索，language_term表示用户查询时所用的语言。 指定要在 column_name 中搜索的文本和匹配条件。 ::= { | | | | } | { ( ) [ { | | } ] [ ...n ] } 说明如下。 ：用于说明搜索的是单词还是短语，格式为： word | \"phrase\" 其中，word为单词，即不含空格和标点符号的字符串；短语是含一个或多个空格的字符串。如果搜索的是短语，则需要用双引号将其括起来。 ：给出了要搜索的单词或短语必须匹配的前缀，其格式为： { \"word*\" | \"phase*\"} 其中，word为单词，phase为短语，当查询的串是短语时，需用双引号定界。 ：说明搜索包含原词的派生词，所谓派生词是指原词的名词单、复数形式或动词的各种时态等。格式为： FORMSOF ( { INFLECTIONAL | THESAURUS } , [ ,...n ] ) INFLECTIONAL选项表示指定要对指定的简单字词使用与语言相关的词干分析器。 THESAURUS选项表示指定使用对应于列全文语言或指定的查询语言的同义词库。 ：表示搜索包含NEAR或~运算符左右两边的词或短语。 格式为： { | } { { NEAR | ~ } { | }[…n] ：指明本语句是加权搜索，即查询的数据与给定的权重进行加权匹配。格式为： ISABOUT ( { { | | | } [ WEIGHT ( weight_value ) ] } [ ,...n ] ) 其中，weight_value是一个0～1之间的数，表示权重。 【例4.25】 使用CONTAINS谓词搜索XSB表中包含字符“工程”的所有行。 USE PXSCJ GO SELECT * FROM XSB WHERE CONTAINS(*,'工程') 执行结果如下： 6．FREETEXT谓词 与CONTAINS谓词类似，FREETEXT谓词也用于在一个表中搜索单词或短语，并要求表已建立全文索引。格式为 FREETEXT ( { column| column _list | * }, 'freetext_string' [ , LANGUAGE language_term ] ) 其中，freetext_string是要搜索的字符串。 FREETEXT的查询精度没有CONTAINS高，并不要求对它们进行严格的模式匹配。FREETEXT对所查询的串也没有写法要求，因此FREETEXT也称为自由式查询。 【例4.26】 使用FREETEXT谓词搜索XSB表中包含字符“李”的所有行。 SELECT * FROM XSB WHERE FREETEXT(*,'李') 界面新建全文索引 下面介绍如何利用图形化界面向导的方式来新建全文索引，其主要步骤如下。 第1步：要建立全文索引，首先要启动全文搜索服务，这项服务默认是禁用的。启动的方法是：打开“SQL Server配置管理器”窗口，进入“SQL Full-Text Filter Daemon Launcher”服务的属性对话框。选择“服务”选项卡，将“启动模式”设置为“自动”，如图4.2所示。设置完后单击“应用”按钮，再选择“登录”选项卡，将内置账户设置为本地账户，如local system，如图4.3所示，单击“启动”按钮启动全文搜索，最后单击“确定”按钮关闭窗口。 图4.2 更改服务启动模式 图4.3 启动全文搜索 第2步：创建全文目录。在对象资源管理器中展开数据库“PXSCJ”，选择“存储”目录下的“全文目录”，右击鼠标，选择“新建全文目录”选项。在弹出的“新建全文目录-PXSCJ”窗口中填写全文目录名称，如fulltext，如图4.4所示，单击“确定”按钮。 图4.4 创建全文目录 第3步：在全文目录中注册需要全文索引的表。在“全文目录”目录下右击刚刚新建的全文目录“fulltext”，选择“属性”菜单项，进入fulltext的属性窗口。选择“表/视图”选项卡，选择需要全文索引的表，如“dbo.XSB”，单击 按钮。选择完需要全文索引的表后，在“合格列”栏中会显示能够进行全文索引的列，选择需要的列，如图4.5所示，单击“确定”按钮。 图4.5 在全文目录中注册需要全文索引的表 "},"page/11274.html":{"url":"page/11274.html","title":"MSSQL子查询","keywords":"","body":"MSSQL 子查询 T-SQL允许SELECT多层嵌套使用，用来表示复杂的查询。子查询除了可以用在SELECT语句中，还可以用在INSERT、UPDATE及DELETE语句中。子查询通常与IN、EXIST谓词及比较运算符结合使用。 （1）IN子查询 IN子查询用于进行一个给定值是否在子查询结果集中的判断，格式为： expression [ NOT ] IN ( subquery ) 其中，subquery是子查询。当表达式expression与子查询subquery的结果表中的某个值相等时，IN谓词返回TRUE，否则返回FALSE；若使用了NOT，则返回的值刚好相反。 【例4.27】 查找选修了课程号为206的课程的学生情况。 在“查询分析器”窗口中输入并执行如下查询脚本： USE PXSCJ GO SELECT * FROM XSB WHERE 学号 IN ( SELECT 学号 FROM CJB WHERE 课程号 = '206') 在执行包含子查询的SELECT语句时，系统先执行子查询，产生一个结果表，再执行查询。本例中，先执行上面括号里面的子查询： SELECT 学号FROM CJB WHERE 课程名 = '206' 【例4.28】 查找未选修离散数学的学生情况。 SELECT * FROM XSB WHERE 学号 NOT IN ( SELECT 学号 FROM CJB WHERE 课程号 IN ( SELECT 课程号 FROM KCB WHERE 课程名 = '离散数学' ) ) （2）比较子查询 这种子查询可以认为是IN子查询的扩展，它使表达式的值与子查询的结果进行比较运算，格式为 expression { | >= | != | <> | ! } { ALL | SOME | ANY } ( subquery ) 其中，expression为要进行比较的表达式，subquery是子查询。ALL、SOME和ANY说明对比较运算的限制。 ALL指定表达式要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较的关系时，才返回TRUE，否则返回FALSE； SOME或ANY表示表达式只要与子查询结果集中的某个值满足比较的关系，就返回TRUE，否则返回FALSE。 【例4.29】 查找选修了离散数学的学生学号。 SELECT 学号 FROM CJB /* 一对一用=，多个值用in等*/ WHERE 课程号 = ( SELECT 课程号 FROM KCB WHERE 课程名 ='离散数学' ); 【例4.30】 查找比所有计算机系的学生年龄都大的学生。 SELECT * FROM XSB WHERE 出生时间 【例4.31】查找206号课程成绩不低于101号课程最低成绩的学生学号。 SELECT 学号 FROM CJB WHERE 课程号 = '206' AND 成绩 ! （3）EXISTS子查询 EXISTS谓词用于测试子查询的结果是否为空表，若子查询的结果集不为空，则EXISTS返回TRUE，否则返回FALSE。EXISTS还可与NOT结合使用，即NOT EXISTS，其返回值与EXISTS刚好相反。其格式为 [ NOT ] EXISTS ( subquery ) 【例4.32】 查找选修206号课程的学生姓名。 SELECT 姓名 FROM XSB WHERE EXISTS ( SELECT * FROM CJB WHERE 学号 = XSB.学号 AND 课程号 = '206' ) 其处理过程如下： 首先查找外层查询中XSB表的第一行，根据该行的学号列值处理内层查询，若结果不为空，则WHERE条件为真，就把该行的姓名值取出作为结果集的一行；然后再找XSB表的第2，3…行，重复上述处理过程直到XSB表的所有行都查找完为止。 【例4.33】 查找选修了全部课程的同学的姓名。 SELECT 姓名 FROM XSB WHERE NOT EXISTS ( SELECT * FROM KCB WHERE NOT EXISTS ( SELECT * FROM CJB WHERE 学号=XSB.学号 AND 课程号=KCB.课程号 ) ) 另外，子查询还可以用在SELECT语句的其他子句中，如FROM子句。 SELECT关键字后面也可以定义子查询。 【例4.34】 从XSB表中查找所有女学生的姓名、学号及其与081101号学生的年龄差距。 SELECT 学号, 姓名, YEAR(出生时间)-YEAR( ( SELECT 出生时间 FROM XSB WHERE 学号='081101' ) ) AS 年龄差距 FROM XSB WHERE 性别=0 执行结果如下： "},"page/11273.html":{"url":"page/11273.html","title":"MSSQL连接查询","keywords":"","body":"MSSQL 前面嵌套都可转化为连接 1．连接谓词 可以在SELECT语句的WHERE子句中使用比较运算符给出连接条件对表进行连接，将这种表示形式称为连接谓词表示形式。 【例4.42】 查找PXSCJ数据库每个学生的情况以及选修的课程情况。 USE PXSCJ GO SELECT XSB.* , CJB.* // .字段名，*所有字段 FROM XSB , CJB WHERE XSB.学号 = CJB.学号 // 表.字段 重复一定有，唯一可以省略 结果表将包含XSB表和CJB表的所有列。 【例4.43】 自然连接查询。 SELECT XSB.* , CJB.课程号, CJB.成绩 FROM XSB , CJB WHERE XSB.学号= CJB.学号 本例所得的结果表包含以下字段：学号、姓名、性别、出生时间、专业、总学分、备注、课程号、成绩。 若选择的字段名在各个表中是唯一的，则可以省略字段名前的表名。例如，本例的SELECT语句也可写为： SELECT XSB.* , 课程号, 成绩 FROM XSB , CJB WHERE XSB.学号 = CJB.学号 【例4.44】 查找选修了206号课程且成绩在80分以上的学生姓名及成绩。 SELECT 姓名, 成绩 FROM XSB , CJB WHERE XSB.学号 = CJB.学号 AND 课程号 = '206' AND 成绩 >= 80 //先筛选符合条件，再和xsb连接 执行结果如下： 【例4.45】 查找选修了“计算机基础”课程且成绩在80分以上的学生学号、姓名、课程名及成绩。 SELECT XSB.学号, 姓名, 课程名, 成绩 FROM XSB , KCB , CJB WHERE XSB.学号 = CJB.学号 AND KCB.课程号 = CJB.课程号 AND 课程名 = '计算机基础' AND 成绩 >= 80 执行结果如下： 2．以JOIN关键字指定的连接 T-SQL扩展了以JOIN关键字指定连接的表示方式，使表的连接运算能力有了增强。FROM子句的表示将多个表连接起来。 格式如下。 ::= { ON | CROSS JOIN | left_table_source { CROSS | OUTER } APPLY right_table_source | [ ( ) [ ] ] } 说明如下。 ：准备要连接的表。 表示连接类型。 的格式为 ::= [ { INNER | { { LEFT | RIGHT | FULL } [ OUTER ] } } [ ] ] JOIN 其中，INNER表示内连接，OUTER表示外连接，是连接提示。 ON：用于指定连接条件，为连接的条件。 APPLY运算符：使用APPLY运算符可以为实现查询操作的外部表表达式返回的每个行调用表值函数。left_table_source为外部表值表达式，right_table_source为表值函数。通过对right_table_source求值来获得left_table_source每一行的计算结果，生成的行被组合起来作为最终输出。APPLY 运算符生成的列的列表是left_table_source中的列集，后跟right_table_source返回的列的列表。CROSS APPLY仅返回外部表中通过表值函数生成结果集的行。OUTER APPLY既返回生成结果集的行，也返回不生成结果集的行。 CROSS JOIN：表示交叉连接。 #（1）内连接。 指定了INNER关键字的连接是内连接，内连接按照ON所指定的连接条件合并两个表，返回满足条件的行。 【例4.46】 查找PXSCJ数据库每个学生的情况以及选修的课程情况。 SELECT * FROM XSB INNER JOIN CJB ON XSB.学号 =CJB.学号 执行的结果将包含XSB表和CJB表的所有字段（不去除重复字段——学号）。 内连接是系统默认的，可以省略INNER关键字。使用内连接后仍可使用WHERE子句指定条件。 【例4.47】 用FROM子句的JOIN关键字表达下列查询：查找选修了206号课程且成绩在80分以上的学生姓名及成绩。 SELECT 姓名, 成绩 FROM XSB JOIN CJB ON XSB.学号 = CJB.学号 WHERE 课程号 = '206' AND 成绩>=80 执行结果如下： 【例4.48】 用FROM子句的JOIN关键字表达下列查询：查找选修了“计算机基础”课程且成绩在80分以上的学生学号、姓名、课程名及成绩。 SELECT XSB.学号, 姓名, 课程名, 成绩 FROM XSB JOIN CJB JOIN KCB ON CJB.课程号 = KCB.课程号 ON XSB.学号 = CJB.学号 WHERE 课程名= ‘计算机基础’ AND 成绩>=80 若要在一个表中查找具有相同列值的行，则可以使用自连接。使用自连接时需为表指定两个别名，且对所有列的引用均要用别名限定。 【例4.49】 查找不同课程成绩相同的学生的学号、课程号和成绩。 SELECT a.学号, a.课程号, b.课程号, a.成绩 FROM CJB a JOIN CJB b ON a.成绩=b.成绩 AND a.学号=b.学号 AND a.课程号!=b.课程号 第三个条件约束的是课程不一样 执行结果如下： （2）外连接。 指定了OUTER关键字的为外连接，外连接的结果表不但包含满足连接条件的行，还包括相应表中的所有行。外连接包括以下三种。 左外连接（LEFT OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括左表的所有行； 右外连接（RIGHT OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括右表的所有行； 完全外连接（FULL OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括两个表的所有行。 其中的OUTER关键字均可省略。 【例4.50】 查找所有学生情况，以及他们选修的课程号，若学生未选修任何课，也要包括其情况。 SELECT XSB.* , 课程号 FROM XSB LEFT OUTER JOIN CJB ON XSB.学号 = CJB.学号 本例执行时，若有学生未选任何课程，则结果表中相应行的课程号字段值为NULL。 【例4.51】 查找被选修了的课程的选修情况和所有开设的课程名。 SELECT CJB.* , 课程名 FROM CJB RIGHT JOIN KCB ON CJB.课程号= KCB.课程号 （3）交叉连接。 交叉连接实际上是将两个表进行笛卡尔积运算，结果表是由第一个表的每一行与第二个表的每一行拼接后形成的表，因此结果表的行数等于两个表的行数之积。 【例4.52】 列出学生所有可能的选课情况。 SELECT 学号, 姓名, 课程号, 课程名 FROM XSB CROSS JOIN KCB 交叉连接也可以使用WHERE子句进行条件限定。 "},"page/11035.html":{"url":"page/11035.html","title":"GROUP BY","keywords":"","body":"GROUP BY "},"page/11270.html":{"url":"page/11270.html","title":"MSSQL","keywords":"","body":"MSSQL 1．ISO标准的GROUP BY子句 语法格式如下。 GROUP BY { | ROLLUP ( ) | CUBE (>) | GROUPING SETS ( ) } 说明如下。 ：指定分组的字段名表达式。 ROLLUP()：生成简单的GROUP BY聚合行、小计行或超聚合行，还生成一个总计行，返回的分组数等于中的表达式数加一，功能与非ISO标准语法中的WITH ROLLUP子句类似。 CUBE()：生成简单的GROUP BY 聚合行、ROLLUP超聚合行和交叉表格行。CUBE针对中表达式的所有排列输出一个分组。生成的分组数等于2n，其中，n 为中的表达式数，功能与WITH CUBE子句类似。 GROUPING SETS()：在一个查询中指定数据的多个分组。仅聚合指定组，而不聚合由CUBE或ROLLUP生成的整组聚合。其结果与针对指定的组执行UNION ALL运算等效。GROUPING SETS可以包含单个元素或元素列表。 设置数据库的兼容级别可以使用ALTER DATABASE语句，语法格式如下： ALTER DATABASE database_name SET COMPATIBILITY_LEVEL = { 80 | 90 | 100 } 80、90和100分别代表SQL Server 2000、SQL Server 2005和SQL Server 2008。所以需要将PXSCJ数据库的兼容级别设置成100，使用如下语句： ALTER DATABASE PXSCJ SET COMPATIBILITY_LEVEL=100 另外，还可以使用界面方式完成，方法如下： 打开数据库PXSCJ的“属性”窗口，选择“选项”选项卡，在窗口右边的“兼容级别”下拉框中选择“SQL Server 2008(100)”，如图4.6所示，单击“确定”按钮即可。 设置数据库兼容级别 【例4.59】 在PXSCJ数据库上产生一个结果集，包括每个专业的男生、女生人数、总人数及学生总人数。 SELECT 专业, 性别 , COUNT(*) AS '人数' FROM XSB GROUP BY ROLLUP(专业,性别) 执行结果如下： 【例4.60】 在PXSCJ数据库上产生一个结果集，包括每个专业的男生、女生人数、总人数，以及男生总数、女生总数、学生总人数。 SELECT 专业, 性别, COUNT(*) AS '人数' FROM XSB GROUP BY CUBE(专业,性别) 执行结果如下： 【例4.61】 生成一个结果集，分别根据专业和性别对人数进行聚合。 SELECT 专业, 性别, COUNT(*) AS '人数' FROM XSB GROUP BY GROUPING SETS(专业,性别) 执行结果如下： 2．非ISO标准的GROUP BY子句 语法格式如下。 [ GROUP BY [ ALL ] group_by_expression [,…n] [ WITH { CUBE | ROLLUP } ] ] 说明如下。 group_by_expression：用于分组的表达式，其中通常包含字段名。指定ALL将显示所有组。使用GROUP BY子句后，SELECT子句中的列表中只能包含在GROUP BY中指出的列或在聚合函数中指定的列。 WITH：指定CUBE或ROLLUP操作符，CUBE或ROLLUP与聚合函数一起使用，在查询结果中增加附加记录。 【例4.53】 将PXSCJ数据库中各专业输出。 SELECT 专业 FROM XSB GROUP BY 专业 执行结果如下： 【例4.54】 求各专业的学生数。 SELECT 专业, COUNT(*) AS '学生数' FROM XSB GROUP BY 专业 执行结果如下： 【例4.55】 求被选修的各门课程的平均成绩和选修该课程的人数。 各，必然是分组，个后面是什么。就什么分组 group by 什么 SELECT 课程号, AVG(成绩) AS '平均成绩' , COUNT(学号) AS '选修人数' FROM CJB GROUP BY 课程号 执行结果如下： 【例4.56】 在PXSCJ数据库上产生一个结果集，包括每个专业的男生、女生人数、总人数及学生总人数。 SELECT 专业, 性别 , COUNT(*) AS '人数' FROM XSB GROUP BY 专业,性别 WITH ROLLUP 执行结果如下： 可以将上述语句与不带ROLLUP操作符的GROUP BY子句的执行情况做一个比较： SELECT 专业, 性别, COUNT(*) AS '人数' FROM XSB GROUP BY 专业,性别 执行结果如下： 【例4.57】 在PXSCJ数据库上产生一个结果集，包括每个专业的男生、女生人数、总人数，以及男生总数、女生总数、学生总人数。 SELECT 专业, 性别, COUNT(*) AS '人数' FROM XSB GROUP BY 专业,性别 WITH CUBE 执行结果如下： 使用带有CUBE或ROLLUP的GROUP BY子句时，SELECT子句的列表还可以是聚合函数GROUPING。若需要标志结果表中哪些行是由CUBE或ROLLUP添加的而哪些行不是，则可使用GROUPING函数作为输出列。 【例4.58】 统计各专业男生、女生人数及学生总人数，标志汇总行。 SELECT 专业, 性别, COUNT(*) AS '人数', GROUPING(专业) AS 'spec', GROUPING(性别) AS 'sx' FROM XSB GROUP BY 专业,性别 WITH CUBE 执行结果如下： "},"page/11036.html":{"url":"page/11036.html","title":"HAVING","keywords":"","body":"HAVING "},"page/11271.html":{"url":"page/11271.html","title":"MSSQL","keywords":"","body":"MSSQL HAVING子句的格式为 [ HAVING ] 其中，search_condition为查询条件，与WHERE子句的查询条件类似，不过HAVING子句中可以使用聚合函数，而WHERE子句中不可以。 where是一行一行看的没法聚合 例如，查找PXSCJ数据库中平均成绩在85分以上的学生，就是在CJB表上按学号分组后筛选出符合平均成绩大于等于85的学生。 【例4.62】 查找平均成绩在85分以上的学生的学号和平均成绩。 USE PXSCJ GO SELECT 学号, AVG(成绩) AS '平均成绩' FROM CJB GROUP BY 学号 HAVING AVG(成绩) > =85 执行结果如下： 【例4.63】 查找选修课程超过2门且成绩都在80分以上的学生的学号。 SELECT 学号 FROM CJB WHERE 成绩 >= 80 GROUP BY 学号 HAVING COUNT(*) > 2 【例4.64】 查找通信工程专业平均成绩在85分以上的学生的学号和平均成绩。 SELECT 学号, AVG(成绩) AS '平均成绩' FROM CJB WHERE 学号 IN ( SELECT 学号 FROM XSB WHERE 专业 = '通信工程' ) GROUP BY 学号 HAVING AVG(成绩) > =85 执行结果如下： "},"page/11037.html":{"url":"page/11037.html","title":"ORDER BY","keywords":"","body":"ORDER BY "},"page/11272.html":{"url":"page/11272.html","title":"MSSQL","keywords":"","body":"MSSQL ORDER BY子句 在应用中经常要对查询的结果排序输出，如将学生成绩由高到低排序。在SELECT语句中，使用ORDER BY子句对查询结果进行排序。ORDER BY子句的格式为 [ ORDER BY { order_by_expression [ COLLATE collation_name ] [ ASC | DESC ] } [ ,...n ] ] 【例4.65】 将通信工程专业的学生按出生时间先后顺序排序。 SELECT * FROM XSB WHERE 专业= '通信工程' ORDER BY 出生时间 【例4.66】 将计算机专业学生的“计算机基础”课程成绩按降序排列。 SELECT 姓名, 课程名, 成绩 FROM XSB, KCB, CJB WHERE XSB.学号 = CJB.学号 AND CJB.课程号 = KCB.课程号 AND 课程名= '计算机基础' AND 专业= '计算机' ORDER BY 成绩 DESC ORDER BY子句可以与COMPUTE BY子句一起使用，在对结果排序的同时还产生附加的汇总行。COMPUTE子句用于分类汇总，将产生额外的汇总行。格式为 [ COMPUTE { 聚合函数名(expression)} [ ,…n ] [ BY expression [ ,…n ] ] ] 【例4.67】 查找通信工程专业学生的学号、姓名、出生时间，并产生一个学生总人数行。 SELECT 学号, 姓名, 出生时间 FROM XSB WHERE 专业= '通信工程' COMPUTE COUNT(学号) 执行结果如下： 【例4.68】 将学生按专业排序，并汇总各专业人数和平均学分。 SELECT 学号, 姓名, 出生时间, 总学分 FROM XSB ORDER BY 专业 COMPUTE COUNT(学号), AVG(总学分) BY 专业 执行结果如下： "},"page/11305.html":{"url":"page/11305.html","title":"其他","keywords":"","body":"其他 "},"page/11306.html":{"url":"page/11306.html","title":"MSSQL","keywords":"","body":"MSSQL SELECT语句的其他语法 　1．INTO 使用INTO子句可以将SELECT查询所得的结果保存到一个新建的表中。INTO子句的格式为 [ INTO new_table ] 其中，new_table是要创建的新表名。包含INTO子句的SELECT语句执行后所创建的表的结构由SELECT所选择的列决定，新创建的表中的记录由SELECT的查询结果决定，若SELECT的查询结果为空，则创建一个只有结构而没有记录的空表。 【例4.69】 由XSB表创建“计算机系学生”表，包括学号和姓名。 SELECT 学号, 姓名 INTO 计算机系学生 FROM XSB WHERE 专业= '计算机' 2．UNION 使用UNION子句可以将两个或多个SELECT查询的结果合并成一个结果集，其格式为 { | ( ) } UNION [ A LL ] | ( ) [ UNION [ A LL ] | ( ) […n] ] 其中，和都是SELECT查询语句。 使用UNION组合两个查询的结果集的基本规则是： （1）所有查询中的列数和列的顺序必须相同。 （2）数据类型必须兼容。 【例4.70】 查找学号为081101和学号为081210的两位同学的信息。 SELECT * FROM XSB WHERE 学号= '081101' UNION ALL SELECT * FROM XSB WHERE 学号= '081210' 执行结果如下： 3．EXCEPT 和 INTERSECT EXCEPT和INTERSECT用于比较两个查询的结果，返回非重复值。语法格式如下： { | ( ) } { EXCEPT | INTERSECT } { | ( ) } 其中，和都是SELECT查询语句。使用EXCEPT和INTERSECT比较两个查询的规则和UNION语句一样。 EXCEPT从EXCEPT关键字左边的查询中返回右边查询没有找到的所有非重复值。INTERSECT返回INTERSECT关键字左右两边的两个查询都返回的所有非重复值。 EXCEPT或INTERSECT返回的结果集的列名与关键字左侧的查询返回的列名相同。 【例4.71】 查找专业为计算机但性别不为男的学生信息。 USE PXSCJ GO SELECT * FROM XSB WHERE 专业= '计算机' EXCEPT SELECT * FROM XSB WHERE 性别=1 执行结果如下： 【例4.72】 查找总学分大于42且性别为男的学生信息。 SELECT * FROM XSB WHERE 总学分>42 INTERSECT SELECT * FROM XSB WHERE 性别=1 4．CTE 在SELECT语句的最前面可以使用一条WITH子句来指定临时结果集，语法格式如下： [ WITH [ ,...n ] ] 其中， ::= expression_name [ ( column_name [ ,...n ] ) ] AS ( CTE_query_definition ) 说明： expression_name是CTE的名称，column_name指定查询语句CTE_query_definition返回的数据字段名称，其个数要和CTE_query_definition返回的字段个数相同，若不定义，则直接命名查询语法的数据集合字段名称为返回数据的字段名称。CTE下方的SELECT语句可以直接查询CTE中的数据。 不允许在一个CTE中指定多个WITH子句。例如，如果CTE_query_definition包含一个子查询，则该子查询不能包括定义另一个CTE的嵌套的WITH子句。 【例4.73】 使用CTE从CJB表中查询选了101号课程的学生学号、成绩，并定义新的列名为number、point。再使用SELECT语句从CTE和XSB中查询姓名为“王林”的学生学号和成绩情况。 USE PXSCJ GO WITH cte_stu(number,point) AS (SELECT 学号,成绩 FROM CJB WHERE 课程号='101') SELECT number, point FROM cte_stu, XSB WHERE XSB.姓名='王林' AND XSB.学号=cte_stu.n 执行结果如下： 定位点成员必须与UNION ALL、INTERSECT或EXCEPT结合使用。在最后一个定位点成员和第一个递归成员之间，以及组合多个递归成员时，只能使用UNION ALL运算符。递归CTE中所有成员的数据字段必须完全一致。递归成员的FROM子句只能引用一次递归CTE的名称。在递归成员的CTE_query_definition中不允许出现下列项： 【例4.74】 计算数字1～10的阶乘。 WITH MyCTE(n,njc) AS ( SELECT n=1, njc=1 UNION ALL SELECT n=n+1, njc=njc*(n+1) FROM MyCTE WHERE n "},"page/11038.html":{"url":"page/11038.html","title":"连接查询","keywords":"","body":"连接查询 "},"page/11039.html":{"url":"page/11039.html","title":"子查询","keywords":"","body":"子查询 "},"page/11042.html":{"url":"page/11042.html","title":"数据控制语言DCL","keywords":"","body":"数据控制语言DCL "},"page/11301.html":{"url":"page/11301.html","title":"MSSQL数据控制语言DCL","keywords":"","body":"MSSQL数据控制语言DCL "},"page/11043.html":{"url":"page/11043.html","title":"事务管理与并发控制","keywords":"","body":"事务管理与并发控制 "},"page/11276.html":{"url":"page/11276.html","title":"MSSQL","keywords":"","body":"MSSQL 事务 事务与ACID属性 使用一个简单的例子来帮助理解事务：向公司添加一名新的雇员（见图12.1）。这里的过程由三个基本步骤组成：在雇员数据库中为雇员创建一条记录；为雇员分配部门；建立雇员的工资记录。如果这三步中的任何一步失败，如为新成员分配的雇员ID已经被其他人使用或者输入到工资系统中的值太大，系统就必须撤销在失败之前所有的变化，删除所有不完整记录的踪迹，避免以后的不一致和计算失误。前面的三项任务构成了一个事务。任何一个任务的失败都会导致整个事务被撤销，而使系统返回到以前的状态。 在形式上，事务是由ACID属性标识的。术语“ACID”是一个简称，每个事务的处理必须满足ACID原则，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。 （1）原子性。原子性意味着每个事务都必须被认为是一个不可分割的单元。假设一个事务由两个或者多个任务组成，其中的语句必须同时成功，才能认为事务是成功的。如果事务失败，系统将会返回到事务以前的状态。 在添加雇员这个例子中，原子性指如果没有创建雇员相应的工资表和部门记录，就不可能向雇员数据库添加雇员。 原子的执行是一个或者全部发生或者什么也没有发生的命题。在一个原子操作中，如果事务中的任何一个语句失败，前面执行的语句都将返回，以保证数据的整体性没有受到影响。这在一些关键系统中尤其重要，现实世界的应用程序（如金融系统）执行数据输入或更新，必须保证不出现数据丢失或数据错误，以保证数据安全性。 （2）一致性。不管事务是完全成功完成还是中途失败，当事务使系统中的所有数据处于一致的状态时存在一致性。参照前面的例子，一致性是指，如果从系统中删除了一个雇员，则所有和该雇员相关的数据，包括工资数据和组的成员资格也要被删除。 （3）隔离性。隔离性是指，每个事务在它自己的空间发生，和其他发生在系统中的事务隔离，而且事务的结果只有在它完全被执行时才能看到。即使在这样的一个系统中同时发生了多个事务，隔离性原则也保证某个特定事务在完全完成之前，其结果是看不见的。 当系统支持多个同时存在的用户和连接时（如SQL Server），这就尤其重要。如果系统不遵循这个基本规则，就可能导致大量数据的破坏，如每个事务各自空间的完整性很快地被其他冲突事务所侵犯。 （4）持久性。持久性意味着，一旦事务执行成功，在系统中产生的所有变化将是永久的。即使系统崩溃，一个提交的事务仍然存在。当一个事务完成，数据库的日志已经被更新时，持久性就开始发生作用了。大多数RDBMS产品通过保存所有行为的日志来保证数据的持久性，这些行为是指在数据库中以任何方法更改数据。数据库日志记录了所有对于表的更新、查询、报表等。 多用户使用的问题 丢失更新（lost update）指，当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，因此最后的更新将重写由其他事务所做的更新，这将导致数据丢失。 脏读（dirty read）指，一个事务正在访问数据，而其他事务正在更新该数据，但尚未提交，此时就会发生脏读问题，即第一个事务所读取的数据是“脏”（不正确）数据，它可能会引起错误。 当一个事务多次访问同一行而且每次读取不同的数据时，会发生不可重复读（unrepeatable read）问题。不可重复读与脏读有相似之处，因为该事务也是正在读取其他事务正在更改的数据。当一个事务访问数据时，另外的事务也访问该数据并对其进行修改，因此就发生了由于第二个事务对数据的修改而导致第一个事务两次读到的数据不一样的情况，这就是不可重复读。 当一个事务对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻读（phantom read）问题。事务第一次读的行范围显示出其中一行已不复存在于第二次读或后续读中，因为该行已被其他事务删除。同样，由于其他事务的插入操作，事务的第二次读或后续读显示有一行已不存在于原始读中。 事务处理 SQL Server 2008中的事务可以分为两类：系统提供的事务和用户定义的事务。 系统提供的事务是在执行某些T-SQL语句时，一条语句就构成了一个事务，这些语句包括ALTER TABLE、CREATE、DELETE、DROP、FETCH、GRANT、INSERT、OPEN、REVOKE、SELECT、UPDATE、TRUNCATE TABLE。 例如，执行如下创建表的语句： CREATE TABLE xxx ( f1 int NOT NULL, f2 char(10) NOT NULL, f3 varchar(30) NULL ) 在实际应用中，大量使用的是用户自定义的事务。用户自定义事务的定义方法主要有以下几个步骤。 1．开始事务 在SQL Server中，显式地开始一个事务可以使用BEGIN TRANSACTION语句。 语法格式： BEGIN { TRAN | TRANSACTION } [ { transaction_name | @tran_name_variable } [ WITH MARK [ 'dEscription' ] ] ] [ ; ] 2．结束事务 COMMIT TRANSCATION语句是提交语句，它将事务开始以来所执行的所有数据都修改成为数据库的永久部分，也标志一个事务的结束，其语法格式为 COMMIT { TRAN | TRANSACTION } [ transaction_name | @tran_name_variable ] ] [ ; ] 标志一个事务的结束也可以使用COMMIT WORK语句。语法格式为 COMMIT [WORK] 此语句的功能与COMMIT TRANSACTION相同，但COMMIT TRANSACTION接受用户定义的事务名称，而COMMIT WORK不带参数。 3．撤销事务 若要结束一个事务，可以使用ROLLBACK TRANSACTION语句。它使得事务回滚到起点，撤销自最近一条BEGIN TRANSACTION语句以后对数据库的所有更改，同时也标志了一个事务的结束。 语法格式： ROLLBACK { TRAN | TRANSACTION } [ transaction_name | @tran_name_variable ] [ ; ] ROLLBACK TRANSACTION语句不能在COMMIT语句之后。 另外，一条ROLLBACK WORK语句也能撤销一个事务，功能与ROLLBACK TRANSACTION语句一样，但ROLLBACK TRANSACTION语句接受用户定义的事务名称。 语法格式： ROLLBACK [ WORK ] [ ; ] 4．回滚事务 ROLLBACK TRANSACTION语句除了能够撤销整个事务，还可以使事务回滚到某个点，不过在这之前需要使用SAVE TRANSACTION语句来设置一个保存点。 SAVE TRANSACTION的语法格式： SAVE { TRAN | TRANSACTION } { savepoint_name | @savepoint_variable } [ ; ] SAVE TRANSACTION语句会向已命名的保存点回滚一个事务。如果在保存点被设置后，当前事务对数据进行了更改，则这些更改会在回滚中被撤销。语法格式为 ROLLBACK { TRAN | TRANSACTION } [ savepoint_name | @savepoint_variable ] [ ; ] 其中，savepoint_name是SAVE TRANSACTION语句中的savepoint_name。在事务中允许有重复的保存点名称，但指定保存点名称的ROLLBACK TRANSACTION语句只将事务回滚到使用该名称的最近的SAVE TRANSACTION。 下面几个语句说明了有关事务的处理过程： ① BEGIN TRANSACTION mytran1 ② UPDATE … ③ DELETE… ④ SAVE TRANSACTION S1 ⑤ DELETE… ⑥ ROLLBACK TRANSACTION S1; ⑦ INSERT… ⑧ COMMIT TRANSACTION 【例11.1】 定义一个事务，向PXSCJ数据库的XSB表添加一行数据，然后删除该行数据；但执行后，新插入的数据行并没有删除，因为事务中使用了ROLLBACK语句将操作回滚到保存点My_sav，即删除前的状态。 BEGIN TRANSACTION My_tran USE PXSCJ INSERT INTO XSB VALUES('081115', '胡新华', 1, '1991-06-27', '计算机', 50, NULL) SAVE TRANSACTION My_sav DELETE FROM XSB WHERE 学号='081115' ROLLBACK TRAN My_sav COMMIT WORK GO 执行完上述语句后使用SELECT语句查询XSB表中的记录： SELECT * FROM XSB WHERE 学号='081115' 执行结果如下： 事务隔离级 在SQL Server 2008中，可以使用SET TRANSACTION ISOLATION LEVEL语句来设置事务的隔离级别。 语法格式： SET TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SNAPSHOT | SERIALIZABLE } [ ; ] （1）未提交读。未提交读提供了事务之间最小限度的隔离，允许脏读，但不允许丢失更新。如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读取此行数据。该隔离级别可以通过“排他锁”实现。 （2）提交读。提交读是SQL Server 2008默认的隔离级别，处于这一级的事务可以看到其他事务添加的新记录，而且其他事务对现存记录做出的修改一旦被提交，也可以看到。也就是说，这意味着在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个SELECT语句可能返回不同的结果。提交读允许不可重复读取，但不允许脏读。该隔离级别可以通过“共享锁”和“排他锁”实现。 （3）可重复读。处于这一级的事务禁止不可重复读取和脏读取，但是有时可能出现幻读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 （4）快照。处于这一级别的事务只能识别在其开始之前提交的数据修改。在当前事务中执行的语句将看不到在当前事务开始以后由其他事务所做的数据修改。其效果就好像事务中的语句获得了已提交数据的快照，因为该数据在事务开始时就存在。必须在每个数据库中将ALLOW_SNAPSHOT_ISOLATION数据库选项设置为ON，才能开始一个使用SNAPSHOT隔离级别的事务。设置的方法如下： ALTER DATABASE database_name SET ALLOW_SNAPSHOT_ISOLATION ON （5）序列化。序列化是隔离事务的最高级别，提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于大多数应用程序，可以优先考虑把数据库的隔离级别设为READ COMMITTED，它能够避免脏取，而且具有较好的并发性能。 下面就PXSCJ数据库的隔离级别设置做一个简单示范，在SSMS中打开两个“查询分析器”窗口，在第一个窗口中执行如下语句，更新课程表KCB中的信息： USE PXSCJ GO begin tran update KCB set 课程名='计算机导论' where 课程号='101' 由于代码中并没有执行COMMIT语句，所以数据变动操作实际上还没有最终完成。接下来，在另一个窗口里执行下列语句查询KCB表中的数据： SELECT * FROM KCB “结果”窗口中将不显示任何查询结果，窗口底部提示“正在执行查询…”。出现这种情况的原因是PXSCJ数据库的默认隔离级别是READ COMMITTED，若一个事务更新了数据，但事务尚未结束，这时就发生了脏读的情况。 在第一个窗口中使用ROLLBACK语句回滚以上操作。这时使用SET语句设置事务的隔离级别为READ UNCOMMITTED，执行如下语句： SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED 锁定 锁定粒度 在SQL Server中，可被锁定的资源从小到大分别是行、页、扩展盘区、表和数据库，被锁定的资源单位称为锁定粒度。可见，上述5种资源单位其锁定粒度是由小到大排列的。锁定粒度不同，系统的开销将不同，并且锁定粒度与数据库访问并发度是一对矛盾，锁定粒度大，系统开销小，但并发度会降低；锁定粒度小，系统开销大，但并发度可提高。 锁定模式 （1）排他锁。排他锁可以防止并发事务对资源进行访问。其他事务不能读取或修改排他锁锁定的数据。 （2）共享锁。共享锁允许并发事务读取一个资源。当一个资源上存在共享锁时，任何其他事务都不能修改数据。一旦读取数据完毕，资源上的共享锁便立即释放，除非将事务隔离级别设置为可重复读或更高级别，或者在事务生存周期内用锁定提示保留共享锁。 （3）更新锁。更新锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享锁，然后修改行，此操作要求锁转换为排他锁。如果两个事务获得了资源上的共享锁，然后试图同时更新数据，则其中的一个事务将尝试把锁转换为排他锁。共享模式到排他锁的转换必须等待一段时间，因为一个事务的排他锁与其他事务的共享锁不兼容，这就是锁等待。第二个事务试图获取排他锁以进行更新。由于两个事务都要转换为排他锁，并且每个事务都等待另一个事务释放共享锁，因此会发生死锁，这就是潜在的死锁问题。 要避免这种情况的发生，可使用更新锁。一次只允许有一个事务可获得资源的更新锁，如果该事务要修改锁定的资源，则更新锁将转换为排他锁；否则为共享锁。 （4）意向锁。意向锁表示SQL Server需要在层次结构中的某些底层资源（如表中的页或行）上获取共享锁或排他锁，例如，放置在表级的共享意向锁表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排他锁。意向锁可以提高性能，因为SQL Server仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。 意向锁包括意向共享（IS）、意向排他（IX）以及与意向排他共享（ISX）。 意向共享锁：通过在各资源上放置共享锁，表明事务的意向是读取层次结构中的部分底层资源。 意向排他锁：通过在各资源上放置排他锁，表明事务的意向是修改层次结构中部分底层资源。 意向排他共享锁：通过在各资源上放置意向排他锁，表明事务的意向是读取层次结构中的全部底层资源并修改部分底层资源。 （5）键范围锁。键范围锁用于序列化的事务隔离级别，可以保护由T-SQL语句读取的记录集合中隐含的行范围。键范围锁可以防止幻读，还可以防止对事务访问的记录集进行幻像插入或删除。 （6）架构锁。执行表的数据定义语言操作（如增加列或删除表）时使用架构修改锁。 当编译查询时，使用架构稳定性锁。架构稳定性锁不阻塞任何事务锁，包括排他锁。因此在编译查询时，其他事务（包括在表上有排他锁的事务）都能继续运行，但不能在表上执行DDL操作。 （7）大容量更新锁。当将数据大容量复制到表，且指定了TABLOCK提示或者使用sp_tableoption设置了table lock on bulk表选项时，将使用大容量更新锁。大容量更新锁允许进程将数据并发地大容量复制到同一表，同时可防止其他不进行大容量复制数据的进程访问该表。 SQL Server 2008自动化管理 在SQL Server 2008中要进行自动化管理，需要按以下步骤进行操作： （1）确定哪些管理任务或服务器事件定期执行，以及这些任务或事件是否可以通过编程方式进行管理。 （2）使用自动化管理工具定义一组作业、计划、警报和操作员。 （3）运行已定义的SQL Server代理作业。 SQL Server 2008自动化管理能够实现以下几种管理任务： （1）任何T-SQL语法中的语句； （2）操作系统命令； （3）VBScript或JavaScript之类的脚本语言； （4）复制任务； （5）数据库创建和备份； （6）索引重建； （7）报表生成。 SQL Server代理 SQL Server代理服务启动以后需要正确配置SQL Server代理。SQL Server代理的配置信息主要保存在系统数据库msdb的表中，使用SQL Server用户对象来存储代理的身份验证信息。在SQL Server中，必须将SQL Server代理配置为使用sysadmin固定服务器角色成员的账户，才能执行其功能。该账户必须拥有以下Windows权限： 调整进程的内存配额； 以操作系统方式操作； 跳过遍历检查； 作为批处理作业登录； 作为服务登录； 替换进程级记号。 如果需要验证账户是否已经设置了所需的Windows权限，可以通过以下步骤进行： （1）单击“开始”菜单，选择“程序→管理工具→本地安全策略”。 （2）在弹出的“本地安全设置”窗口中，选择“本地策略→用户权利指派”。 （3）在右侧的权限列表中右击一个权限选项，如“作为服务器登录”，选择“属性”菜单项，如图11.1所示。在打开的“属性”窗口中，从列表中查看要设置的SQL Server代理的账户是否存在，如图11.2所示。 （4）如果账户不在列表中，单击“添加用户或组”按钮，在打开的“选择用户或组”对话框中添加SQL Server代理服务账户，再单击“确定”按钮返回。 （5）重复上述操作，对权限列表中的其他选项进行相同的设置。 通常情况下，为SQL Server代理选择的账户都是为此目的创建的域账户，并且有严格控制的访问权限。使用域账户不是必需的，但是如果使用本地计算机上的账户，那么SQL Server代理就没有权限访问其他计算机上的资源。SQL Server需要访问其他计算机的情况很常见，例如，当它在另一台计算机上的某个位置创建数据库备份和存储文件时。 操作员 每一个操作员都必须具有一个唯一的名称，操作员的联系信息决定了通知操作员的方式。通知方式有以下3种： （1）电子邮件通知。电子邮件通知是向操作员发送电子邮件。对于电子邮件通知，需要提供操作员的电子邮件地址；但是若要使用数据库邮件发送电子邮件，则必须具有访问支持SMTP的电子邮件服务器的权限。若要使用SQL Mail功能发送电子邮件，则必须具有访问Exchange服务器的权限，必须在运行SQL Server的计算机上安装Outlook和Exchange Client。 （2）寻呼通知。寻呼是通过电子邮件实现的。对于寻呼通知，需要提供操作员接收寻呼消息的电子邮件地址。若要设置寻呼通知，就必须在邮件服务器上安装软件，处理入站邮件并将其转换为寻呼消息。 （3）net send通知。此方式通过net send命令向操作员发送消息。对于net send，需要指定网络消息的收件人（计算机或用户）。 创建操作员的步骤如下。 第1步：使用系统管理员身份连接SQL Server，启动SQL Server Management Studio，查看SQL Server代理服务是否运行，如果未运行，则右击“SQL Server代理”，选择“启动”菜单项启动SQL Server代理服务。如果服务已经运行，则展开“SQL Server代理”，右击“操作员”节点，选择“新建操作员”菜单项。 第2步：进入“新建操作员”窗口，在“姓名”文本框中输入操作员名称，如tao；在“电子邮件名称”文本框中输入通知操作员的电子邮件，如tao@163.com。如果需要指定net send通知，则可以在“Net Send”文本框中输入计算机名。如果操作员携带了可以接收电子邮件的传呼机，则可以在“寻呼电子邮件名称”文本框中输入电子邮件。 第3步：在“寻呼值班计划”栏中，可以选择操作员接收通知的时间。例如，选择“星期一”复选框，并设置“工作日开始时间”和“工作日结束时间”，如图11.3所示，则操作员将在每个星期一的这个时间段接到通知。 第4步：设置完后单击“确定”按钮完成操作员的创建。 作业 第1步：启动SQL Server Management Studio，在“对象资源管理器”窗口中展开“SQL Server代理”，右击“作业”，选择“新建作业”菜单项，打开“新建作业”窗口。 第2步：选择“常规”选项卡，在“名称”文本框中输入要定义的作业名称，如“创建并备份数据库”。“所有者”使用默认值。在“类别”下拉框中选择当前作业的类别，如“数据库维护”，如图11.4所示，默认是“未分类（本地）”。“说明”框中可以输入对作业的描述信息。 第3步：选择“步骤”选项卡，在右侧单击“新建”按钮，弹出“新建作业步骤”窗口。在窗口中的“步骤名称”文本框中定义一个作业步骤的名称，如“新建数据库”。在“类型”下拉框中选择作业步骤的类型，这里选择“Transact-SQL脚本（T-SQL）”。如果作业步骤是对数据库直接操作，则可以在“数据库”下拉框中选择目标数据库，这里使用默认值。在“命令”文本框中输入创建新数据库的T-SQL语句，如图11.5所示。 第4步：在“新建作业步骤”窗口中可以单击“分析”按钮分析SQL命令的正确性，如果语句正确则选择“高级”选项卡，可以设置“成功时要执行的操作”和“失败时要执行的操作”，这里使用默认值。单击“确定”按钮返回。 第5步：返回“新建作业”窗口后，窗口中的“作业步骤列表”中将显示刚刚新建的作业步骤。这时可以再单击“新建”按钮，添加备份数据库的作业步骤（过程略），新建后的作业步骤如图11.6所示。 第6步：选择“计划”选项卡，单击“新建”按钮，弹出“新建作业计划”窗口，如图11.7所示。在窗口中，在“名称”文本框中输入要创建的作业计划的名称。在“计划类型”下拉框中可以选择“重复执行”、“执行一次”等选项。如果选择“重复执行”，还可以设置执行的频率、持续时间等选项。如果选择“执行一次”，可以设置具体的执行时间。设置完成后单击“确定”按钮返回“新建作业”窗口。 第7步：选择“通知”选项卡，选择作业完成时要执行的操作。例如，可以选择“电子邮件”复选框，在后面的第一个下拉框中选择要通知的操作员，如tao。在第二个下拉框中选择通知操作员的时机，如果选择了“当作业完成时”选项则包括“当作业成功时”和“当作业失败时”。如图11.8所示，这样设置以后，在作业完成时可以使用电子邮件通知方式通知操作员。其他的选项可以根据用户需要自行设置，例如，如果需要在作业运行之后就将该作业删除，可以选择“自动删除作业”复选框。 第8步：单击“确定”按钮完成作业的创建。此后，作业会按照之前的设定开始按计划执行。如果要查看作业的执行情况，可以展开“SQL Server代理”的“作业”节点，右击刚刚创建的作业“创建并备份数据库”，选择“查看历史记录”菜单项，在“日志文件查看器”窗口中即可查看作业执行的历史记录。 警报 1．事件警报 要创建基于SQL Server事件的警报，必须先把错误写到Windows事件日志上，因为SQL Server代理会从该事件日志上读取错误信息。一旦SQL Server代理读取了该事件日志并检测到了新错误，就会搜索整个数据库，查找匹配的警报。当这个代理发现匹配的警报时，该警报立即被激活，进而可以通知操作员，执行作业或者同时做这两件事情。可以指定一个警报响应一个或多个事件。 可以使用下列参数来指定触发警报的SQL Server事件： （1）错误号。SQL Server代理在发生特定错误时发出警报。例如，可以指定错误号2571来响应未经授权就尝试调用数据库控制台命令（DBCC）的操作。 （2）严重级别。SQL Server代理在发生特定级别的严重错误时发出警报。例如，可以指定严重级别15来响应T-SQL语句中的语法错误。SQL Server中的每个错误都有一个关联的严重级别，用于指示错误的严重程度。表11.1中列出了常见的错误严重级别及说明。 （3）数据库。SQL Server代理仅在特定数据库中发生事件时才发出警报。此选项是对错误号或严重级别的补充。例如，如果实例中包含一个用于生产的数据库和一个用于报告的数据库，可以定义仅响应生产数据库中的语法错误的警报。 （4）事件文本。SQL Server代理在指定事件的事件消息中包含特定文本字符串时发出警报。例如，可以定义警报来响应包含特定表名或特定约束的消息。 SQL Server常见的错误严重级别及说明 级 别 说 明 是否写入应用程序日志 0~10 消息，不是错误 可选 11~16 用户错误，可纠正 可选 17 在服务器资源耗尽时产生的错误 可选 18 非致命的内部错误。语句将完成，并且用户连接将维持 可选 19 非可配置资源错误，产生这个错误的任何语句将被终止 是 20 当前数据库的一个单独进程遇到问题 是 21 当前数据库的所有进程都受到影响 是 22 正在使用的表或索引可能受到损坏 是 23 整个数据库遭到破坏 是 24 硬件发生故障 是 创建事件警报的具体步骤如下。 第1步：启动SQL Server Management Studio，以Windows系统管理员身份连接SQL Server 2008。在“对象资源管理器”窗口中，展开“SQL Server代理”，右击“警报”，选择“新建警报”菜单项，打开“新建警报”窗口。 第2步：在“新建警报”窗口的“常规”选项卡的“名称”文本框中输入要定义的警报名称，如“警报_PXSCJ”。如果要禁用该警报，则将“启用”复选框中的勾去掉，这里保持默认值。在“类型”下拉框中选择警报的类型为“SQL Server事件警报”。在“数据库名称”下拉框中选择警报作用于的数据库，这里选择“PXSCJ”。启用“错误号”单选按钮可以指定触发警报的错误号，如208，如图11.9所示。也可以启用“严重性”单选按钮，在后面的下拉框中可以指定触发警报的错误严重级别，如果选择的严重级别在19～25之间，就会向Windows应用程序日志发送SQL Server消息，并触发一个警报。 第3步：选择“响应”选项卡，启用“通知操作员”复选框，在操作员列表中选择警报激活后要通知的操作员，如tao，在其之后的复选框中选择通知方式，如图11.10所示。 第4步：选择“选项”选项卡，在“警报错误文本发送方式”下的复选框中选择发送警报的方式，如“电子邮件”和“Net Send”。 第5步：全部设置完成后单击“确定”按钮完成警报的创建。 在事件警报创建完成后，可以在“SQL Server代理”节点的“警报”目录下找到刚新建的警报“警报_PXSCJ”，右击该警报，选择“属性”菜单项，在“历史记录”选项卡中可以查看警报的响应时间和次数。 2．性能警报 创建性能警报的具体步骤如下。 第1步：打开“新建警报”窗口（步骤略），在“常规”选项卡的“名称”文本框输入警报名称，如“性能警报（tempdb）”。在“类型”下拉框中选择“SQL Server性能条件警报”选项，之后窗口中会出现性能条件警报要定义的选项。 第2步：在“对象”（要监视的性能区域）下拉框中选择“MSSQL$SQL2008:Databases”选项，在“计数器”（要监视的区域的属性）下拉框中选择“Log File(s) Used Size (KB)”选项，在“实例”（要监视的属性的特定实例）下拉框中选择“PXSCJ”，在“计数器满足以下条件时触发警报”选项的第一个下拉框中选择“高于”选项，在“值”文本框中输入5000，如图11.11所示。以上设置表示：为性能对象Databases设置当数据库PXSCJ的日志文件使用超过5000 KB时发出警报。当然，用户可以根据自己的需要定义性能条件警报。 第3步：在“响应”选项卡中设置要在警报激活时通知的操作员，在“选项”选项卡中设置警报错误的发送方式，这和设置事件警报的方法类似，这里不详细说明。最后单击“确定”按钮完成警报的创建。 3．WMI警报 Windows Management Instrumentation（Windows管理规范）是一项核心的Windows管理技术，用户可以使用WMI管理本地和远程计算机。WMI是一种规范和基础结构，通过它可以访问、配置、管理和监视几乎所有的Windows资源，比如用户可以在远程计算机上启动一个进程，设定一个在特定日期和时间运行的进程，远程启动计算机，获得本地或远程计算机的已安装程序列表，查询本地或远程计算机的Windows事件日志，等等。WMI警报就是指定发出警报来响应特定的WMI事件。创建WMI警报也是在“新建警报”窗口中进行的，这里不详细介绍。 数据库邮件 1．可靠性 （1）无需Microsoft Outlook或扩展消息处理应用程序编程接口（扩展 MAPI）。数据库邮件使用标准的简单邮件传输协议（SMTP）发送邮件，无须在运行SQL Server的计算机上安装扩展MAPI客户端便可以使用数据库邮件。 （2）进程隔离。若要最大程度地减小对SQL Server的影响，传递电子邮件的组件必须在SQL Server外围的单独进程中运行。 （3）故障转移账户。数据库邮件配置文件允许指定多台SMTP服务器。 （4）群集支持。数据库邮件与群集兼容，并且可以完全用于群集中。 2．灵活性 （1）后台传递。数据库邮件提供后台（或异步）传递。 （2）多个配置文件。数据库邮件允许在一个SQL Server实例中创建多个配置文件。 （3）多个账户。每个配置文件都可以包含多个故障转移账户。 （4）64位兼容性。数据库邮件完全可以用于采用64位安装的SQL Server。 3．安全性 （1）为了减少SQL Server的外围应用，在默认情况下，禁用数据库邮件存储过程。 （2）必须是msdb数据库中的DatabaseMailUserRole数据库角色的成员，才能发送数据库邮件。 （3）数据库邮件增强了邮件配置文件的安全性。 （4）数据库邮件增强了对附件文件大小的可配置限制。 （5）数据库邮件维护一个禁止的文件扩展名列表，用户无法附加扩展名为列表中某个扩展名的文件。 4．兼容性 （1）集成配置。数据库邮件在SQL Server数据库引擎中维护电子邮件账户的信息。SQL Server 2008的数据库邮件配置向导提供了十分方便的界面来配置数据库邮件，另外还可以使用Transact-SQL语句创建并维护数据库邮件的配置。 （2）日志记录。数据库邮件将电子邮件活动记录到SQL Server、Microsoft Windows应用程序事件日志和msdb数据库的表中。 （3）审核。数据库邮件将发送的邮件和附件的副本保留在msdb数据库中，用户可以轻松地审核数据库邮件的使用情况并检查保留的邮件。 （4）数据库邮件允许以HTML格式发送电子邮件。 第1步：启动SQL Server Management Studio，以系统管理员身份连接SQL Server。在“对象资源管理器”窗口中展开“管理”节点，右击“数据库邮件”，选择“配置数据库邮件”选项，弹出“配置数据库邮件向导”窗口。 第2步：单击“下一步”按钮进入“选择配置任务”窗口，如图11.12所示。按照默认选项单击“下一步”按钮，如果SQL Server未启用数据库邮件功能，则会弹出“是否启用此功能”对话框，单击“是”按钮启用数据库邮件功能。 第3步：进入“新建配置文件”窗口，在“配置文件名”文本框中输入要配置的文件名，如“DatabaseMail”，在“说明”文本框中可以输入对该配置文件的说明，如图11.13所示。 第4步：单击“新建配置文件”窗口的“添加”按钮，弹出“新建数据库邮件账户”窗口，在“账户名”文本框中输入一个账户名；在“电子邮件地址”文本框输入用于发送电子邮件的Email地址，如“david@163.com”；“显示名称”和“答复电子邮件”文本框可以指定显示名称和答复邮件的地址；“服务器名称”文本框中指定邮箱服务器地址，如“smtp.163.com”，端口号默认为25；在“SMTP身份验证”栏，可以选择“基本身份验证”选项，在“用户名”和“密码”栏指定邮箱账户和密码，当然也可以根据需要选择其他选项。填写结果如图11.14所示。 第5步：单击“确定”按钮返回“新建配置文件”窗口，单击“下一步”按钮进入“管理配置文件安全性”窗口，在“公共配置文件”选项卡中，选中刚新建的配置文件的“公共”复选框，将“默认配置文件”选项设为“是”，如图11.15所示。 第6步：单击“下一步”按钮，进入“配置系统参数”窗口，可以配置系统参数。这里按照默认设置不做修改，单击“下一步”按钮进入“完成该向导”窗口，单击“完成”按钮。数据库邮件配置成功后单击“关闭”按钮关闭向导。此时可在“对象资源管理器”窗口的“管理”节点下右击“数据库邮件”，选择“发送测试电子邮件”菜单项，在弹出的对话框中选择新建的配置文件“DatabaseMail”，并输入收件人的Email地址，单击“发送测试电子邮件”按钮。在对应的邮箱中查看是否收到此测试邮件。 数据库邮件配置完成后创建了一个名为DatabaseMail的配置文件，可以在SQL Server代理中使用该配置文件来发送电子邮件给操作员，具体步骤如下。 第1步：在“对象资源管理器”窗口中右击“SQL Server代理”，选择“属性”菜单项。在“常规”选项卡中，在“Net send收件人”文本框中指定Net Send收件人，一般为主机名或IP地址，如0BD7E57C949A420。 第2步：在“警报系统”选项卡，启用“启用邮件配置文件”。在“邮件系统”下拉框中选择“数据库邮件”选项，在“邮件配置文件”下拉框中选择刚创建的“DatabaseMail”选项，如图11.16所示。 第3步：单击“确定”按钮完成设置，重启SQL Server代理服务。 这时可以在SQL Server代理中创建从SQL Server接收电子邮件的操作员，在要执行的作业或警报中指定以电子邮件形式通知该操作员。之后在作业执行完成或警报激活时，SQL Server将发送电子邮件到操作员的邮箱中。 维护计划向导 使用维护计划向导创建维护计划的具体步骤如下。 第1步：首先启动SQL Server代理服务，接着以系统管理员身份连接SQL Server，展开“对象资源管理器”窗口的“管理”节点，右击“维护计划”，选择“维护计划向导”菜单项，弹出“SQL Server维护计划向导”窗口，单击“下一步”按钮。 第2步：进入“选择计划属性”窗口，在“名称”文本框中输入要执行的维护计划的名称，如“管理数据库”。在“说明”文本框中可以输入要对维护计划的说明信息。如果要对维护计划的每项任务制定单独的计划，可以选中“每项任务单独计划”单选按钮，如果要对整个计划统筹安排或暂不制定计划，则可以选择“整个计划统筹安排或无计划”单选按钮。如果要对整个计划统筹安排，则可以单击“更改”按钮设定使用计划的时间和频率。这里暂不制定计划，如图11.17所示。 第3步：单击“下一步”按钮进入“选择维护任务”窗口，可以按需要选择要进行的维护任务。为了便于说明操作步骤，这里选择除“清除维护任务”之外的全部维护任务，如图11.18所示，读者可以根据自己的需要进行选择。单击“下一步”按钮进入“选择维护任务顺序”窗口，通过单击“上移”和“下移”按钮，可以对已经选择的维护任务指定先后顺序，这里采用默认顺序。 第4步：单击“下一步”按钮进入“定义‘数据库检查完整性’任务”窗口，在“数据库”下拉框中选择“PXSCJ”数据库，如图11.19所示。当然，还可以根据需要选择“所有数据库”、“系统数据库”等选项。 第5步：单击“下一步”按钮进入“定义‘收缩数据库’任务”窗口，在“数据库”下拉框中选择需要收缩的数据库，如PXSCJ，之后可以对要收缩数据库的条件和选项进行设定，这里保持默认值，如图11.20所示。 第6步：单击“下一步”按钮进入“定义‘重新组织索引’任务”窗口，选择PXSCJ数据库，“对象”栏选择“表”，“选择”栏选择“所有对象”。当然，用户也可以根据自己的需要进行设定。单击“下一步”按钮进入“定义‘重新组织索引’任务”窗口，按之前的方法对其中的选项进行相同的设定。其中，“使用默认可用空间重新组织页”选项表示该选项填充因子重新产生页面，“将每页的可用空间百分比改为”表示该选项创建一个新的填充因子，如设为20%，表示页面将包含20%的自由空间。 第7步：单击“下一步”按钮进入“定义‘更新统计信息’任务”窗口，统计信息基于一个值在列中出现的次数，由于列中的值有变化，所以统计信息需要更新以反映那些变化。在“数据库”下拉框中选择PXSCJ，在“对象”下拉框中选择“表”，在“选择”下拉框中选择“所有对象”，如图11.21所示。 第8步：单击“下一步”按钮进入“定义‘清除历史记录’任务”窗口，在该窗口中可以选择要清除的历史记录，这里保持默认值，如图11.22所示。 第9步：单击“下一步”按钮进入“定义‘执行SQL Server代理作业’任务”窗口，选择要执行的SQL Server代理作业，如图11.23所示。 第10步：单击“下一步”按钮进入“定义‘备份数据库（完整）’任务”窗口，在“数据库”下拉框中选择PXSCJ数据库，其他选项用户可以根据需要进行设定，如图11.24所示。单击“下一步”按钮进入“定义‘备份数据（差异）’任务”窗口和“定义‘备份数据库（事务日志）’任务”窗口，设置方法与之前类似。 第12步 单击“下一步”按钮进入“选择报告选项”窗口，这里可以设置“将报告写入文本文件”并指定具体的路径，这里保持默认值。如果需要将报告发送给操作员，则选中“以电子邮件形式发送报告”，并设置收件人为相应的操作员，如图11.25所示。 单击“下一步”按钮进入“完成该向导”窗口，查看计划执行的步骤，单击“完成”按钮，结果如图11.26所示。最后单击“关闭”按钮关闭该窗口。 SQL Server 2008服务 SQL Server 2008的服务平台是指对SQL Server的组成部分和这些组成部分之间关系的描述。SQL Server 2008的服务一共由4部分组成：数据库引擎、集成服务（Integration Services）、报表服务（Reporting Services）和分析服务（Analysis Services）。通过选择不同的数据库服务，可以完成不同的数据库操作。SQL Server 2008中各个服务的体系结构如图11.29所示。 集成服务 SQL Server 2008中集成服务的具体用途主要体现在以下几个方面。 （1）整理和标准化数据。集成服务包含了一些内置转换，可将其添加到包中以达到清理数据和将数据标准化、更改数据的大小写、将数据转换成不同类型或格式，或者根据表达式创建新列值等目的。其中，包是一个有组织的集合，包括连接、控制流元素、数据流元素、事件处理程序、变量和配置。使用SSIS工具可以设计、创建、部署和管理包，从而处理日常的义务需求。 包还可以使用精确查找或模糊查找来找到引用表中的值，通过将列中的值替换为引用表中的值来清理数据。通常包首先使用精确查找，如果该查找失败再使用模糊查找。 （2）为数据仓库提供数据。集成服务作为ETL在SQL Server中的实现渠道，是为数据仓库提供数据的主要来源，集成服务包含了一个可直接将数据从平面文件大容量加载到SQL Server表和视图中的任务，还包含了一个目标组件，该组件可以在数据转换过程的最后一步将数据大容量加载到SQL Server数据库中。 （3）实现数据的跨平台存储。数据通常存储在很多不同的数据存储系统中。集成服务可以连接到各种数据源，从所有的源中提取数据并将其合并到单个一致的数据集中。SSIS包可以使用.NET和OLE DB访问接口连接到关系数据库，还可以使用ODBC驱动程序连接到早期的数据库。包还可以连接到平面文件、Excel文件和SQL Server的分析服务项目。 （4）在数据转换过程中实现商业智能。集成服务提供了用于将商业智能置入SSIS包的容器、任务和转换的功能。 报表服务 通过报表服务可以可视化地完成报表设计过程的交互工作，并且在Web上完成绝大多数的报表管理工作，还可以在运行时对报表的内容进行筛选。SQL Server Reporting Services的服务体系结构如图11.30所示。 报表服务为所有组织的报表需求建立了新的标准，把一个单一的、完整的报表平台和一个可伸缩的、可扩展的架构结合在一起，来满足对报表的不同需求，包括以下几种。 （1）企业报表。企业可以使用报表服务来制作内部报表或者商业智能的应用。使用报表服务，公司内部的IT人员可以设计出各种不同的报表，并将它们发布给整个企业中的每个人。 （2）即席报表。SQL Server 2008报表服务包括一个报表生成器。它是一种新的、特别的即席报表工具，能确保商业用户创建自己的报表和浏览企业数据。报表生成器包含有利于用户的商业查询模式，确保用户无须在技术上深入理解潜在数据源即能建立报表。 （3）嵌入式报表。独立软件开发商（ISV）可以使用报表服务来发布作为应用包一部分的、已经预定义好的报表。客户的IT机构可以访问这些报表或者使用报表服务来自定义报表，也可以针对特殊的业务需要建立新的报表。对于独立软件开发商来讲，报表服务提供了将灵活的可交互的报表嵌入应用的一个简单模式。 （4）面向合作伙伴和客户的基于Web的报表。组织可以通过部署传统的或者交互式的基于Web的报表来通过Internet的extranets与客户或者合作伙伴交流。报表服务将报表消费者从复杂的底层数据源分离，同时提供了个性化与交互性。 SQL Server报表服务支持完整的报表生命周期，包括： （1）报表制作。通过使用Microsoft或其他使用报表定义语言（RDL）的设计工具，报表开发人员可制作发布在报表服务之上的报表。报表定义语言（RDL）是基于XML的用于定义报表的行业标准。 （2）报表管理。报表定义、文件夹和资源被作为一项Web服务来发表和管理。受管理的报表可根据随机请求或按特定进度被执行，并且在一致性和性能方面提供了缓存方式。在SQL Server 2008报表服务中，管理员能使用SSMS来组织报表和数据源、确定报表执行的进度、交付和跟踪报表历史记录。 （3）报表提交。报表服务支持随机请求的方式提交，以及基于时间表或事件的方式提交。用户可基于WEB格式或者通过电子邮件阅读报表。 （4）报表安全。SQL Server报表服务实施一种灵活的基于角色的安全模式，从而保护了报表与数据源。该产品也包含为整合其他安全模式提供的可扩展的界面。 表述尚欠清晰，请润色。 分析服务 数据挖掘就是指从大量的数据中提取出有价值的信息。SQL Server 2008中的数据挖掘不仅功能强大和易于访问，并且与很多在进行分析和报告工作时常用的工具集成在一起。用户使用SQL Server 2008分析服务中的数据挖掘工具有助于识别数据中的模式，从而确定出现问题的原因，还可以在分析服务中轻松地挖掘创建的OLAP多维数据集。SQL Server 2008分析服务包含创建复杂数据挖掘解决方案所需的如下功能和工具： 一组行业标准数据挖掘算法。 数据挖掘设计器，可用于创建、管理和浏览数据挖掘模型，并随后使用这些模型创建预测。 数据挖掘扩展插件（DMX）语言，可用于管理挖掘模型和创建复杂的预测查询。 "},"page/11044.html":{"url":"page/11044.html","title":"数据完整性管理","keywords":"","body":"数据完整性管理 "},"page/11277.html":{"url":"page/11277.html","title":"MSSQL","keywords":"","body":"MSSQL "},"page/11339.html":{"url":"page/11339.html","title":"数据完整性","keywords":"","body":"数据完整性 数据完整性的分类 数据完整性是指数据库中的数据在逻辑上的一致性和准确性。数据完整性一般包括三种。 1．实体完整性(主键约束) 不写也是非空唯一，也可通过 唯一索引+ 非空约束 实体完整性又称为行的完整性，要求表中有一个主键，其值不能为空且能唯一地标识对应的记录。通过索引、UNIQUE约束、PRIMARY KEY约束或IDENTITY属性可实现数据的实体完整性。 例如，对于PXSCJ数据库中的XSB表，“学号”作为主键，每一个学生的学号能唯一地标识该学生对应的行记录信息，那么在输入数据时，则不能有相同学号的行记录。通过对学号这一字段建立主键约束可实现表XSB的实体完整性。 2．域完整性（列完整性） 域完整性又称为列完整性，指给定列输入的有效性。实现域完整性的方法有：限制类型（通过数据类型）、格式（通过CHECK约束和规则）或可能的取值范围（通过CHECK约束、DEFALUT定义、NOT NULL定义和规则）等。 例如，对于学生数据库PXSCJ的KCB表，学生的总学分应在0～60之间，为了对“总学分”这一数据项输入的数据范围进行限制，可以在定义KCB表的同时定义学分的约束条件来达到这一目的。 【例6.8】 建立表KCB2，同时定义总学分的约束条件为0～60。 CREATE TABLE KCB2 ( 课程号 char(6) NOT NULL, 课程名 char(8) NOT NULL, 学分 tinyint CHECK (学分>=0 AND 学分 3．参照完整性(引用完整性) 参照完整性又称为引用完整性。参照完整性保证主表中的数据与从表（被参照表）中数据的一致性。在SQL Server 2008中，参照完整性的实现是通过定义外键与主键之间或外键与唯一键之间的对应关系来实现的。参照完整性确保键值在所有表中一致。 码：即前面所说的关键字，又称为“键”，是能唯一标识表中记录的字段或字段组合。如果一个表有多个码，可选其中一个作为主键（主码），其余的称为候选键。 外码：如果一个表中的一个字段或若干个字段的组合是另一个表的码，则称该字段或字段组合为该表的外码（外键）。 例如，对于PXSCJ数据库中XSB表的每一个学号，在CJB表中都有相关的课程成绩记录，将XSB作为主表，“学号”字段定义为主键，CJB作为从表，表中的“学号”字段定义为外键，从而建立主表和从表之间的联系，实现参照完整性。XSB和CJB表的对应关系如表6.1和表6.2所示。 如果定义了两个表之间的参照完整性，则要求： （1）从表不能引用不存在的键值。例如，CJB表中行记录出现的学号必须是XSB表中已存在的学号。 （2）如果主表中的键值更改了，那么在整个数据库中，对从表中该键值的所有引用要进行一致的更改。例如，如果对XSB表中的某一学号修改，则CJB表中所有对应学号也要进行相应的修改。 （3）如果主表中没有关联的记录，则不能将记录添加到从表。 如果要删除主表中的某一记录，则应先删除从表中与该记录匹配的相关记录。 实体完整性的实现 如果PRIMARY KEY约束是由多列组合定义的，则某一列的值可以重复，但PRIMARY KEY约束定义中所有列的组合值必须唯一。如果要确保一个表中的非主键列不输入重复值，则应在该列上定义唯一约束（UNIQUE约束）。 例如，对于PXSCJ数据库中的XSB表，“学号”列是主键，在XSB表中增加一列“身份证号码”，可以定义一个UNIQUE约束来要求表中“身份证号码”列的取值是唯一的。 PRIMARY KEY约束与UNIQUE约束的主要区别如下： （1）一个数据表只能创建一个PRIMARY KEY约束，但一个表中可根据需要对表中不同的列创建若干个UNIQUE约束。 （2）PRIMARY KEY字段的值不允许为NULL，而UNIQUE字段的值可取NULL。 （3）一般在创建PRIMARY KEY约束时，系统会自动产生(聚集)索引，索引的默认类型为簇索引。在创建UNIQUE约束时，系统会自动产生一个UNIQUE索引，索引的默认类型为非簇索引。 有主键不能再创建聚集索引，只能有一个物理的 没有主键可以创建唯一聚集索引 命令 利用“T-SQL命令”创建及删除PRIMARY KEY约束或UNIQUE约束 利用T-SQL命令可以使用两种方式定义约束：作为列的约束或作为表的约束。可以在创建表或修改表时定义。 （1）在创建表的同时创建PRIMARY KEY约束或UNIQUE约束。 语法格式： CREATE TABLE table_name ( { }[,…n] [ ] [ ,...n ] ) 其中，为列的约束，为表的约束。 ::= /*定义列的约束*/ [ CONSTRAINT constraint_name ] { { PRIMARY KEY | UNIQUE } /*定义主键与UNIQUE键*/ [ CLUSTERED | NONCLUSTERED ] /*定义约束的索引类型*/ [WITH ( [ , ...n ] ) ] [ ON { partition_scheme_name ( partition_column_name ) | filegroup | \"default\" } ] | [ FOREIGN KEY ] /*定义外键*/ | CHECK [ NOT FOR REPLICATION ] ( logical_expression ) /*定义CHECK约束*/ } ::= /*定义表的约束*/ [ CONSTRAINT constraint_name ] /*指定名称方便删除*/ { { PRIMARY KEY | UNIQUE } [ CLUSTERED | NONCLUSTERED ] (column [ ASC | DESC ] [ ,...n ] ) /*定义表的约束时需要指定列*/ [WITH ( [ , ...n ] ) ] [ ON { partition_scheme_name (partition_column_name) | filegroup | \"default\" } ] | FOREIGN KEY ( column [ ,...n ] ) | CHECK [ NOT FOR REPLICATION ] ( logical_expression ) } 【例6.9】 创建XSB1表（假设XSB1表未创建），并对“学号”字段创建PRIMARY KEY约束，对“姓名”字段定义UNIQUE约束。 USE PXSCJ GO CREATE TABLE XSB1 ( 学号 char(6) NOT NULL CONSTRAINT XH_PK PRIMARY KEY, 姓名 char(8) NOT NULL CONSTRAINT XM_UK UNIQUE, 性别 bit NOT NULL DEFAULT 1, 出生时间 date NOT NULL, 专业 char(12) NULL, 总学分 int NULL, 备注 varchar(500) NULL ) 【例6.10】 创建一个course_name表来记录每门课程的学生学号、姓名、课程号、学分和毕业日期。其中，学号、课程号和毕业日期构成复合主键，学分为唯一键。 CREATE TABLE course_name ( 学号 varchar(6) NOT NULL, 姓名 varchar(8) NOT NULL, 毕业日期date NOT NULL, 课程号 varchar(3) , 学分 tinyint, PRIMARY KEY (学号, 课程号, 毕业日期), CONSTRAINT XF_UK UNIQUE (学分) ) （2）通过修改表创建PRIMARY KEY约束或UNIQUE约束。 使用ALTER TABLE语句中的ADD子句可以为表中已存在的列或新列定义约束，语法格式参见第3章中ALTER TABLE语句的ADD子句。 【例6.11】 修改例6.14中的XSB1表，向其中添加一个“身份证号码”字段，对该字段定义UNIQUE约束。对“出生时间”字段定义UNIQUE约束。 ALTER TABLE XSB1 ADD 身份证号码 char(20) CONSTRAINT SF_UK UNIQUE NONCLUSTERED (身份证号码) GO ALTER TABLE XSB1 ADD CONSTRAINT CJSJ_UK UNIQUE NONCLUSTERED (出生时间) （3）删除PRIMARY KEY约束或UNIQUE约束。 删除PRIMARY KEY约束或UNIQUE约束需要使用ALTER TABLE的DROP子句。 语法格式： ALTER TABLE table_name DROP CONSTRAINT constraint_name [ ,...n ] 【例6.12】 删除例6.14中创建的PRIMARY KEY约束和UNIQUE约束。 ALTER TABLE XSB1 DROP CONSTRAINT XH_PK, XM_UK GO 界面 1．利用界面方式创建和删除PRIMARY KEY约束 （1）创建PRIMARY KEY约束。 如果要对XSB表按学号建立PRIMARY KEY约束，则可以按第3章创建表的第3步中所介绍的设置主键的相关步骤进行。 当创建主键时，系统将自动创建一个名称以“PK_”为前缀、后跟表名的主键索引，系统自动按聚集索引方式组织主键索引。 （2）删除PRIMARY KEY约束。 如果要删除表XSB中对“学号”字段建立的PRIMARY KEY约束，可按如下步骤进行：在对象资源管理器中选择dbo.XSB表图标，右击鼠标，在弹出的快捷菜单中选择“设计”菜单项，进入“表设计器”窗口。选中“XSB表设计器”窗口中主键所对应的行，右击鼠标，在弹出的快捷菜单中选择“删除主键”菜单项即可。 2．利用界面方式创建和删除UNIQUE约束 （1）创建UNIQUE约束。 如果要对XSB表中的“学号”列创建UNIQUE约束，以保证该列取值的唯一性，可按以下步骤进行： 进入XSB表的“表设计器”窗口，选择“学号”属性列并右击鼠标，在弹出的快捷菜单中选择“索引/键”菜单项，打开“索引/键”窗口。 在窗口中单击“添加”按钮，并在右边的“标识”属性区域的“名称”栏中输入唯一键的名称（用系统默认的名或重新取名）。在“常规”属性区域的“类型”栏中选择类型为“唯一键”，如图6.3所示。 在“常规”属性区域中的“列”栏后面单击[...]形状的按钮，选择要创建索引的列。在此选择“学号”列，并设置排列顺序。单击“关闭”按钮，然后保存修改即可。 （2）删除UNIQUE约束。 打开如图6.3所示的“索引/键”窗口，选择要删除的UNIQUE约束，单击左下方的“删除”按钮，单击“关闭”按钮，保存表的修改即可。 域完整性的实现 1．CHECK约束的定义与删除 CHECK约束实际上是字段输入内容的验证规则，表示一个字段的输入内容必须满足CHECK约束的条件，若不满足，则数据无法正常输入。 命令 （2）利用SQL语句在创建表时创建CHECK约束。 在创建表时可以使用CHECK约束表达式来定义CHECK约束，具体语法格式参见6.2.2小节。CHECK约束表达式语法格式如下： CHECK [ NOT FOR REPLICATION ] ( logical_expression ) 关键字CHECK表示定义CHECK约束，如果指定NOT FOR REPLICATION选项，则当复制代理执行插入、更新或删除操作时，将不会强制执行此约束。其后的logical_expression逻辑表达式称为CHECK约束表达式，返回值为TRUE或FALSE，该表达式只能为标量表达式。 【例6.13】 创建一个表student，只考虑“学号”和“性别”两列，性别只能包含男或女。 USE PXSCJ GO CREATE TABLE student ( 学号 char(6) NOT NULL, 性别 char(1) NOT NULL CHECK(性别 IN ('男', '女')) ) 【例6.14】 创建一个表student1，只考虑“学号”和“出生日期”两列，出生日期必须大于1980年1月1日，并命名CHECK约束。 CREATE TABLE student1 ( 学号 char(6) NOT NULL, 出生时间 datetime NOT NULL, CONSTRAINT DF_student1_cjsj CHECK(出生时间>'1980-01-01') ) 【例6.15】 创建表student2，有“学号”、“最好成绩”和“平均成绩”三列，要求最好成绩必须大于平均成绩。 CREATE TABLE student2 ( 学号 char(6) NOT NULL, 最好成绩 INT NOT NULL, 平均成绩 INT NOT NULL, CHECK(最好成绩>平均成绩) ) （3）利用SQL语句在修改表时创建CHECK约束。 在使用ALTER TABLE语句修改表时也能定义CHECK约束，ALTER TABLE语句的语法格式参见第3章。 定义CHECK约束的语法格式为 ALTER TABLE table_name [ WITH { CHECK | NOCHECK } ] ADD [] [CONSTRAINT constraint_name] CHECK (logical_expression) 【例6.16】 通过修改PXSCJ数据库的CJB表，增加“成绩”字段的CHECK约束。 USE PXSCJ GO ALTER TABLE CJB ADD CONSTRAINT cj_constraint CHECK (成绩>=0 AND 成绩 界面 （1）通过图形向导方式创建与删除CHECK约束。 在PXSCJ数据库的CJB表中，学生每门功课的成绩一般在0～100的范围内。如果对用户的输入数据要施加这一限制，可按如下步骤进行。 第1步：启动“SQL Server Management Studio”，在对象资源管理器中展开“数据库→PXSCJ→表”，选择“dbo.CJB”，右击鼠标，在出现的快捷菜单中选择“设计”菜单项。 第2步：在打开的“表设计器”窗口中选择“成绩”属性列，右击鼠标，在弹出的快捷菜单中选择“CHECK约束”菜单项。 第3步：在打开的 “CHECK约束”窗口（如图6.4所示）中，单击“添加”按钮，添加一个CHECK约束。在“常规”属性区域中的“表达式”栏后面单击“【...】 ”按钮（或直接在文本框中输入内容），打开“CHECK约束表达式”窗口，并编辑相应的CHECK约束表达式为“成绩>=0 AND 成绩 “CHECK约束”窗口 第4步：单击“确定”按钮，完成CHECK约束表达式的编辑，返回到“CHECK约束”窗口中。在“CHECK约束”窗口中选择“关闭”按钮，并保存修改，完成“CHECK约束”的创建。此时若输入数据，如果成绩不是在0～100的范围内，系统将报告错误。 如果要删除上述约束，只需进入如图6.4所示的“CHECK约束”窗口，选中要删除的约束，单击“删除”按钮删除约束，然后单击“关闭”按钮即可。 2．规则对象的定义、使用与删除 规则是一组使用T-SQL语句组成的条件语句，规则提供了另外一种在数据库中实现域完整性与用户定义完整性的方法。规则对象的使用方法与默认值对象的使用步骤类似。 ① 定义规则对象； ② 将规则对象绑定到列或用户自定义类型。 在SQL Server 2008中，规则对象的定义可以利用CREATE RULE语句来实现。 （1）规则对象的定义。 语法格式： CREATE RULE [ schema_name. ] rule_name AS condition_expression [ ; ] （2）将规则对象绑定到用户定义数据类型或列。 将规则对象绑定到列或用户定义数据类型中可以使用系统存储过程sp_bindrule。 语法格式： sp_bindrule [ @rulename = ] 'rule' , [ @objname = ] 'object_name' [ , [ @futureonly = ] 'futureonly_flag' ] （3）应用举例。 【例6.18】 如下程序创建一个规则，并绑定到表KCB的课程号列，用于限制课程号的输入范围。 USE PXSCJ GO CREATE RULE kc_rule AS @range like '[1-5][0-9][0-9]' GO EXEC sp_bindrule 'kc_rule', 'KCB.课程号' /*执行存储过程使用EXEC命令*/ GO 程序如果正确执行将提示：“已将规则绑定到表的列”。 【例6.19】 创建一个规则，用以限制输入到该规则所绑定的列中的值只能是该规则中列出的值。 CREATE RULE list_rule AS @list IN ('C语言', '离散数学', '微机原理') GO EXEC sp_bindrule 'list_rule', 'KCB.课程名' GO 【例6.20】 如下程序定义一个用户数据类型course_num，然后将前面定义的规则“kc_rule”绑定到用户数据类型course_num上，最后创建表KCB1，其课程号的数据类型为course_num。 CREATE TYPE course_num FROM char(3) NOT NULL /*创建用户定义数据类型*/ EXEC sp_bindrule 'kc_rule', 'course_num' /*将规则对象绑定到用户定义数据类型*/ GO CREATE TABLE KCB1 ( 课程号 course_num, /*将学号定义为course_num类型*/ 课程名 char(16) NOT NULL, 开课学期 tinyint , 学时 tinyint, 学分 tinyint ) GO （4）规则对象的删除。在删除规则对象前，首先应使用系统存储过程sp_unbindrule解除被绑定对象与规则对象之间的绑定关系，使用格式如下： sp_unbindrule [@objname =] 'object_name' [, [@futureonly =] 'futureonly_flag'] 在解除列或自定义类型与规则对象之间的绑定关系后，就可以删除规则对象了。 语法格式： DROP RULE { [ schema_name . ] rule_name } [ ,...n ] [ ; ] 【例6.21】 解除规则kc_rule与列或用户定义类型的绑定关系，并删除规则对象kc_rule。 EXEC sp_unbindrule 'KCB.课程号' EXEC sp_unbindrule 'course_num' GO DROP RULE kc_rule 参照完整性的实现 命令 利用“T-SQL命令”定义表间的参照关系 前面已介绍了创建主键（PRIMARY KEY约束）及唯一键（UNIQUE约束）的方法，在此将介绍通过T-SQL命令创建外键的方法。 （1）创建表的同时定义外键约束。 语法格式在6.3.2小节中已经列出，这里只列出定义外键部分的语法。 CREATE TABLE table_name /*指定表名*/ ( [ CONSTRAINT constraint_name ] [ FOREIGN KEY ][ ( column [ ,...n ] )] ) 其中， ::= REFERENCES referenced_table_name [ ( ref_column [ ,...n ] ) ] [ ON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ] [ ON UPDATE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ] /*忽略， 级联跟着变， */ [ NOT FOR REPLICATION ] 【例6.22】 创建stu表，要求stu表中所有的学生学号都必须出现在XSB表中，假设已经使用“学号”列作为主键创建了XSB表。 USE PXSCJ GO CREATE TABLE stu ( 学号 char(6) NOT NULL FOREIGN KEY (学号) REFERENCES XSB (学号), 姓名 char(8) NOT NULL, 出生时间 datetime NULL ) 【例6.23】 创建point表，要求表中所有的学号、课程号组合都必须出现在CJB表中。 CREATE TABLE point ( 学号 char(6) NOT NULL, 课程号 char(3) NOT NULL, 成绩 int NULL, CONSTRAINT FK_point FOREIGN KEY (学号,课程号) REFERENCES CJB (学号,课程号) ON DELETE NO ACTION ) （2）通过修改表定义外键约束。 【例6.24】 假设KCB表为主表，KCB的“课程号”字段已定义为主键。CJB表为从表，如下示例用于将CJB表的“课程号”字段定义为外键。 ALTER TABLE CJB ADD CONSTRAINT kc_foreign FOREIGN KEY (课程号) REFERENCES KCB(课程号 ) 4．利用T-SQL命令删除表间的参照关系 删除表间的参照关系，实际上删除从表的外键约束即可。 语法格式与前面其他约束删除的格式类似。 【例6.25】 删除上例对CJB表的“课程号”字段定义的外键约束。 ALTER TABLE CJB DROP CONSTRAINT kc_foreign 界面 1．利用界面定义表间的参照关系 例如，要实现XSB表与CJB表之间的参照完整性，操作步骤如下。 第1步：按照前面所介绍的方法定义主表的主键。由于之前在创建表的时候已经定义XSB表中的“学号”字段为主键，所以这里就不需要再定义主表的主键了。 第2步：启动SQL Server Management Studio，在对象资源管理器中展开“数据库→PXSCJ”，选择“数据库关系图”，右击鼠标，在出现的快捷菜单中选择“新建数据库关系图”菜单项，打开“添加表”窗口。 第3步：在出现的“添加表”窗口中选择要添加的表，本例中选择了表XSB和表CJB。单击“添加”按钮完成表的添加，之后单击“关闭”按钮退出窗口。 第4步：在“数据库关系图设计”窗口将鼠标指向主表的主键，并拖动到从表，即将XSB表中的“学号”字段拖动到从表CJB中的“学号”字段。 第5步：在弹出的“表和列”窗口中输入关系名、设置主键表和列名，如图6.5所示，单击“表和列”窗口中的“确定”按钮，再单击“外键关系”窗口中的“确认”按钮。 第6步：进入如图6.6所示的界面，单击“保存”按钮，在弹出的“选择名称”对话框中输入关系图的名称。单击“确定”按钮，在弹出的“保存”对话框中单击“是”按钮，保存设置。 如果要在图6.6的基础上再添加KCB表并建立相应的参照完整性关系，可以使用以下步骤：右击图6.6中的空白区域，选择“添加表”菜单项，在随后弹出的“添加表”窗口中添加KCB表，之后定义CJB表和KCB表之间的参照关系，结果如图6.7所示。 设置参照完整性 主表和从表的参照关系图 三个表之间的参照关系图 2．利用图形向导方式删除表间的参照关系 如果要删除前面建立的XSB表与CJB表之间的参照关系，可按以下步骤进行。 第1步：在PXSCJ数据库的“数据库关系图”目录下选择要修改的关系图，如Diagram_0，右击鼠标，在弹出的快捷菜单中选择“修改”菜单项，打开“数据库关系图设计”窗口。 第2步：在“数据库关系图设计”窗口中，选择已经建立的“关系”，单击鼠标右键，选择“从数据库中删除关系”，如图6.8所示。在随后弹出的对话框中，单击“是”按钮，删除表之间的关系。 删除关系 "},"page/11045.html":{"url":"page/11045.html","title":"数据安全性控制","keywords":"","body":"数据安全性控制 "},"page/11278.html":{"url":"page/11278.html","title":"MSSQL","keywords":"","body":"MSSQL SQL Server 2008的安全机制 SQL Server 2008的身份验证模式 SQL Server 2008的身份验证模式是指系统确认用户的方式。SQL Server 2008有两种身份验证模式：Windows验证模式和SQL Server验证模式。如图9.1所示为这两种方式登录SQL Server服务器的情形。 1．Windows验证模式 用户登录Windows时进行身份验证，登录SQL Server时就不再进行身份验证。以下是对于Windows验证模式登录的几点重要说明。 （1）必须将Windows账户加入到SQL Server中，才能采用Windows账户登录SQL Server。 （2）如果使用Windows账户登录到另一个网络的SQL Server，则必须在Windows中设置彼此的托管权限。 2．SQL Server验证模式 在SQL Server验证模式下，SQL Server服务器要对登录的用户进行身份验证。当SQL Server在Windows XP或Windows 2003/2008等操作系统上运行时，系统管理员设定登录验证模式的类型可为Windows验证模式和混合模式。当采用混合模式时，SQL Server系统既允许使用Windows登录名登录，也允许使用SQL Server登录名登录。 SQL Server 2008的安全性机制 （1）服务器级别所包含的安全对象主要有登录名、固定服务器角色等。其中，登录名用于登录数据库服务器，而固定服务器角色用于给登录名赋予相应的服务器权限。 SQL Server 2008中的登录名主要有两种，第一种是Windows登录名，第二种是SQL Server登录名。 Windows登录名对应Windows验证模式，该验证模式所涉及的账户类型主要有Windows本地用户账户、Windows域用户账户、Windows组。 SQL Server登录名对应SQL Server验证模式，在该验证模式下，能够使用的账户类型主要是SQL Server账户。 （2）数据库级别所包含的安全对象主要有用户、角色、应用程序角色、证书、对称密钥、非对称密钥、程序集、全文目录、DDL事件、架构等。 用户安全对象是用来访问数据库的。如果某人只拥有登录名，而没有在相应的数据库中为其创建登录名所对应的用户，则该用户只能登录数据库服务器，而不能访问相应的数据库。 （3）架构级别所包含的安全对象主要有表、视图、函数、存储过程、类型、同义词、聚合函数等。 简单地说，架构的作用是将数据库中的所有对象分成不同的集合，这些集合没有交集，每一个集合就称为一个架构。数据库中的每一个用户都会有自己的默认架构。这个默认架构可以在创建数据库用户时由创建者设定，若不设定则系统默认架构为dbo。数据库用户只能对属于自己架构中的数据库对象执行相应的数据操作。至于操作的权限则由数据库角色决定。 例如，若某数据库中的表A属于架构S1，表B属于架构S2，而某用户默认的架构为S2，如果没有授予用户操作表A的权限，则该用户不能对表A执行相应的数据操作。但是，该用户可以对表B执行相应的操作。 一个数据库使用者，要登录服务器上的SQL Server数据库，并对数据库中的表执行数据更新操作，则该使用者必须经过如图9.2所示的安全验证。 图9.2 SQL Server数据库安全验证 建立和管理用户账户 界面方式管理用户账户 1．建立Windows验证模式的登录名 第1步：创建Windows的用户。 以管理员身份登录到Windows XP，选择“开始”，打开控制面板中的“性能和维 护”，选择其中的“管理工具”，双击“计算机管理”，进入“计算机管理”窗口。 在该窗口中选择“本地用户和组”中的“用户”图标，右击，在弹出的快捷菜单中选择 “新用户”菜单项，打开“新用户”窗口。如图9.3所示，在该窗口中输入用户名、密码，单击“创建”按钮，然后单击“关闭”按钮，完成新用户的创建。 第2步：将Windows账户加入到SQL Server中。 以管理员身份登录到SQL Server Management Studio，在对象资源管理器中，找到并选择如图9.4所示的“登录名”项。右击鼠标，在弹出的快捷菜单中选择“新建登录名”，打开“登录名-新建”窗口。 如图9.5所示，可以通过单击“常规”选项卡的“搜索”按钮，在“选择用户或组”对话框中选择相应的用户名或用户组并添加到SQL Server 2008登录用户列表中。例如，本例的用户名为0BD7E57C949A420\\liu（0BD7E57C949A420为本地计算机名）。 2．建立SQL Server验证模式的登录名 步骤如下。 第1步：以系统管理员身份登录SQL Server Management Studio，在对象资源管理器中选择要登录的SQL Server服务器图标，右击鼠标，在弹出的快捷菜单中选择“属性”菜单项，打开“服务器属性”窗口。 第2步：在打开的“服务器属性”窗口中选择“安全性”选项卡。选择服务器身份验证为“SQL Server和Windows身份验证模式”，单击“确定”按钮，保存新的配置，重启SQL Server服务即可。 创建SQL Server验证模式的登录名也在如图9.5所示的界面中进行，输入一个自己定义的登录名，例如david，选中“SQL Server身份验证”选项，输入密码，并将“强制密码过期”复选框中的勾去掉，设置完单击“确定”按钮即可。 为了测试创建的登录名能否连接SQL Server，可以使用新建的登录名david来进行测试，具体步骤如下： 在对象资源管理器窗口中单击“连接”，在下拉框中选择“数据库引擎”，弹出“连接到服务器”对话框。在该对话框中，“身份验证”选择“SQL Server身份验证”，“登录名”填写david，输入密码，单击“连接”按钮，就能连接SQL Server了。登录后的“对象资源管理器”界面如图9.6所示。 3．管理数据库用户 使用SSMS创建数据库用户账户的步骤如下（以PXSCJ为例）： 以系统管理员身份连接SQL Server，展开“数据库→PXSCJ→安全性”，选择“用户”，右击鼠标，选择“新建用户”菜单项，进入“数据库用户-新建”窗口。在“用户名”框中填写一个数据库用户名，“登录名”框中填写一个能够登录SQL Server的登录名，如david。注意，一个登录名在本数据库中只能创建一个数据库用户。选择默认架构为dbo，如图9.7所示，单击“确定”按钮完成创建。 命令方式管理用户账户 1．创建登录名 在SQL Server 2008中，创建登录名可以使用CREATE LOGIN命令。语法格式： CREATE LOGIN login_name { WITH PASSWORD = 'password' [ HASHED ] [ MUST_CHANGE ] [ , [ ,... ] ] /*WITH子句用于创建SQL Server登录名*/ | FROM /*FROM子句用于创建其他登录名*/ {   WINDOWS [ WITH [ ,... ] ] | CERTIFICATE certname | ASYMMETRIC KEY asym_key_name } } 其中， ::= SID = sid | DEFAULT_DATABASE = database | DEFAULT_LANGUAGE = language | CHECK_EXPIRATION = { ON | OFF} | CHECK_POLICY = { ON | OFF} [ CREDENTIAL = credential_name ] ::= DEFAULT_DATABASE = database | DEFAULT_LANGUAGE = language （1）创建Windows验证模式登录名。创建Windows登录名使用FROM子句，在FROM子句的语法格式中，WINDOWS关键字指定将登录名映射到Windows登录名，其中，为创建Windows登录名的选项，DEFAULT_DATABASE指定默认数据库，DEFAULT_LANGUAGE指定默认语言。 【例9.1】 使用命令方式创建Windows登录名tao（假设Windows用户tao已经创建，本地计算机名为0BD7E57C949A420），默认数据库设为PXSCJ。 USE master GO CREATE LOGIN [0BD7E57C949A420\\tao] FROM WINDOWS WITH DEFAULT_DATABASE= PXSCJ （2）创建SQL Server验证模式登录名。创建SQL Server登录名使用WITH子句，其中， ① PASSWORD：用于指定正在创建的登录名的密码，password为密码字符串。HASHED 选项指定在PASSWORD参数后输入的密码已经过哈希运算，如果未选择此选项，则在将作为密码输入的字符串存储到数据库之前，对其进行哈希运算。如果指定MUST_CHANGE选项，则SQL Server会在首次使用新登录名时提示用户输入新密码。 ② ：用于指定在创建SQL Server登录名时的一些选项，选项如下。 SID：指定新SQL Server登录名的全局唯一标识符，如果未选择此选项，则自动指派。 DEFAULT_DATABASE：指定默认数据库，如果未指定此选项，则默认数据库将设置为master。 DEFAULT_LANGUAGE：指定默认语言，如果未指定此选项，则默认语言将设置为服务器的当前默认语言。 CHECK_EXPIRATION：指定是否对此登录名强制实施密码过期策略，默认值为OFF。 CHECK_POLICY：指定应对此登录名强制实施运行SQL Server的计算机的Windows密码策略，默认值为ON。 【例9.2】 创建SQL Server登录名sql_tao，密码为123456，默认数据库设为PXSCJ。 CREATE LOGIN sql_tao WITH PASSWORD='123456', DEFAULT_DATABASE=PXSCJ 2．删除登录名 删除登录名使用DROP LOGIN命令。语法格式： DROP LOGIN login_name 【例9.3】 删除Windows登录名tao。 DROP LOGIN [0BD7E57C949A420\\tao] 【例9.4】 删除SQL Server登录名sql_tao。 DROP LOGIN sql_tao 3．创建数据库用户 创建数据库用户使用CREATE USER命令。语法格式： CREATE USER user_name [{ FOR | FROM } { LOGIN login_name | CERTIFICATE cert_name | ASYMMETRIC KEY asym_key_name } | WITHOUT LOGIN ] [ WITH DEFAULT_SCHEMA = schema_name ] 【例9.5】 使用SQL Server登录名sql_tao（假设已经创建）在PXSCJ数据库中创建数据库用户tao，默认架构名使用dbo。 USE PXSCJ GO CREATE USER tao FOR LOGIN sql_tao WITH DEFAULT_SCHEMA=dbo 4．删除数据库用户 删除数据库用户使用DROP USER语句。语法格式： DROP USER user_name user_name为要删除的数据库用户名，在删除之前要使用USE语句指定数据库。 【例9.6】 删除PXSCJ数据库的数据库用户tao。 USE PXSCJ GO DROP USER tao 角色管理 固定服务器角色 （1）sysadmin：系统管理员，角色成员可对SQL Server服务器进行所有的管理工作，为最高管理角色。这个角色一般适合于数据库管理员（DBA）。 （2）securityadmin：安全管理员，角色成员可以管理登录名及其属性。可以授予、拒绝、撤销服务器级和数据库级的权限。另外还可以重置SQL Server登录名的密码。 （3）serveradmin：服务器管理员，角色成员具有对服务器进行设置及关闭服务器的权限。 （4）setupadmin：设置管理员，角色成员可以添加和删除链接服务器，并执行某些系统存储过程。 （5）processadmin：进程管理员，角色成员可以终止SQL Server实例中运行的进程。 （6）diskadmin：用于管理磁盘文件。 （7）dbcreator：数据库创建者，角色成员可以创建、更改、删除或还原任何数据库。 （8）bulkadmin：可执行BULK INSERT语句，但是这些成员对要插入数据的表必须有INSERT权限。BULK INSERT语句的功能是以用户指定的格式复制一个数据文件至数据库表或视图。 （9）public：其角色成员可以查看任何数据库。 1．通过对象资源管理器添加服务器角色成员 第1步：以系统管理员身份登录到SQL Server服务器，在对象资源管理器中展开“安全性→登录名”，选择登录名，例如“0BD7E57C949A420\\liu”，双击或右击选择“属性”菜单项，打开“登录属性”窗口。 第2步：在打开的“登录属性”窗口中选择“服务器角色”选项卡。如图9.8所示，在“登录属性”窗口右边列出了所有的固定服务器角色，用户可以根据需要，在服务器角色前的复选框中打勾，来为登录名添加相应的服务器角色，此处默认已经选择了“public”服务器角色。单击“确定”按钮完成添加。 2．利用系统存储过程添加固定服务器角色成员 利用系统存储过程sp_addsrvrolemember可将一登录名添加到某一固定服务器角色中，使其成为固定服务器角色的成员。语法格式： sp_addsrvrolemember [ @loginame = ] 'login', [@rolename =] 'role' 参数含义：login指定添加到固定服务器角色role的登录名，login可以是SQL Server登录名或Windows 登录名；对于Windows登录名，如果还没有授予SQL Server访问权限，将自动对其授予访问权限。固定服务器角色名role必须为sysadmin、securityadmin、serveradmin、setupadmin、processadmin、diskadmin、dbcreator、bulkadmin和public之一。 【例9.7】 将Windows登录名0BD7E57C949A420\\liu添加到sysadmin固定服务器角色中。 EXEC sp_addsrvrolemember '0BD7E57C949A420\\liu', 'sysadmin' 3．利用系统存储过程删除固定服务器角色成员 利用sp_dropsrvrolemember系统存储过程可从固定服务器角色中删除SQL Server 登录名或Windows登录名。语法格式： sp_dropsrvrolemember[ @loginame = ] 'login' , [ @rolename = ] 'role' 参数含义：'login'为将要从固定服务器角色删除的登录名。'role'为服务器角色名，默认值为NULL，必须是有效的固定服务器角色名。 【例9.8】 从sysadmin固定服务器角色中删除SQL Server登录名david。 EXEC sp_dropsrvrolemember 'david', 'sysadmin' 固定数据库角色 （1）db_owner：数据库所有者，这个数据库角色的成员可执行数据库的所有管理操作。 用户发出的所有SQL语句均受限于该用户具有的权限。例如，CREATE DATABASE仅限于sysadmin和dbcreator固定服务器角色的成员使用。 sysadmin固定服务器角色的成员、db_owner固定数据库角色的成员以及数据库对象的所有者都可授予、拒绝或废除某个用户或某个角色的权限。使用GRANT赋予执行T-SQL语句或对数据进行操作的权限；使用DENY拒绝权限，并防止指定的用户、组或角色从组和角色成员的关系中继承权限；使用REVOKE取消以前授予或拒绝的权限。 （2）db_accessadmin：数据库访问权限管理者，角色成员具有添加、删除数据库使用者、数据库角色和组的权限。 （3）db_securityadmin：数据库安全管理员，角色成员可管理数据库中的权限，如设置数据库表的增加、删除、修改和查询等存取权限。 （4）db_ddladmin：数据库DDL管理员，角色成员可增加、修改或删除数据库中的对象。 （5）db_backupoperator：数据库备份操作员，角色成员具有执行数据库备份的权限。 （6）db_datareader：数据库数据读取者，角色成员可以从所有用户表中读取数据。 （7）db_datawriter：数据库数据写入者，角色成员具有对所有用户表进行增加、删除、修改的权限。 （8）db_denydatareader：数据库拒绝数据读取者，角色成员不能读取数据库中任何表的内容。 （9）db_denydatawriter：数据库拒绝数据写入者，角色成员不能对任何表进行增加、删修、修改操作。 （10）public：是一个特殊的数据库角色，每个数据库用户都是public角色的成员，因此不能将用户、组或角色指派为public角色的成员，也不能删除public角色的成员。通常将一些公共的权限赋给public角色。 1．使用对象资源管理器添加固定数据库角色成员 第1步：以系统管理员身份登录到SQL Server服务器，在对象资源管理器中展开“数据库→PXSCJ→安全性→用户”，选择一个数据库用户，例如“david”，双击或单击右键选择“属性”菜单项，打开“数据库用户”窗口。 第2步：在打开的窗口中，在“常规”选项卡中的“数据库角色成员身份”栏，用户可以根据需要，在数据库角色前的复选框中打勾，来为数据库用户添加相应的数据库角色，如图9.9所示，单击“确定”按钮完成添加。 第3步：查看固定数据库角色的成员。在对象资源管理器窗口中，在PXSCJ数据库下的“安全性→角色→数据库角色”目录下，选择数据库角色，如db_owner，右击选择“属性”菜单项，在属性窗口中的“角色成员”栏下可以看到该数据库角色的成员列表，如图9.10所示。 2．使用系统存储过程添加固定数据库角色成员 利用系统存储过程sp_addrolemember可以将一个数据库用户添加到某一固定数据库角色中，使其成为该固定数据库角色的成员。语法格式： sp_addrolemember[ @rolename = ] 'role', [ @membername = ] 'security_account' 参数含义：'role'为当前数据库中的数据库角色的名称。'security_account'为添加到该角色的安全账户，可以是数据库用户或当前数据库角色。 【例9.9】 将PXSCJ数据库上的数据库用户david（假设已经创建）添加为固定数据库角色db_owner的成员。 USE PXSCJ GO EXEC sp_addrolemember 'db_owner', 'david' 3．使用系统存储过程删除固定数据库角色成员 利用系统存储过程sp_droprolemember可以将某一成员从固定数据库角色中去除。 语法格式： sp_droprolemember [ @rolename = ] 'role' , [ @membername = ] 'security_account' 【例9.10】 将数据库用户david从db_owner中去除。 USE PXSCJ GO EXEC sp_droprolemember 'db_owner', 'david' 自定义数据库角色 1．通过对象资源管理器创建数据库角色 第1步：创建数据库角色。以Windows系统管理员身份连接SQL Server，在对象资源管理器中展开“数据库”，选择要创建角色的数据库（如PXSCJ）→“安全性”→“角色”，右击鼠标，在弹出的快捷菜单中选择“新建”菜单项，在弹出的子菜单中选择“新建数据库角色”菜单项，如图9.11所示。进入“数据库角色-新建”窗口。 第2步：将数据库用户加入数据库角色。 当数据库用户成为某一数据库角色的成员之后，该数据库用户就获得该数据库角色所拥有的对数据库操作的权限。 如图9.12所示是将PXSCJ数据库的用户david加入ROLE1角色。 2．通过SQL命令创建数据库角色 （1）定义数据库角色。创建用户自定义数据库角色可以使用CREATE ROLE语句。 语法格式： CREATE ROLE role_name [ AUTHORIZATION owner_name ] 【例9.11】 如下示例在当前数据库中创建名为ROLE2的新角色，并指定dbo为该角色的所有者。 USE PXSCJ GO CREATE ROLE ROLE2 AUTHORIZATION dbo （2）给数据库角色添加成员。向用户定义数据库角色添加成员也使用存储过程sp_ addrolemember，用法与之前介绍的基本相同。 【例9.12】 使用Windows身份验证模式的登录名（如0BD7E57C949A420\\liu）创建PXSCJ数据库的用户（如0BD7E57C949A420\\liu），并将该数据库用户添加到ROLE1数据库角色中。 USE PXSCJ GO CREATE USER [0BD7E57C949A420\\liu] FROM LOGIN [0BD7E57C949A420\\liu] GO EXEC sp_addrolemember 'ROLE1', '0BD7E57C949A420\\liu' 【例9.13】 将SQL Server登录名创建的PXSCJ的数据库用户wang（假设已经创建）添加到数据库角色ROLE1中。 USE PXSCJ GO EXEC sp_addrolemember 'ROLE1','wang' 【例9.14】 将数据库角色ROLE2（假设已经创建）添加到ROLE1中。 EXEC sp_addrolemember 'ROLE1','ROLE2' 3．通过SQL命令删除数据库角色 要删除数据库角色可以使用DROP ROLE语句。语法格式： DROP ROLE role_name 其中，role_name为要删除的数据库角色的名称。 【例9.15】 删除数据库角色ROLE2。 在删除ROLE2之前首先需要将ROLE2中的成员删除，可以使用界面方式，也可以使用命令方式。若使用界面方式，只需在ROLE2的属性页中操作即可。命令方式在删除固定数据库成员时已经介绍，请参见前面内容。确认ROLE2可以删除后，使用以下命令删除ROLE2： DROP ROLE ROLE2 应用程序角色 在SQL Server 2008中创建应用程序角色并测试的具体步骤如下。 第1步：以系统管理员身份连接SQL Server，在“对象资源管理器”窗口中展开“数据库→PXSCJ→安全性→角色”，右击“应用程序角色”，选择“新建应用程序角色”。 第2步：在“应用程序角色-新建”窗口中输入应用程序角色名称addrole，默认架构dbo，设置密码为123456，如图9.13所示。 在“安全对象”选项卡页面中，可以单击“搜索”按钮，添加“特定对象”，选择对象为表XSB，如图9.14所示。 单击“确定”按钮回到“安全对象”选项卡中，授予表XSB的“选择”权限（如图9.15），完成后单击“确认”按钮。 第3步：新建SQL Server登录名jack，并新建PXSCJ数据库的数据库用户jack（将其添加为db_denydatareader数据库角色的成员），使用“jack”登录名连接SQL Server。在查询窗口中输入如下语句： USE PXSCJ GO SELECT * FROM XSB 运行结果如图9.16所示。 第4步：使用系统存储过程sp_setapprole激活应用程序角色，语句如下： EXEC sp_setapprole 'addrole', '123456' 第5步：在当前查询窗口中重新输入第3步中的查询语句，执行结果如图9.17所示。 数据库权限的管理 授予权限 权限的授予可以使用命令方式或界面方式完成。 （1）使用命令方式授予权限。利用GRANT语句可以给数据库用户或数据库角色授予数据库级别或对象级别的权限。 语法格式： GRANT { ALL [ PRIVILEGES ] } | permission [ ( column [ ,...n ] ) ] [ ,...n ] [ ON securable ] TO principal [ ,...n ] [ WITH GRANT OPTI 【例9.16】 给PXSCJ数据库上的用户david和wang授予创建表的权限。 以系统管理员身份登录SQL Server，新建一个查询，输入以下语句： USE PXSCJ GO GRANT CREATE TABLE TO david, wang GO ON ] [ AS principal ] 【例9.17】 首先在数据库PXSCJ中给public角色授予表XSB的SELECT权限。然后，将其他一些权限授予用户david和wang，使用户有对XSB表的所有操作权限。 以系统管理员身份登录SQL Server，新建一个查询，输入以下语句： USE PXSCJ GO GRANT SELECT ON XSB TO public GO GRANT INSERT, UPDATE, DELETE, REFERENCES ON XSB TO david, wang GO 【例9.18】 将CREATE TABLE权限授予数据库角色ROLE1的所有成员。 以系统管理员身份登录SQL Server，新建一个查询，输入以下语句： GRANT CREATE TABLE TO ROLE1 【例9.19】 以系统管理员身份登录SQL Server，将表XSB的SELECT权限授予ROLE2角色（指定WITH GRANT OPTION子句）。用户li是ROLE2的成员（创建过程略），在li用户上将表XSB上的SELECT权限授予用户huang（创建过程略），huang不是ROLE2的成员。 首先以Windows系统管理员身份连接SQL Server，授予角色ROLE2在XSB表上的SELECT权限： USE PXSCJ GO GRANT SELECT ON XSB TO ROLE2 WITH GRANT OPTION 在“SQL Server Management Studio”窗口上单击“新建查询”按钮旁边的数据库引擎查询按钮“ ”，在弹出的连接窗口中以li用户的登录名登录，如图9.18所示。单击“连接”按钮连接到SQL Server服务器，出现“查询分析器”窗口。 在“查询分析器”窗口中使用如下语句将用户li在XSB表上的SELECT权限授予huang： USE PXSCJ GO GRANT SELECT ON XSB TO huang AS ROLE2 【例9.20】 在当前数据库PXSCJ中给public角色赋予对表XSB中学号、姓名字段的SELECT权限。 以系统管理员身份登录SQL Server，新建一个查询，输入以下语句： USE PXSCJ GO GRANT SELECT (学号,姓名) ON XSB TO public GO （2）使用界面方式授予语句权限。 ① 授予数据库上的权限。以给数据库用户wang（假设该用户已经使用SQL Server登录名“wang”创建）授予PXSCJ数据库的CREATE TABLE语句的权限（即创建表的权限）为例，在SQL Server Management Studio中授予用户权限的步骤如下： 以系统管理员身份登录到SQL Server服务器，在对象资源管理器中展开“数据库→PXSCJ”，右击鼠标，选择“属性”菜单项进入PXSCJ数据库的属性窗口，选择“权限”页。 在用户或角色栏中选择需要授予权限的用户或角色（如wang），在窗口下方列出的权限列表中找到相应的权限（如“创建表”），在复选框中打勾，如图9.19所示。 如图9.19所示。单击“确定”按钮即可完成。如果需要授予权限的用户在列出的用户列表中不存在，则可以单击“搜索”按钮将该用户添加到列表中再选择。选择用户后在如图9.19所示窗口中单击“有效”选项卡可以查看该用户在当前数据库中有哪些权限。 ② 授予数据库对象上的权限。以给数据库用户wang授予KCB表上的SELECT、INSERT的权限为例，步骤如下： 以系统管理员身份登录到SQL Server服务器，在对象资源管理器中展开“数据库→PXSCJ→表→KCB”，右击鼠标，选择“属性”菜单项进入KCB表的属性窗口，选择“权限”选项卡。 单击“搜索”按钮，在弹出的“选择用户或角色”窗口中单击“浏览”按钮，选择需要授权的用户或角色（如wang），选择后单击“确定”按钮回到KCB表的属性窗口。在该窗口中选择用户（如huang），在权限列表中选择需要授予的权限，如“插入（INSERT）”、“选择（SELECT）”，如图9.20所示，单击“确定”按钮完成授权。 拒绝权限 使用DENY命令可以拒绝给当前数据库内的用户授予的权限，并防止数据库用户通过其组或角色成员资格继承权限。 语法格式： DENY { ALL [ PRIVILEGES ] } | permission [ ( column [ ,...n ] ) ] [ ,...n ] [ ON securable ] TO principal [ ,...n ] [ CASCADE] [ AS principal ] 【例9.21】 对多个用户不允许使用CREATE VIEW和CREATE TABLE语句。 DENY CREATE VIEW, CREATE TABLE TO li, huang GO 【例9.22】 拒绝用户li、huang、[0BD7E57C949A420\\liu]对表XSB的一些权限，这样，这些用户就没有对XSB表的操作权限了。 USE PXSCJ GO DENY SELECT, INSERT, UPDATE, DELETE ON XSB TO li, huang, [0BD7E57C949A420\\liu] GO 【例9.23】 对所有ROLE2角色成员拒绝CREATE TABLE权限。 DENY CREATE TABLE TO ROLE2 GO 撤销权限 【例9.22】 拒绝用户li、huang、[0BD7E57C949A420\\liu]对表XSB的一些权限，这样，这些用户就没有对XSB表的操作权限了。 USE PXSCJ GO DENY SELECT, INSERT, UPDATE, DELETE ON XSB TO li, huang, [0BD7E57C949A420\\liu] GO 【例9.23】 对所有ROLE2角色成员拒绝CREATE TABLE权限。 DENY CREATE TABLE TO ROLE2 GO 【例9.26】 取消以前对wang授予或拒绝的在XSB表上的SELECT权限。 REVOKE SELECT ON XSB FROM wang 【例9.27】 角色ROLE2在XSB表上拥有SELECT权限，用户li是ROLE2的成员，li使用WITH GRANT OPTION子句将SELECT权限转移给了用户huang，用户huang不是ROLE2的成员。现要以用户li的身份撤销用户huang的SELECT权限。 以用户“li”的身份登录SQL Server服务器，新建一个查询，使用如下语句撤销huang的SELECT权限： USE PXSCJ GO REVOKE SELECT ON XSB TO huang AS ROLE2 数据库架构的定义和使用 使用界面方式创建架构 以在PXSCJ数据库中创建架构为例，具体步骤如下。 第1步：以系统管理员身份登录SQL Server，在对象资源管理器中展开“数据库→PXSCJ→安全性”，选择“架构”，右击鼠标，在弹出的快捷菜单中选择“新建架构”菜单项。 第2步：在打开的“架构-新建”窗口中选择“常规”选项卡，在窗口右边“架构名称”下面的文本框中输入架构名称（如test）。单击“搜索”按钮，在打开的“搜索角色和用户”对话框中单击“浏览”按钮。如图9.21所示，在打开的“查找对象”对话框中，在用户“david”前面的复选框中打勾，单击“确定”按钮，返回“搜索角色和用户”对话框。单击“确定”按钮，返回“架构-新建”窗口。单击“确定”按钮，完成架构的创建。这样就将用户david设为了架构test的所有者。 第3步：架构创建完后可以新建一个测试表来测试如何访问架构中的对象。在PXSCJ数据库中新建一个名为table_1的表，表的结构如图9.22所示。 在创建表时，表的默认架构为dbo，要将其架构修改为test。在进行表结构设计时，表设计窗口右边有一个表table_1的属性窗口，在创建表时，应在表的属性窗口中将该表的架构设置成test，如图9.23所示。如果没有找到属性窗口，则单击“视图”菜单栏，选择“属性窗口”子菜单就能显示出属性窗口。 设置完成后保存该表，保存后的表可以在对象资源管理器中找到，此时表名就已经变成test. table_1，如图9.24所示。 第4步：在对象资源管理器中展开数据库“PXSCJ→安全性→架构”，选择新创建的架构test，右击鼠标，在弹出的快捷菜单中选择“属性”菜单项，打开“架构属性”窗口，在该架构属性的“权限”选项卡中，单击“搜索”按钮，选择用户owner（假设已经创建），为用户owner分配权限，如“选择（SELECT）”权限，如图9.25所示。单击“确定”按钮，保存上述设置。用同样的方法，还可以授予其他用户访问该架构的权限。 第5步：重新启动SQL Server Management Studio，使用SQL Server身份验证方式，以用户owner的登录名连接SQL Server。在连接成功后，创建一个新的查询，在“查询分析器”窗口中输入查询表test. table_1中数据的T-SQL语句。 USE PXSCJ GO SELECT * FROM test.table_1 执行结果如图9.26所示。 再新建一个SQL查询，在查询编辑器中输入删除表test. table_1的T-SQL语句： DELETE FROM test.table_1 执行结果如图9.27所示。 使用命令方式创建架构 可以使用CREATE SCHEMA语句创建数据库架构。 语法格式： CREATE SCHEMA [ [ , ...n ] ] 其中， ::= { schema_name | AUTHORIZATION owner_name | schema_name AUTHORIZATION owner_name } ::= { table_definition | view_definition | grant_statement revoke_statement | deny_statement } 【例9.28】 创建架构test_schema，其所有者为用户david。 以系统管理员身份登录SQL Server，新建一个查询，输入以下语句： USE PXSCJ GO CREATE SCHEMA test_schema AUTHORIZATION david 另外，要删除可以使用DROP SCHEMA语句，例如， DROP SCHEMA test_schema "},"page/11345.html":{"url":"page/11345.html","title":"数据库备份、恢复、复制","keywords":"","body":"数据库备份、恢复、复制 "},"page/11046.html":{"url":"page/11046.html","title":"MSSQL数据库备份、恢复、复制","keywords":"","body":"数据库备份和恢复 备份和恢复需求分析 数据库中的数据丢失或被破坏可能是由于以下原因： （1）计算机硬件故障。由于使用不当或产品质量等原因，计算机硬件可能会出现故障，不能使用。如硬盘损坏会使得存储于其上的数据丢失。 （2）软件故障。由于软件设计上的失误或用户使用的不当，软件系统可能会误操作数据引起数据破坏。 （3）病毒。破坏性病毒会破坏系统软件、硬件和数据。 （4）误操作。如用户误用了诸如DELETE、UPDATE等命令而引起数据丢失或被破坏。 （5）自然灾害。如火灾、洪水或地震等，它们会造成极大的破坏，会毁坏计算机系统及其数据。 （6）盗窃。一些重要数据可能会遭窃。 1．备份内容 数据库中数据的重要程度决定了数据恢复的必要性与重要性，也就决定了数据是否需要备份及如何备份。数据库需备份的内容可分为数据文件（又分为主要数据文件和次要数据文件）、日志文件两部分。其中，数据文件中所存储的系统数据库是确保SQL Server 2008系统正常运行的重要依据，无疑，系统数据库必须完全备份。 2．由谁做备份 在SQL Server 2008中，具有下列角色的成员可以做备份操作： （1）固定的服务器角色sysadmin（系统管理员）。 （2）固定的数据库角色db_owner（数据库所有者）。 （3）固定的数据库角色db_backupoperator（允许进行数据库备份的用户）。 3．备份介质 备份介质是指将数据库备份到的目标载体，即备份到何处。在SQL Server 2008中，允许使用两种类型的备份介质。 （1）硬盘：是最常用的备份介质，可以用于备份本地文件，也可以用于备份网络文件。 （2）磁带：是大容量的备份介质，磁带仅可用于备份本地文件。 4．何时备份 （1）系统数据库。当系统数据库master、msdb和model中的任何一个被修改以后，都要将其备份。 master数据库包含了SQL Server 2008系统有关数据库的全部信息，即它是“数据库的数据库”。如果master数据库损坏，那么SQL Server 2008可能无法启动，并且用户数据库可能无效。当master数据库被破坏而没有master数据库的备份时，就只能重建全部的系统数据库了。 （2）用户数据库。当创建数据库或加载数据库时，应备份数据库。当为数据库创建索引时，应备份数据库，以便恢复时大大节省时间。 当清理了日志或执行了不记日志的T-SQL命令时，应备份数据库，这是因为若日志记录被清除或命令未记录在事务日志中，日志中将不包含数据库的活动记录，因此不能通过日志恢复数据。不记日志的命令有BACKUP LOG WITH NO_LOG、WRITETEXT、UPDATETEXT、SELECT INTO、命令行实用程序、BCP命令等。 5．限制的操作 SQL Server 2008在执行数据库备份的过程中，允许用户对数据库继续操作，但不允许用户在备份时执行下列操作：创建或删除数据库文件；创建索引；不记日志的命令。 若在系统正执行上述操作中的任何一种时试图进行备份，则备份进程不能执行。 6．备份方法 数据库备份常用的两类方法是完全备份和差异备份。完全备份每次都备份整个数据库或事务日志，差异备份则只备份自上次备份以来发生过变化的数据库的数据。差异备份也称为增量备份。 SQL Server 2008中有两种基本的备份：一是只备份数据库，二是备份数据库和事务日志，它们又都可以与完全或差异备份相结合。另外，当数据库很大时，也可以进行个别文件或文件组的备份，从而将数据库备份分割为多个较小的备份过程。这样就形成了以下4种备份方法： （1）完全数据库备份。 这种方法按常规定期备份整个数据库，包括事务日志。当系统出现故障时，可以恢复到最近一次数据库备份时的状态，但自该备份后所提交的事务都将丢失。 完全数据库备份的主要优点是简单，备份是单一操作，可按一定的时间间隔预先设定，恢复时只需一个步骤就可以完成。 （2）数据库和事务日志备份。 这种方法不需很频繁地定期进行数据库备份，而是在两次完全数据库备份期间，进行事务日志备份，所备份的事务日志记录了两次数据库备份之间所有的数据库活动记录。当系统出现故障后，能够恢复所有备份的事务，而只丢失未提交或提交但未执行完的事务。 执行恢复时，需要两步：首先恢复最近的完全数据库备份，然后恢复在该完全数据库备份以后的所有事务日志备份。 （3）差异备份。 差异备份只备份自上次数据库备份后发生更改的部分数据库，它用来扩充完全数据库备份或数据库和事务日志备份方法。对于一个经常修改的数据库，采用差异备份策略可以减少备份和恢复时间。差异备份比全量备份工作量小而且备份速度快，对正在运行的系统影响也较小，因此可以更经常地备份。经常备份将减少丢失数据的危险。 使用差异备份方法，执行恢复时，若是数据库备份，则用最近的完全数据库备份和最近的差异数据库备份来恢复数据库；若是差异数据库和事务日志备份，则需用最近的完全数据库备份和最近的差异备份后的事务日志备份来恢复数据库。 （4）数据库文件或文件组备份。 这种方法只备份特定的数据库文件或文件组，同时还要定期备份事务日志，这样在恢复时可以只还原已损坏的文件，而不用还原数据库的其余部分，从而加快了恢复速度。 数据库恢复概念 1．准备工作 数据库恢复的准备工作包括系统安全性检查和备份介质验证。在进行恢复时，系统先执行安全性检查、重建数据库及其相关文件等操作，保证数据库安全地恢复，这是数据库恢复必要的准备，可以防止错误的恢复操作。例如，用不同的数据库备份或用不兼容的数据库备份信息覆盖某个已存在的数据库。当系统发现出现了以下情况时，恢复操作将不进行： （1）指定要恢复的数据库已存在，但在备份文件中记录的数据库与其不同； （2）服务器上数据库文件集与备份中的数据库文件集不一致； （3）未提供恢复数据库所需的所有文件或文件组。 安全性检查是系统在执行恢复操作时自动进行的。在恢复数据库时，要确保数据库的备份是有效的，即要验证备份介质，得到数据库备份的信息。这些信息包括: 备份文件或备份集名及描述信息。 所使用的备份介质类型（磁带或磁盘等）。 所使用的备份方法。 执行备份的日期和时间。 备份集的大小。 数据库文件及日志文件的逻辑和物理文件名。 备份文件的大小。 2．执行恢复数据库的操作 可以提供使用图形向导方式或T-SQL语句执行恢复数据库的操作。 备份 创建备份设备 1．创建永久备份设备 若使用磁盘设备备份，那么备份设备实际上就是磁盘文件；若使用磁带设备备份，那么备份设备实际上就是一个或多个磁带。 创建该备份设备有两种方法：使用图形向导方式或使用系统存储过程sp_addumpdevice。 （1）使用系统存储过程创建命名备份设备。执行系统存储过程sp_addumpdevice可以在磁盘或磁带上创建命名备份设备，也可以将数据定向到命名管道。 创建命名备份设备时，要注意以下几点： ① SQL Server 2008将在系统数据库master的系统表sysdevice中创建该命名备份设备的物理名和逻辑名。 ② 必须指定该命名备份设备的物理名和逻辑名，当在网络磁盘上创建命名备份设备时要说明网络磁盘文件路径名。 语法格式： sp_addumpdevice [ @devtype = ] 'device_type' , [ @logicalname = ] 'logical_name' , /*DBMS上*/ [ @physicalname = ] 'physical_name' /*物理磁盘上*/ 【例8.1】 在本地硬盘上创建一个备份设备。 USE master GO EXEC sp_addumpdevice 'disk', 'mybackupfile', 'E:\\data\\mybackupfile.bak' 上例所创建的备份设备的逻辑名是mybackupfile。所创建的备份设备的物理名是E:\\data\\mybackupfile.bak。 【例8.2】 在磁带上创建一个备份设备。 EXEC sp_addumpdevice 'tape', 'tapebackupfile', ' \\\\.\\tape0' /*永久备份设备，以后都能用*/ （2）使用对象资源管理器创建永久备份设备。 在SSMS中创建备份设备，步骤如下。 启动SQL Server Management Studio，在对象资源管理器中展开“服务器对象”，选择“备份设备”，在“备份设备”的列表上可以看到上例中使用系统存储过程创建的备份设备，右击鼠标，在弹出的快捷菜单中选择“新建备份设备”菜单项。 在打开的“备份设备”窗口中分别输入备份设备的名称和完整的物理路径名，单击“确定”按钮，完成备份设备的创建。 当所创建的“命名备份设备”不再需要时，可用图形向导方式或系统存储过程sp_dropdevice删除它。在SQL Server Management Studio中删除“命名备份设备”时，若被删除的“命名备份设备”是磁盘文件，那么必须在其物理路径下用手工删除该文件。 用系统存储过程sp_dropdevice删除命名备份文件时，若被删除的“命名备份设备”的类型为磁盘，那么必须指定DELFILE选项，但备份设备的物理文件一定不能直接保存在磁盘根目录下。例如， EXEC sp_dropdevice 'mybackupfile' , DELFILE 2．创建临时备份设备 例如，如果只要进行数据库的一次性备份或测试自动备份操作，那么就用临时备份设备。 在创建临时备份设备时，要指定介质类型（磁盘、磁带）、完整的路径名及文件名称。可使用T-SQL的BACKUP DATABASE语句创建临时备份设备。对使用临时备份设备进行的备份，SQL Server 2008系统将创建临时文件来存储备份的结果。 语法格式： BACKUP DATABASE { database_name | @database_name_var } TO [, …n ] 其中， ::= { { backup_file_name | @backup_file_name_evar } | { DISK | TAPE } = { temp_file_name | @temp_file_name_evar } 【例8.3】 在磁盘上创建一个临时备份设备，它用来备份数据库PXSCJ。 USE master GO BACKUP DATABASE PXSCJ TO DISK= 'E:\\data\\tmppxscj.bak' /*临时用=，类型disk，存储路径*/ 3．使用多个备份设备 SQL Server可以同时向多个备份设备写入数据，即进行并行的备份。并行备份将需备份的数据分别备份在多个设备上，这多个备份设备构成了备份集。图8.1显示了在多个备份设备上进行备份以及由备份的各组成部分形成备份集。 在用多个备份设备进行并行备份时，要注意： （1）设备备份操作使用的所有设备必须具有相同的介质类型。 （2）多设备备份操作使用的设备其存储容量和运行速度可以不同。 （3）可以使用命名备份设备与临时备份设备的组合。 （4）从多设备备份恢复时，不必使用与备份时相同数量的设备。 图8.1 使用多个备份设备及备份集 备份命令 1．备份整个数据库 语法格式 BACKUP DATABASE { database_name | @database_name_var } /*被备份的数据库名*/ TO [ ,...n ] /*指出备份目标设备*/ [ [ MIRROR TO [ ,...n ] ] [ ...next-mirror ] ] [ WITH [ BLOCKSIZE = { blocksize | @blocksize_variable } ] /*块大小*/ [ [ , ] { CHECKSUM | NO_CHECKSUM } ] [ [ , ] { STOP_ON_ERROR | CONTINUE_AFTER_ERROR } ] [ [ , ] DESCRIPTION = { 'text' | @text_variable } ] [ [ , ] DIFFERENTIAL ] [ [ , ] EXPIREDATE = { date | @date_var } /*备份集到期和允许被重写的日期*/ | RETAINDAYS = { days | @days_var } ] [ [ , ] PASSWORD = { password | @password_variable } ] [ [ , ] { FORMAT | NOFORMAT } ] [ [ , ] { INIT | NOINIT } ] /*指定是覆盖还是追加*/ [ [ , ] { NOSKIP | SKIP } ] [ [ , ] MEDIADESCRIPTION = { 'text' | @text_variable } ] [ [ , ] MEDIANAME = { media_name | @media_name_variable } ] [ [ , ] MEDIAPASSWORD = { mediapassword | @mediapassword_variable } ] [ [ , ] NAME = { backup_set_name | @backup_set_name_var } ] [ [ , ] { NOREWIND | REWIND } ] [ [ , ] { NOUNLOAD | UNLOAD } ] [ [ , ] RESTART ] [ [ , ] STATS [ = percentage ] ] ] 【例8.4】 使用逻辑名test1在E盘中创建一个命名的备份设备，并将数据库PXSCJ完全备份到该设备。 USE master GO EXEC sp_addumpdevice 'disk' , 'test1', 'E:\\data\\test1.bak' BACKUP DATABASE PXSCJ TO test1 图8.2 使用BACKUP语句进行完全数据库备份 【例8.5】 将数据库PXSCJ备份到多个备份设备。 USE master GO EXEC sp_addumpdevice 'disk','test2','E:\\data\\test2.bak' EXEC sp_addumpdevice 'disk','test3','E:\\data\\test3.bak' BACKUP DATABASE PXSCJ TO test2, test3 WITH NAME = 'pxscjbk' 2．差异备份数据库 对于需频繁修改的数据库，进行差异备份可以缩短备份和恢复的时间。只有当已经执行了完全数据库备份后才能执行差异备份。在进行差异备份时，SQL Server将备份从最近的完全数据库备份后数据库发生了变化的部分。 语法格式： BACKUP DATABASE { database_name | @database_name_var } READ_WRITE_FILEGROUPS [ , FILEGROUP = { logical_filegroup_name | @logical_filegroup_name_var } [ ,...n ] ] TO [ , … n ] [ [ MIRROR TO [ ,...n ] ] [ ...next-mirror ] ] [ WITH {[[,] DIFFERENTIAL ] /*其余选项与数据库的完全备份相同*/ } ] SQL Server执行差异备份时需注意下列几点： （1）若在上次完全数据库备份后，数据库的某行被修改了，则执行差异备份只保存最后一次改动的值； （2）为了使差异备份设备与完全数据库备份设备区分开来，应使用不同的设备名。 【例8.6】 创建临时备份设备并在所创建的临时备份设备上进行差异备份。 BACKUP DATABASE PXSCJ TO DISK ='E:\\data\\pxscjbk.bak' WITH DIFFERENTIAL 3．备份数据库文件或文件组 当数据库非常大时，可以进行数据库文件或文件组的备份。 语法格式： BACKUP DATABASE { database_name | @database_name_var } [ ,...f ] /*指定文件或文件组名*/ TO [ ,...n ] [ [ MIRROR TO [ ,...n ] ] [ ...next-mirror ] ] [ WITH { [[,] DIFFERENTIAL ] /*选项与数据库的完全备份相同*/ } ] 其中， ::= { FILE = { logical_file_name | @logical_file_name_var } | FILEGROUP = { logical_filegroup_name | @logical_filegroup_name_var } } 使用数据库文件或文件组备份时，要注意以下几点： （1）必须指定文件或文件组的逻辑名； （2）必须执行事务日志备份，以确保恢复后的文件与数据库其他部分的一致性； （3）应轮流备份数据库中的文件或文件组，以使数据库中的所有文件或文件组都定期得到备份； 【例8.7】 设TT数据库有2个数据文件t1和t2，事务日志存储在文件tlog中。将文件t1备份到备份设备t1backup中，将事务日志文件备份到tbackuplog中。 EXEC sp_addumpdevice 'disk', 't1backup', 'E:\\data\\t1backup.bak' EXEC sp_addumpdevice 'disk', 'tbackuplog', 'E:\\data\\tbackuplog.bak' GO BACKUP DATABASE TT FILE ='t1' TO t1backup BACKUP LOG TT TO tbackuplog 4．事务日志备份 当进行事务日志备份时，系统进行下列操作： （1）将事务日志中从前一次成功备份结束位置开始，到当前事务日志结尾处的内容进行备份。 （2）标识事务日志中活动部分的开始，所谓事务日志的活动部分指从最近的检查点或最早的打开位置开始至事务日志的结尾处。 进行事务日志备份使用BACKUP LOG语句。语法格式： BACKUP LOG { database_name | @database_name_var } /*指定被备份的数据库名*/ { TO [ ,...n ] /*指定备份目标*/ [ [ MIRROR TO [ ,...n ] ] [ ...next-mirror ] ] [ WITH { { NORECOVERY | STANDBY = undo_file_name } | NO_TRUNCATE ] |/*其余选项与数据库的完全备份相同*/ } } 下面讨论三个专用于事务日志备份的选项。 NO_TRUNCATE选项：若数据库被损坏，则应使用NO_TRUNCATE选项备份数据库。使用该选项可以备份最近的所有数据库活动，SQL Server将保存整个事务日志。使用此选项进行数据库备份，当执行恢复时，可以恢复数据库和采用了NO_TRUNCATE选项创建的事务日志。 NORECOVERY选项：该选项将数据备份到日志尾部，不覆盖原有的数据。 STANDBY选项：该选项将备份日志尾部，并使数据库处于只读或备用模式。其中的undo_file_name是要撤销的文件名，该文件名指定了容纳回滚（roll back）更改的存储。如果随后执行RESTORE LOG操作，则必须撤销这些回滚更改。如果指定的撤销文件名不存在，SQL Server将创建该文件；如果该文件已存在，则SQL Server将重写它。 【例8.8】 创建一个命名的备份设备PXSCJLOGBK，并备份PXSCJ数据库的事务日志。 USE master GO EXEC sp_addumpdevice 'disk' , 'PXSCJLOGBK' , 'E:\\data\\testlog.bak' BACKUP LOG PXSCJ TO PXSCJLOGBK 使用对象资源管理器进行备份 以备份PXSCJ数据库为例，在备份之前先在E盘根目录下创建一个备份设备，名称为PXSCJBK，备份设备的文件名为pxscjbk.bak。 在SQL Server Management Studio中进行备份的步骤如下。 第1步：启动SQL Server Management Studio，在对象资源管理器中选择“管理”，右击鼠标，如图8.4所示，在弹出的快捷菜单上选择“备份”菜单项。 第2步：在打开的“备份数据库”窗口（如图8.5所示）中选择要备份的数据库名，如PXSCJ；在“备份类型”栏选择备份的类型，有3种类型：完整、差异、事务日志，这里选择完整备份。 第3步：选择了数据库之后，窗口最下方的目标栏中会列出与PXSCJ数据库相关的备份设备。可以单击“添加”按钮在“选择备份目标”对话框中选择另外的备份目标（即命名的备份介质的名称或临时备份介质的位置），有两个选项：“文件名”和“备份设备”。选择“备份设备”选项，在下拉框中选择需要将数据库备份到的目标备份设备，如mybackupfile，如图8.6所示，单击“确定”按钮。当然，也可以选择“文件名”选项，然后选择备份设备的物理文件来进行备份。 第4步：在“备份数据库”窗口中，将不需要的备份目标选择后单击“删除”按钮删除，最后备份目标选择为“mybackupfile”，单击“确定”按钮，执行备份操作。备份操作完成后，将出现提示对话框，单击“确定”按钮，完成所有步骤。 恢复 检查点 在SQL Server运行过程中，数据库的大部分页存储于磁盘的主数据文件和辅数据文件中，而正在使用的数据页则存储在主存储器的缓冲区中，所有对数据库的修改都记录在事务日志中。日志记录每个事务的开始和结束，并将每个修改与一个事务相关联。 SQL Server系统在日志中存储有关信息，以便在需要时可以恢复（前滚）或撤销（回滚）构成事务的数据修改。日志中的每条记录都由一个唯一的日志序号 （LSN）标识，事务的所有日志记录都链接在一起。 SQL Server系统对修改过的数据缓冲区的内容并不是立即写回磁盘，而是控制写入磁盘的时间，它将在缓冲区内修改过的数据页存入高速缓存一段时间后再写入磁盘，从而实现优化磁盘写入。将包含被修改过但尚未写入磁盘的数据的缓冲区页称为脏页，将脏缓冲区页写入磁盘称为刷新页。对被修改过的数据页进行高速缓存时，要确保在将相应的内存日志映像写入日志文件之前没有刷新任何数据修改，否则将不能在需要时进行回滚。 为了保证能恢复所有对数据页的修改，SQL Server采用预写日志的方法，即将所有内存日志映像都在相应的数据修改前写入磁盘。只要所有日志记录都已刷新到磁盘，则即使在被修改的数据页未被刷新到磁盘的情况下，系统也能够恢复。这时系统恢复可以只使用日志记录，进行事务前滚或回滚，执行对数据页的修改。 SQL Server系统定期将所有脏日志和数据页刷新到磁盘，这就称为检查点。检查点从当前数据库的高速缓冲存储器中刷新脏数据和日志页，以尽量减少在恢复时必须前滚的修改量。 SQL Server恢复机制能够通过检查点在检查事务日志时保证数据库的一致性，在对事务日志进行检查时，系统将从最后一个检查点开始检查事务日志，以发现数据库中所有数据的改变。若发现有尚未写入数据库的事务，则将它们对数据库的改变写入数据库。 数据库的恢复命令 （1）进行安全检查。安全检查是系统的内部机制，是数据库恢复时的必要操作，它可以防止由于偶然的误操作而使用了不完整的信息或其他数据库备份来覆盖现有的数据库。 当出现以下几种情况时，系统将不能恢复数据库： 使用与被恢复的数据库名称不同的数据库名去恢复数据库； 服务器上的数据库文件组与备份的数据库文件组不同； 需恢复的数据库名或文件名与备份的数据库名或文件名不同，例如，当试图将northwind数据库恢复到名为accounting的数据库中，而accounting数据库已经存在时，那么SQL Server将拒绝此恢复过程。 （2）重建数据库。当从完全数据库备份中恢复数据库时，SQL Server将重建数据库文件，并把所重建的数据库文件置于备份数据库时这些文件所在的位置，所有的数据库对象都将自动重建，用户无须重建数据库的结构。 在SQL Server中，恢复数据库的语句是RESTORE。 1．恢复数据库的准备 （1）使用图形界面方式查看所有备份介质的属性。 启动SQL Server Management Studio，在对象资源管理器中展开“服务器对象”，在其中的“备份设备”里面选择欲查看的备份介质，右击鼠标，（如图8.7所示），在弹出的快捷菜单中选择“属性”菜单项。 在打开的“备份设备”窗口中单击“媒体内容”选项卡，如图8.8所示，将显示所选备份介质的有关信息，例如备份介质所在的服务器名、备份数据库名、备份类型、备份日期、到期日及大小等信息。 （2）使用RESTORE HEADONLY、RESTORE FILELISTONLY、RESTORE LABEL ONLY等语句可以得到有关备份介质更详细的信息。 例如，RESTORE HEADERONLY语句的执行结果是在特定的备份设备上检索所有备份集的所有备份首部信息。 语法格式： RESTORE HEADERONLY FROM /*指定还原时要使用的逻辑或物理备份设备*/ [ WITH [ { CHECKSUM | NO_CHECKSUM } ] [ [ , ] { CONTINUE_AFTER_ERROR | STOP_ON_ERROR } ] [ [ , ] FILE = file_number] [ [ , ] MEDIANAME = { media_name | @media_name_variable } ] [ [ , ] MEDIAPASSWORD = { mediapassword | @mediapassword_variable } ] [ [ , ] PASSWORD = { password | @password_variable } ] [ [ , ] REWIND ] [ [ , ] { UNLOAD | NOUNLOAD } ] ] [;] 2．使用RESTORE语句进行数据库恢复 使用RESTORE语句可以恢复用BACKUP命令所做的各种类型的备份，但是需要引起注意的是：对于使用完全恢复模式或大容量日志恢复模式的数据库，在大多数情况下，在完整恢复模式或大容量日志恢复模式下，SQL Server 2008要求先备份日志尾部，然后还原当前附加在服务器实例上的数据库。 “尾日志备份”可捕获尚未备份的日志（日志尾部），是恢复计划中的最后一个相关备份。除非RESTORE语句包含WITH REPLACE或WITH STOPAT子句，否则，还原数据库而不先备份日志尾部将导致错误。 与正常日志备份相似，尾日志备份将捕获所有尚未备份的事务日志记录，但尾日志备份与正常日志备份在下列几个方面有所不同： 如果数据库损坏或离线，则可以尝试进行尾日志备份。仅当日志文件未损坏且数据库不包含任何大容量日志更改时，尾日志备份才会成功。如果数据库包含要备份的、在记录间隔期间执行的大容量日志更改，则仅在所有数据文件都存在且未损坏的情况下，尾日志备份才会成功。 尾日志备份可使用COPY_ONLY 选项独立于定期日志备份进行创建。仅复制备份不会影响备份日志链。事务日志不会被尾日志备份截断，并且捕获的日志将包括在以后的正常日志备份中。这样就可以在不影响正常日志备份过程的情况下进行尾日志备份，例如，为了准备进行在线还原。 如果数据库损坏，尾日志可能会包含不完整的元数据，这是因为某些通常可用于日志备份的元数据在尾日志备份中可能会不可用。使用CONTINUE_AFTER_ERROR进行的日志备份可能会包含不完整的元数据，这是因为此选项将通知进行日志备份，而不考虑数据库的状态。 在创建尾日志备份时，也可以同时使数据库变为还原状态。使数据库离线可保证尾日志备份包含对数据库所做的所有更改，并且随后不对数据库进行更改。当需要对某个文件执行离线还原以便与数据库匹配时，或按照计划故障转移到日志传送备用服务器并希望切换回来时，会用到此操作。 （1）恢复整个数据库。当存储数据库的物理介质被破坏，或整个数据库被误删除或被破坏时，就要恢复整个数据库。在恢复整个数据库时，SQL Server系统将重新创建数据库及与数据库相关的所有文件，并将文件存放在原来的位置。 语法格式。 RESTORE DATABASE { database_name | @database_name_var } /*指定被还原的目标数据库*/ [ FROM [ ,...n ] ] /*指定备份设备*/ [ WITH { [ RECOVERY | NORECOVERY | STANDBY = {standby_file_name | @standby_file_name_var } ] | , [ ,...n ] | , } [ ,...n ] ] [;] 其中， [ ,...n ]::= MOVE 'logical_file_name_in_backup' TO 'operating_system_file_name' [ ,...n ] | REPLACE | RESTART | RESTRICTED_USER | FILE = { backup_set_file_number | @backup_set_file_number } | PASSWORD = { password | @password_variable } | MEDIANAME = { media_name | @media_name_variable } | MEDIAPASSWORD = { mediapassword | @mediapassword_variable } | BLOCKSIZE = { blocksize | @blocksize_variable } | BUFFERCOUNT = { buffercount | @buffercount_variable } | MAXTRANSFERSIZE = { maxtransfersize | @maxtransfersize_variable } | { CHECKSUM | NO_CHECKSUM } | { STOP_ON_ERROR | CONTINUE_AFTER_ERROR } | STATS [ = percentage ] | { REWIND | NOREWIND } | { UNLOAD | NOUNLOAD } ::= | { STOPAT = { 'datetime' | @datetime_var } | STOPATMARK = { 'lsn:lsn_number' } [ AFTER 'datetime' ] | STOPBEFOREMARK = { 'lsn:lsn_number' } [ AFTER 'datetime' ] } 其他选项与之前介绍的BACKUP语句意义类似。 【例8.9】 使用RESTORE语句从一个已存在的命名备份介质PXSCJBK1中恢复整个数据库PXSCJ。 首先创建备份设备PXSCJBK1： USE master GO EXEC sp_addumpdevice 'disk', ' PXSCJBK1', 'E:\\data\\PXSCJBK1.bak' 使用BACKUP命令对PXSCJ数据进行完全备份： BACKUP DATABASE PXSCJ TO PXSCJBK1 恢复数据库的命令如下： RESTORE DATABASE PXSCJ FROM PXSCJBK1 WITH FILE=1, REPLACE 执行结果如图8.9所示。 （2）恢复数据库的部分内容。应用程序或用户的误操作如果无效更新或误删表格等，往往只影响到数据库的某些相对独立的部分。在这些情况下，SQL Server提供了将数据库的部分内容还原到另一个位置的机制，以使损坏或丢失的数据可复制回原始数据库。 语法格式： RESTORE DATABASE { database_name | @database_name_var } [ ,...n ] /*指定需恢复的逻辑文件或文件组的名称*/ [ FROM [ ,...n ] ] WITH PARTIAL, NORECOVERY [ , [ ,...n ] | , ] [ ,...n ] [;] 其中， ::= { FILE = { logical_file_name_in_backup | @logical_file_name_in_backup_var } | FILEGROUP = { logical_filegroup_name | @logical_filegroup_name_var } | READ_WRITE_FILEGROUPS } （3）恢复特定的文件或文件组。若某个或某些文件被破坏或被误删除，则可以从文件或文件组备份中进行恢复，而不必进行整个数据库的恢复。 语法格式： RESTORE DATABASE { database_name | @database_name_var } [ ,...n ] [ FROM [ ,...n ] ] WITH { [ RECOVERY | NORECOVERY ] [ , [ ,...n ] ] } [ ,...n ] [;] （4）恢复事务日志。使用事务日志恢复，可将数据库恢复到指定的时间点。 语法格式： RESTORE LOG { database_name | @database_name_var } [ [ ,...n ] ] [ FROM [ ,...n ] ] [ WITH { [ RECOVERY | NORECOVERY | STANDBY = {standby_file_name | @standby_file_name_var } ] | , [ ,...n ] | , | , } [ ,...n ] ] [;] 其中， ::= | { STOPAT = { 'datetime' | @datetime_var } | STOPATMARK = { 'mark_name' | 'lsn:lsn_number }[ AFTER 'datetime' ] | STOPBEFOREMARK = { 'mark_name' | 'lsn:lsn_number' } [ AFTER 'datetime' ] } 执行事务日志恢复必须在进行完全数据库恢复以后。以下语句是先从备份介质PXSCJBK1进行完全恢复数据库PXSCJ，再进行事务日志事务恢复（假设已经备份了PXSCJ数据库的事务日志到备份设备PXSCJLOGBK1中）。 RESTORE DATABASE PXSCJ FROM PXSCJBK1 WITH NORECOVERY, REPLACE GO RESTORE LOG PXSCJ FROM PXSCJLOGBK1 （5）恢复到数据库快照。可以使用RESTORE语句将数据库恢复到创建数据库快照时的状态。此时恢复的数据库会覆盖原来的数据库。 语法格式： RESTORE DATABASE { database_name | @database_name_var } FROM DATABASE_SNAPSHOT = database_snapshot_name 【例8.10】 创建PXSCJ数据库的快照，并将数据库恢复到创建该快照时的状态。 首先创建PXSCJ数据库的快照： CREATE DATABASE PXSCJ_1 ON ( NAME=PXSCJ, FILENAME='E:\\data\\PXSCJ_1.mdf' ) AS SNAPSHOT OF PXSCJ GO 接着对数据库做一些修改，以确定数据库是否恢复。恢复数据库的语句如下： USE master GO RESTORE DATABASE PXSCJ FROM DATABASE_SNAPSHOT='PXSCJ_1' 第1步：启动SQL Server Management Studio，在对象资源管理器中展开“数据库”，选择需要恢复的数据库。 第2步：如图8.10所示，选择“PXSCJ”数据库，右击鼠标，在弹出的快捷菜单中选择“任务”菜单项，在弹出的“任务”子菜单中选择“还原”菜单项，在弹出的“还原”子菜单中选择“数据库”菜单项，进入“还原数据库-PXSCJ”窗口。 如图8.12所示，单击“确定”按钮，返回“指定备份”窗口，再单击“确定”按钮，返回“还原数据库-PXSCJ”窗口。 第4步：选择完备份设备后，“还原数据库-PXSCJ”窗口的“选择用于还原的备份集”栏中会列出可以进行还原的备份集，在复选框中选中备份集，如图8.13所示。 第5步：在如图8.13所示窗口中单击最左边“选项”页，在窗口右边勾选“覆盖现有数据库”项，如图8.14所示，单击“确定”按钮，系统将进行恢复并显示恢复进度。 复制数据库 启动SQL Server配置管理器的方法在第1章中已经介绍。进入SQL Server配置管理器后，双击SQL Server代理服务，弹出SQL Server代理的属性框，如图8.15所示，单击“启动”按钮，启动该服务后就可以使用“复制数据库向导”了。 也可以直接在对象资源管理器中启动SQL Server 代理服务：在“对象资源管理器”窗口中右击“SQL Server代理”，选择“启动”选项，如图8.16所示。在弹出的“确认”对话框中单击“是”按钮即可。 使用“复制数据库向导”复制数据库的具体步骤如下。 第1步：启动SQL Server Management Studio，在“对象资源管理器”窗口中右击“管理”，选择“复制数据库”选项，打开“欢迎使用复制数据库向导”窗口，单击“下一步”按钮。 第2步：进入“选择源服务器”窗口，如图8.17所示，还可以选择身份验证方式，这里按照默认设置，单击“下一步”按钮。 第3步：进入“选择目标服务器”窗口，目标服务器默认为本地服务器，也可以单击文本框后的按钮，在弹出的目标服务器窗口中选择网络服务器。这里不做修改，单击“下一步”按钮。 第4步：进入“选择传输方法”窗口，这里选择默认的方法，单击“下一步”按钮。 第5步：进入“选择数据库”窗口，这里选择要复制的数据库，如PXSCJ，在要选择的数据库前的复选框中打勾。如果要复制数据库，则在“复制”选项中打勾；如果要移动数据库，则在“移动”选项中打勾。如图8.18所示，单击“下一步”按钮。 第6步：进入“配置目标数据库”窗口，在目标数据库中可以改写目标数据库的名称，另外还可以修改目标数据库的逻辑文件和日志文件的文件名和路径，如图8.19所示。 第7步：单击“下一步”按钮进入“配置包”窗口，这里按照默认设置，单击“下一步”按钮。 第8步：进入“安排运行包”窗口，这里选择“立即运行”选项，单击“下一步”按钮。进入“完成该向导”窗口，单击“完成”按钮开始复制数据库。 "},"page/11244.html":{"url":"page/11244.html","title":"数据库快照、分离、附加","keywords":"","body":"数据库快照、分离、附加 "},"page/11245.html":{"url":"page/11245.html","title":"MSSQL快照、分离、附加","keywords":"","body":"快照 快照可用于报表。另外，如果源数据库出现用户错误，还可将源数据库恢复到创建快照时的状态。丢失的数据仅限于创建快照后数据库更新的数据。 在SQL Server 2008中，创建数据库快照也使用CREATE DATABASE命令。语法格式如下： CREATE DATABASE database_snapshot_name ON ( NAME = logical_file_name, FILENAME = 'os_file_name' ) [ ,...n ] AS SNAPSHOT OF source_database_name [;] 【例2.14】 创建PXSCJ数据库的快照PXSCJ_01。 CREATE DATABASE PXSCJ_01 ON ( NAME=PXSCJ, FILENAME='D:\\data\\PXSCJ_01.mdf' ) AS SNAPSHOT OF PXSCJ GO 命令执行成功之后，在对象资源管理器中刷新“数据库”菜单栏，在“数据库”中展开“数据库快照”，就可以看见刚刚创建的数据库快照PXSCJ_01了。 删除数据库快照的方法和删除数据库的方法完全相同，可以使用界面方式删除，也可以使用命令方式删除，例如， DROP DATABASE PXSCJ_01; MS分离与附加 查看数据库存在哪 分离 附加 在复制数据库文件时，一定要先通过SQL Server配置管理器停止SQL Server服务，然后才能复制数据文件，否则无法复制。 假设有一个JSCJ数据库的数据文件和日志文件都保存在E盘根目录下，那么通过附加数据库的方法将数据库JSCJ导入本地服务器的具体步骤如下。 第1步：启动SQL Server Management Studio，在对象资源管理器中右击“数据库”，选择“附加”选项，进入“附加数据库”窗口，单击“添加”按钮，选择要导入的数据库文件JSCJ.mdf。 第2步：选择后单击“确定”按钮，返回“附加数据库”窗口。此时“附加数据库”窗口中列出了要附加的数据库的原始文件和日志文件的信息，如图8.20所示。确认后单击“确定”按钮开始附加JSCJ数据库。成功后将会在“数据库”列表中找到JSCJ数据库。 查看 "},"page/11199.html":{"url":"page/11199.html","title":"函数","keywords":"","body":"函数 SQL Server 2008内置了大量的函数，如时间函数、统计函数、游标函数等，极大地方便程序员的使用。 在Transact-SQL程序中常用的系统内置函数可以分为四种类型：字符串处理函数、聚合函数、时间函数和数学函数。 "},"page/11302.html":{"url":"page/11302.html","title":"MSSQL函数","keywords":"","body":"MSSQL函数 SQL Server 2008内置了大量的函数，如时间函数、统计函数、游标函数等，极大地方便程序员的使用。 在Transact-SQL程序中常用的系统内置函数可以分为四种类型：字符串处理函数、聚合函数、时间函数和数学函数。 系统内置函数介绍 1．行集函数 行集函数是返回值为对象的函数，该对象可在T-SQL语句中作为表引用。所有行集函数都是非确定性的，即每次用一组特定参数调用它们时，所返回的结果不总是相同的。 SQL Server 2008主要提供了如下行集函数： （1）CONTAINSTABLE：对于基于字符类型的列，按照一定的搜索条件进行精确或模糊匹配，然后返回一个表，该表可能为空。 （2）FREETEXTTABLE：为基于字符类型的列返回一个表，其中的值符合指定文本的含义，但不符合确切的表达方式。 （3）OPENDATASOURCE：提供与数据源的连接。 （4）OPENQUERY：在指定数据源上执行查询。可以在查询的 FROM 子句中像引用基本表一样引用OPENQUERY函数，虽然查询可能返回多个记录，但 OPENQUERY 只返回第一个记录。 （5）OPENROWSET：包含访问OLE DB数据源中远程数据所需的全部连接信息。可在查询的FROM子句中像引用基本表一样引用OPENROWSET函数，虽然查询可能返回多个记录，但OPENROWSET只返回第一个记录。 （6）OPENXML函数：通过XML文档提供行集视图。 2．聚合函数 聚合函数对一组值操作，返回单一的汇总值。聚合函数在以下情况下，允许作为表达式使用： （1）SELECT语句的选择列表（子查询或外部查询）。 （2）COMPUTE或COMPUTE BY子句。 （3）HAVING子句。 T-SQL语言提供的常用聚合函数的应用请参考查询相关内容。 3．标量函数 标量函数的特点：输入参数的类型为基本类型，返回值也为基本类型。SQL Server包含如下几类标量函数： （1）配置函数； （2）系统函数； （3）系统统计函数； （4）数学函数； （5）字符串函数； （6）日期和时间函数； （7）游标函数； （8）文本和图像函数； （9）元数据函数； （10）安全函数。 "},"page/11200.html":{"url":"page/11200.html","title":"聚合函数","keywords":"","body":"聚合函数 2. 聚合函数 （1）COUNT函数 该函数用于返回组中的项数，其语法如下： COUNT({[[ALL|DISTINCT] expression]|*}) 该函数有三种调用形式：  COUNT(*)：返回组中的行数，包括NULL值和重复行。  COUNT(ALL expression)：对组中的每一行都计算expression并返回非NULL值的个数，式中的ALL可以省略。  COUNT(DISTINCT expression)：对组中的每一行都计算expression并返回唯一非空值的个数。 （2）AVG函数 该函数返回组中各值的平均值，NULL被忽略。其语法如下： AVG( [ ALL | DISTINCT ] expression ) 【例子】 求女学生的平均成绩，可以用下列的语句来完成： SELECT AVG(s_avgrade) FROM student WHERE s_sex = '女' （3）MAX函数 该函数的语法格式如下： MAX([ ALL | DISTINCT ] expression ) ​ 它返回表达式的最大值 （4）MIN函数 该函数的语法格式如下： MIN([ ALL | DISTINCT ] expression ) ​ 它返回表达式的最小值。 （5）SUM函数 该函数的语法格式如下： SUM([ ALL | DISTINCT ] expression ) ​ 当选择ALL（默认）时，它返回表达式expression中所有值的和；当选择DISTINCT时，它返回仅非重复值的和。NULL值被忽略。 "},"page/11279.html":{"url":"page/11279.html","title":"MSSQL","keywords":"","body":"MSSQL 聚合函数表 函 数 名 说 明 AVG 求组中值的平均值 BINARY_CHECKSUM 返回对表中的行或表达式列表计算的二进制校验值，可用于检测表中行的更改 CHECKSUM 返回在表的行上或在表达式列表上计算的校验值，用于生成哈希索引 CHECKSUM_AGG 返回组中值的校验值 COUNT 求组中项数，返回int类型整数 COUNT_BIG 求组中项数，返回bigint类型整数 GROUPING 产生一个附加的列 GROUPING_ID 为聚合列列表中的每一行创建一个值以标识聚合级别 MAX 求最大值 MIN 求最小值 SUM 返回表达式中所有值的和 STDEV 返回给定表达式中所有值的统计标准偏差 STDEVP 返回给定表达式中所有值的填充统计标准偏差 VAR 返回给定表达式中所有值的统计方差 VARP 返回给定表达式中所有值的填充统计方差 下面对常用的聚合函数加以介绍。 （1）SUM和AVG SUM和AVG分别用于求表达式中所有值项的总和与平均值，语法格式为 SUM /AVG ( [ ALL | DISTINCT ] expression ) ​```sql 其中，expression是常量、列、函数或表达式，其数据类型只能是int、smallint、tinyint、bigint、decimal、numeric、float、real、money和smallmoney。ALL表示对所有值进行运算，DISTINCT表示去除重复值，默认为ALL。SUM / AVG忽略NULL值。 ​```sql 【例4.9】 求选修101课程的学生的平均成绩。 SELECT AVG(成绩) AS '课程101平均成绩' FROM CJB WHERE 课程号 = '101' 使用聚合函数作为SELECT的选择列时，若不为其指定列标题，则系统将对该列输出标题“无列名”。 【例4.10】 求学号为081101的同学所学课程的总成绩。 SELECT SUM(成绩) AS '课程总成绩' FROM CJB WHERE 学号 = '081101'; 结果为234。 （2）MAX和MIN MAX和MIN分别用于求表达式中所有值项的最大值与最小值，语法格式为 MAX / MIN ( [ ALL | DISTINCT ] expression ) 其中，expression是常量、列、函数或表达式，其数据类型可以是数字、字符和时间日期类型。ALL、DISTINCT的含义及默认值与SUM/AVG函数相同。MAX/MIN忽略NULL值。 【例4.11】 求选修101课程的学生的最高分和最低分。 SELECT MAX(成绩) AS '课程101的最高分' , MIN(成绩) AS '课程101的最低分' FROM CJB WHERE 课程号 = '101' 执行结果如下： |课程101的最高分 |课程101的最低分 | |--- |--- | | 95 | 62 | （3）COUNT COUNT用于统计组中满足条件的行数或总行数，格式为 COUNT ( { [ ALL | DISTINCT ] expression } | * ) 其中，expression是一个表达式，其数据类型是除text、image或ntext之外的任何类型。ALL、DISTINCT的含义及默认值与SUM/AVG函数相同，COUNT忽略NULL值。 【例4.12】 求学生的总数。 SELECT COUNT(*) AS '学生总数' FROM XSB 学生总数为22，使用COUNT(*)时将返回检索行的总数目，不论其是否包含 NULL值。 【例4.13】 统计备注不为空的学生数。 SELECT COUNT(备注) AS '备注不为空的学生数' FROM XSB; 【例4.14】 统计总学分在50分以上的人数。 SELECT COUNT(总学分) AS '总学分在50分以上的人数' FROM XSB WHERE 总学分>50; 执行结果为2。 【例4.15】 求选修了课程的学生总数。 SELECT COUNT(DISTINCT 学号) FROM CJB COUNT_BIG函数的格式、功能与COUNT函数都相同，区别仅在于COUNT_BIG返回bigint类型值。 "},"page/11218.html":{"url":"page/11218.html","title":"字符串处理函数","keywords":"","body":"字符串处理函数 1. 字符串处理函数 （1）ASCII函数 该函数的语法如下： ASCII ( character_expression ) 　　character_expression为char或varchar类型的字符串表达式。其作用是以int类型返回字符串表达式character_expression中第一个字符的ASCII值。 【例子】 ASCII ('Abcd')返回65，ASCII ('abcd')返回97等（'A'和'a'的ASCII值分别为65和97）。 （2）SUBSTRING函数 该函数的语法如下： SUBSTRING( expression ,start , length ) 　　 该函数的作用是返回给定字符expression中的一个子串，该子串是从位置start开始、长度为length的字符串。其中，expression可以是字符串、二进制字符串、文本、图像、列或包含列的表达式，但不能使用包含聚合函数的表达式，start , length都是整型数据。 【例子】 SU BSTRING('abcdef',2, 4)返回'bcde'，SUBSTRING('abcdef',2, 1)返回'b'等。 （3）LEFT函数 该函数的语法如下： LEFT(character_expression, integer_expression) 　　其作用是返回字符串character_expression中从左边开始的integer_expression个字符。 【例子】 打印学生的姓氏，可以用下列的语句来实现（不考虑复姓）： SELECT LEFT(s_name,1) FROM student （4）REPLACE函数 该函数的语法如下： REPLACE(string_expression1 , string_expression2, string_expression3) 　　其作用是用第三个表达式string_expression3替换第一个字符串表达式string_expression1中出现的所有第二个指定字符串表达式string_expression2的匹配项，并返回替换后的字符串表达式。 【例子】 REPLACE('abcdefghicde','cd','China')将返回'abChinaefghiChinae'。 "},"page/11280.html":{"url":"page/11280.html","title":"MSSQL","keywords":"","body":"MSSQL 字符串处理函数 字符串处理函数 函数语法 功能描述 举例 ASCII (character_expression) 返回字符串表达式中第一个字符的ASCII值（int型） ASCII('abcdef')返回97 CHAR ( integer_expression ) 将ASCII值转换为相应的字符，并返回该字符 CHAR(65)返回'A'，CHAR(97)返回'a' CHARINDEX(expression1 ,\u000bexpression2[,start_location] ) 返回字符串中指定表达式的开始位置。如果指定start_location，则表示从位置start_location开始查找指定的字符串以返回其开始位置。如果没有匹配则返回0 CHARINDEX('be','aabecdefbeghi')返回3，CHARINDEX('be','aabecdefbeghi',4)返回9 LEFT(character_expression, integer_expression) 返回字符串character_expression中从左边开始的integer_expression个字符。 LEFT('abcdef',3)返回'abc' LEN( string_expression ) 返回指定字符串表达式的字符（而不是字节）个数，其中不包含尾随空格。 LEN('a bcdefg ')返回8 LOWER(character_expression) 将大写字符数据转换为小写字符数据后返回字符表达式。 LOWER('AbCdEfG')返回'abcdefg' LTRIM(character_expression) 返回删除起始空格之后的字符表达式 LTRIM(' abcdef ')返回'abcdef ' NCHAR(integer_expression) 根据Unicode标准的定义，返回具有指定的整数代码的Unicode字符 NCHAR(197)返回'Å' PATINDEX('%pattern%',expression ) 返回指定表达式中某模式第一次出现的起始位置。如果在全部有效的文本和字符数据类型中没有找到该模式，则返回零。可以使用通配符 PATINDEX('%defg%','abcdefghidefg')返回4 QUOTENAME('character_string'[,'quote_character' ] ) 返回带有分隔符的 Unicode 字符串 QUOTENAME('abcdef','''')返回'abcdef'， QUOTENAME('abcdef','(')返回' (abcdef) ' 函数语法 功能描述 举例 REPLACE(str_expression1, str_expression2, str_expression3) 用第三个表达式str_expression3替换第一个字符串表达式str_expression1中出现的所有第二个指定字符串表达式str_expression 2的匹配项，并返回替换后的字符串表达式。 REPLACE('abcdefghicde','cd','China')返回'abChinaefghiChinae'。 REVERSE ( character_expression ) 将字符表达式中的字符首尾反转，然后返回反转后的字符串 REVERSE('abcdefg')返回'gfedcba' RIGHT(character_expression, integer_expression) 返回字符串character_expression中从右边开始的integer_expression个字符 RIGHT('abcdef',3)返回'def' RTRIM(character_expression) 返回删除尾随空格之后的字符表达式 RTRIM(' abcdef ')返回' abcdef' SPACE(integer_expression) 返回由integer_expression个空格组成的字符串 'a'+SPACE(4)+'b'返回'a b' STR(float_expression[,length[,] ] ) 返回由数字数据转换来的字符数据 STR(123.4588, 10, 4)返回'123.4588' STUFF(character_expression,start,length,character_expression) 在字符串character_expression中从位置start开始删除start,length个字符，然后又从该位置插入字符串character_expression，最后返回处理后的字符串 STUFF('abcdefgh',2,3,'xyz')返回'axyzefgh' SUBSTRING(expression,start,length) 返回给定字符expression中的一个子串，该子串是从位置start开始、长度为length的字符串 SUBSTRING('abcdef',2, 4)返回'bcde' UNICODE('ncharacter_expression') 按照Unicode标准的定义，返回输入表达式的第一个字符的整数值 UNICODE(N'Åkergatan 24')返回197 UPPER(character_expression) 返回小写字符数据转换为大写的字符表达式 UPPER('AbCdEfG')返回'ABCDEFG' （1）ASCII函数 该函数的语法如下： ASCII ( character_expression ) character_expression为char或varchar类型的字符串表达式。其作用是以int类型返回字符串表达式character_expression中第一个字符的ASCII值。 【例子】 ASCII ('Abcd')返回65，ASCII ('abcd')返回97等（'A'和'a'的ASCII值分别为65和97）。 （2）SUBSTRING函数 该函数的语法如下： SUBSTRING( expression ,start , length ) 该函数的作用是返回给定字符expression中的一个子串，该子串是从位置start开始、长度为length的字符串。其中，expression可以是字符串、二进制字符串、文本、图像、列或包含列的表达式，但不能使用包含聚合函数的表达式，start , length都是整型数据。 【例子】 SU BSTRING('abcdef',2, 4)返回'bcde'，SUBSTRING('abcdef',2, 1)返回'b'等。 （3）LEFT函数 该函数的语法如下： LEFT(character_expression, integer_expression) 其作用是返回字符串character_expression中从左边开始的integer_expression个字符。 【例子】 打印学生的姓氏，可以用下列的语句来实现（不考虑复姓）： SELECT LEFT(s_name,1) FROM student （4）REPLACE函数 该函数的语法如下： REPLACE(string_expression1 , string_expression2, string_expression3) 其作用是用第三个表达式string_expression3替换第一个字符串表达式string_expression1中出现的所有第二个指定字符串表达式string_expression2的匹配项，并返回替换后的字符串表达式。 【例子】 REPLACE('abcdefghicde','cd','China')将返回'abChinaefghiChinae'。 "},"page/11219.html":{"url":"page/11219.html","title":"数学函数","keywords":"","body":"数学函数 "},"page/11281.html":{"url":"page/11281.html","title":"MSSQL","keywords":"","body":"MSSQL 数学函数 数学函数用于对数值型字段和表达式进行处理，常用的函数如表所示 数学函数 函数语法 功能描述 举例 ABS(x) 返回x的绝对值，x为float类型数据 ABS(-1.23)返回1.23 ACOS(x) 返回x的反余弦值con-1(x)，x[0,1] ACOS(-1.0)返回3.14159 ASIN 返回x的反正弦值sin-1(x)，x[0,1] ASIN(-1.0)返回-1.5708 ATAN 返回x的反正切值tan-1(x)，x为float类型数据 ATAN(-.40)返回-0.380506 ATN2(x, y) 返回x/y的反正切值tan-1(x/y)，x,y为float类型数据 ATN2(1.6,4)返回0.380506 CEILING(x) 返回大于或等于x的最小整数，x为float类型数据 CEILING(3.9)返回4 COS(x) 返回x的三角余弦值，x是以float类型表示的弧度值 COS(3.14159)返回1.0 COT(x) 返回x的三角余切值，x是以float类型表示的弧度值 COT(0.5)返回1.83049 DEGREES(x) 将角度的弧度值x转化为角度的度数值并返回该度数值 DEGREES(3.14)返回179.9 EXP(x) 返回x的指数值ex，x为float类型数据 EXP(1.0)返回2.71828 FLOOR(x) 返回小于或等于x的最大整数，x为float类型数据 FLOOR(3.9)返回3 函数语法 功能描述 举例 LOG(x) 返回x的自然对数，x为float类型数据 LOG(10.0)返回2.30259 LOG10(x) 返回x的以10为底的对数，x为float类型数据 LOG(10.0)返回1.0 PI() 返回圆周率的常量值 PI()返回3.14159265358979 POWER(x, y) 返回x的y次幂的值xy POWER(2, 3)返回8 RADIANS(x) 将角度的度数值x转化为角度的弧度值并返回该弧度值 RADIANS(179.9)返回3.13984732 RAND([seed]) 返回从0到1之间的随机float值 RAND()返回0.588327等 ROUND(x,length) 按照指定精度对x进行四舍五入，length为精确的位数 ROUND(748.58678,4)返回 748.58680，ROUND(748.58678, -2)返回700.00000等 SIGN(x) 返回x的正号 (+1)、零 (0) 或负号 (-1)，x为float类型数据 SIGN(100)返回1，SIGN(-100)返回-1，SIGN(0)返回0等 SIN 返回x的三角正弦值，x为角度的幅度值（float类型） SIN(3.14159/2)返回1.0 SQRT(x) 返回x的平方根，x为非负的float类型数据 SQRT(9)返回3 SQUARE(x) 返回x的平方，x为float类型数据 SQUARE(3)返回9 TAN(x) 返回x的正切值，x为float类型数据 TAN(3.14159)返回0.0 VARP([ALL\\ DISTINCT] expression) 返回表达式expression（通常是列）中所有值的总体方差 SELECT VARP(s_avgrade)FROM student返回264.79等 数学函数可对SQL Server提供的数字数据（decimal、integer、float、real、money、smallmoney、smallint 和 tinyint）进行数学运算并返回运算结果。在默认情况下，对float数据类型数据的内置运算的精度为6个小数位。 （1）ABS函数。 语法格式 ABS(numeric_expression) 返回给定数字表达式的绝对值。参数numeric_expression为数字型表达式（bit数据类型除外），返回值类型与numeric_expression相同。 显示ABS 函数对三个不同数字的效果。 SELECT ABS(-5.0), ABS(0.0), ABS(8.0) 运行结果如下： （2）RAND函数。语法格式： RAND ([ seed ] ) 返回0～1之间的一个随机值。参数seed是指定种子值的整型表达式，返回值类型为float。如果未指定seed，则随机分配种子值。对于指定的种子值，返回的结果始终相同。 【例5.24】 以下程序通过RAND函数返回随机值。 DECLARE @count int SET @count = 5 SELECT RAND(@count) "},"page/11220.html":{"url":"page/11220.html","title":"日期时间函数","keywords":"","body":"日期时间函数 "},"page/11282.html":{"url":"page/11282.html","title":"MSSQL","keywords":"","body":"MSSQL 日期时间函数 常用的日期时间函数说明如表示 日期时间函数 函数语法 功能描述 举例 DATEADD(datepart , number, date ) 返回给指定日期加上一个时间间隔后的新 datetime 值 DATEADD(year, 18, '07 18 2017') 返回'07 18 2035 12:00AM'，DATEADD(day, 18, '07 18 2017')返回'08 5 2017 12:00AM' DATEDIFF(datepart,startdate, enddate) 返回跨两个指定日期的日期边界数和时间边界数 DATEDIFF(year, '07 18 2017', '07 18 2020')返回3，DATEDIFF(month, '07 18 2017', '07 18 2020')返回36 DATENAME(datepart,date) 返回表示指定日期的指定日期部分的字符串 DATENAME(day,'07 18 2017')返回'18'，DATENAME(month,'07 18 2017')返回'07' DATEPART(datepart,date) 返回表示指定日期的指定日期部分的整数 DATEPART(day,'07 18 2017')返回18，DATENAME(month,'07 18 2017')返回07 DAY(date) 返回表示指定日期的天的整数 DAY('07/18/2017') 返回18 GETDATE() 返回当前系统日期和时间 GETDATE()返回'07 17 2017 4:31PM' GETUTCDATE() 返回表示当前的UTC时间（通用协调时间或格林尼治标准时间）的datetime值 如GETUTCDATE()可以返回'07 17 2017 8:31AM'（此时GETDATE()返回'07 17 2017 4:31PM'） MONTH(date) 返回表示指定日期的月份的整数 MONTH('07/18/2017')返回7，MONTH('12/18/2017') 返回12 YEAR(date) 返回表示指定日期的年份的整数 YEAR('07/18/2017')返回2017，YEAR('12/18/2020') 返回2020 日期时间函数可用在SELECT语句的选择列表或查询的WHERE子句中。 （1）GETDATE函数。语法格式： GETDATE () 按SQL Server标准内部格式返回当前系统日期和时间。返回值类型为datetime。 （2）YEAR、MONTH、DAY函数。这三个函数分别返回指定日期的年、月、天部分，返回值都为整数。语法格式： YEAR(date) MONTH(date) DAY(date) "},"page/11221.html":{"url":"page/11221.html","title":"数据类型转换函数","keywords":"","body":"数据类型转换函数 "},"page/11283.html":{"url":"page/11283.html","title":"MSSQL","keywords":"","body":"MSSQL 数据类型转换函数 （1）CAST函数和CONVERT函数 CAST函数函数用于将一种数据类型的表达式显式转换为另一种数据类型的表达式。其语法如下： CAST(expression AS data_type [(length )]) 即将表达式expression的值转换为data_type类型的数据，并返回转化后的数据类型。常使用的类型转换主要包括以下几种： 数值型 字符串型 字符串型 日期时间型 CAST(10.6496 AS int) -- 将常量10.6496转化int类型数据，结果变为10 CAST('abc' AS varchar(5)) -- 将常量'abc'转化为varchar(5)类型 CAST('100' AS int) -- 将字符串常量'100'转化为数值常量100 CAST(100 AS varchar(5)) -- 将数值常量100转化字符串常量'100' CAST('2017/12/12' AS datetime) -- 将字符串常量'2017/12/12'转化为时间常量12 12 2017 CAST(GETDATE() AS VARCHAR(20)) -- 将当前系统时间转化为字符串常量 查询成绩在70到80（不含80）分之间的学生，可以用下列的语句实现： SELECT * FROM student WHERE CAST(s_avgrade AS varchar(10)) like '7%' 该语句首先将成绩转换为字符串，然后将70到80之间的分数看作是以7开头的字符串，最后通过利用模糊查询来实现该查询功能。它等价于下列的SELECT语句： SELECT * FROM student WHERE s_avgrade >= 70 and s_avgrade ​ CONVERT函数与CAST函数的功能相似，都是用于将一种数据类型的表达式显式转换为另一种数据类型的表达式，但CONVERT函数的功能更强一些。其语法如下： CONVERT( data_type [ ( length ) ] , expression [ , style ] ) ​ 与CAST函数不同的是，在CONVERT函数中被转换的表达式靠近函数式的右边，而在CONVERT函数中则靠近左边。 【例子】下列语句中使用了CONVERT函数，该语句与上述查询语句等价： SELECT * FROM student WHERE CONVERT(varchar(10), s_avgrade) like '7%' 说明 这两个函数将expression表达式的类型转换为data_type所指定的类型。参数expression可为任何有效的表达式，data_type可为系统提供的基本类型，不能为用户自定义类型，当data_type 为nchar、nvarchar、char、varchar、binary或varbinary 等数据类型时，可以通过length参数指定长度。对于不同的表达式类型转换，参数style的取值不同。style的常用取值及其作用如表5.13～表5.15所示。 表5.13 日期型与字符型转换时style的常用取值及其作用 不带世纪数位（yy） 带世纪数位（yyyy） 标 准 输入/输出 0或100 默认值 mon dd yyyy hh:miAM(或 PM) 1 101 美国 mm/dd/yyyy 2 102 ANSI yy.mm.dd 9或109 默认值 + 毫秒 mon dd yyyy hh:mi:ss:mmmAM(或 PM) 10 110 美国 mm-dd-yy 12 112 ISO Yymmdd 表5.14 float 或 real转换为字符型数据时style的取值 style值 输 出 0（默认值） 根据需要使用科学记数法，长度最多为6 1 使用科学记数法，长度为8 2 使用科学记数法，长度为16 表5.15 从money或smallmoney转换为字符数据时style的取值 值 输 出 0（默认值） 小数点左侧每3位数字之间不以逗号分隔，小数点右侧取两位数，例如 4235.98 1 小数点左侧每3位数字之间以逗号分隔，小数点右侧取两位数，例如 3,510.92 2 小数点左侧每3位数字之间不以逗号分隔，小数点右侧取四位数，例如 4235.9819 【例5.30】 如下程序将检索总学分在50～59分之间的学生姓名，并将总学分转换为char(20)。 /*如下例子同时使用 CAST 和 CONVERT*/ /*使用CAST实现*/ USE PXSCJ GO SELECT 姓名, 总学分 FROM XSB WHERE CAST(总学分AS char(20)) LIKE '5_' AND 总学分>=50 /*使用 CONVERT实现*/ SELECT 姓名, 总学分 FROM XSB WHERE CONVERT(char(20), 总学分) LIKE '5_' AND总学分>=50 （2）COALESCE函数。 语法格式： COALESCE ( expression [ ,...n ] ) 返回参数表中第一个非空表达式的值，如果所有自变量均为NULL，则COALESCE返回NULL值。参数expression可为任何类型的表达式。n表示可以指定多个表达式。所有表达式必须是相同类型的，或者可以隐性转换为相同的类型。 COALESCE(expression1,...n) 与如下形式的CASE 语句等价： CASE WHEN (expression1 IS NOT NULL) THEN expression1 ... WHEN (expressioN IS NOT NULL) THEN expressionN ELSE NULL （3）ISNUMBRIC函数。 ISNUMBRIC函数用于判断一个表达式是否为数值类型。 语法格式： ISNUMBRIC(expression) "},"page/11222.html":{"url":"page/11222.html","title":"用户自定义函数","keywords":"","body":"用户自定义函数 "},"page/11284.html":{"url":"page/11284.html","title":"MSSQL","keywords":"","body":"MSSQL 用户自定义函数 　　用户自定义函数由CREATE FUNCTION语句来定义，分为以下几种类型。 （1）标量函数的定义和引用 　　标量函数是指返回值为标量值的函数。其语法格式如下： CREATE FUNCTION [ schema_name. ] function_name ( [ { @parameter_name [ AS ][ type_schema_name. ] parameter_data_type [ = default ] } [ ,...n ] ] ) RETURNS return_data_type [ WITH [ ,...n ] ] [ AS ] BEGIN function_body RETURN scalar_expression END [ ; ] ::= { [ ENCRYPTION ] | [ SCHEMABINDING ] | [ RETURNS NULL ON NULL INPUT | CALLED ON NULL INPUT ] | [ EXECUTE_AS_Clause ] } 从上述语法形式可归纳出标量函数的一般定义形式如下： CREATE FUNCTION [所有者名.] 函数名 ( 参数1 [AS] 类型1 [ = 默认值 ] ) [ ,...参数n [AS] 类型n [ = 默认值 ] ] ] ) RETURNS 返回值类型 [ WITH 选项 ] [ AS ] BEGIN 函数体 RETURN 标量表达式 END 其中：  schema_name为架构名称。  function_name为用户定义的函数名，它必须符合SQL Server标识符的规则，在架构schema_name中是唯一的。  @parameter_name为用户定义的形式参数的名称，可以声明一个或者多个参数，parameter_data_type为参数的类型。  function_body表示函数体，即Transact-SQL语句块，是函数的主体部分。  在项中，ENCRYPTION用于指示数据库引擎对包含CREATE FUNCTION语句文本的目录视图列进行加密，以防止将函数作为SQL Server复制的一部分发布；SCHEMABINDING指定将函数绑定到其引用的数据库对象，如果其他架构绑定对象也在引用该函数，此条件将防止对其进行更改。  如果定义了 default 值，则无需指定此参数的值即可执行函数。  EXECUTE AS 子句用于指定用于执行用户定义函数的安全上下文。 构造一个函数，使之能够根据学号从表SC中计算学生已选课程的平均成绩。 USE MyDatabase; GO IF OBJECT_ID(N'dbo.get_avgrade', N'FN') IS NOT NULL DROP FUNCTION dbo.get_avgrade; -- 如果已存在名为get_avgrade的函数则将其删除 GO CREATE FUNCTION dbo.get_avgrade(@s_no varchar(8)) RETURNS float AS BEGIN DECLARE @value float; SELECT @value = AVG(c_grade) FROM sc WHERE s_no = @s_no RETURN @value; END 创建用户定义函数，实现计算全体学生某门功课平均成绩的功能。 USE PXSCJ GO CREATE FUNCTION average(@cnum char(20)) RETURNS int AS BEGIN DECLARE @aver int SELECT @aver= ( SELECT avg(成绩) FROM CJB WHERE 课程号=@cnum GROUP BY 课程号 ) RETURN @aver END GO 标量函数的调用。当调用用户定义的标量函数时，必须提供至少由两部分组成的名称（架构名.函数名）。 对于用户自定义函数，其调用方法与变量的引用方式一样。可用以下方式调用标量函数。 ① 在SELECT语句中调用。 在SELECT或者PRINT语句中调用函数 调用形式：架构名.函数名(实参1,…,实参n)。 实参可为已赋值的局部变量或表达式。 【例5.34】 调用例5.33定义的函数average。 USE PXSCJ /*假设用户函数average在此数据库中已定义*/ GO DECLARE @course1 char(20) /*定义局部变量*/ DECLARE @aver1 int SELECT @course1 = '101‘ /*给局部变量赋值*/ SELECT @aver1=dbo.average(@course1) /*调用用户函数，并将返回值赋给局部变量*/ SELECT @aver1 AS '101课程的平均成绩'/*显示局部变量的值*/ 执行结果如下： 101课程的平均成绩 ------ 79 【例子】 可以用下列语句调用自定义函数get_avgrade： DECLARE @SS varchar(8); SET @SS = '20170202' SELECT dbo.get_avgrade(@SS) --或者， SELECT dbo.get_avgrade('20170202') --如果仅仅用于打印输出，可以将上述的关键字SELECT改为PRINT，也有同样的效果。 ② 利用SET语句执行函数 在SET语句中，函数被当作一个表达式进行计算，然后将返回值赋给指定的变量。 DECLARE @V float SET @V = dbo.get_avgrade('20170202') 3.利用EXEC语句执行。 在用T-SQL EXECUTE（EXEC）语句调用用户函数时，参数的标识次序与函数定义中的参数标识次序可以不同。 调用形式： 架构名.函数名 实参1,…,实参n 或 架构名.函数名 形参名1=实参1,…, 形参名n=实参n 【例5.35】 调用例5.33中计算平均成绩的函数。 DECLARE @course1 char(20) DECLARE @aver1 int EXEC @aver1 = dbo.average @cnum = '101' /*通过EXEC调用函数，将返回值赋给局部变量*/ SELECT @aver1 AS '101课程的平均成绩' /*显示局部变量的值*/ （2）内联表值函数  内联表值函数返回的结果是一张数据表，而不是一个标量值。其语法如下： CREATE FUNCTION [ schema_name. ] function_name /*定义函数名部分*/ ( [ { @parameter_name [ AS ] [ type_schema_name. ] parameter_data_type [ = default ] } [ ,...n ] ]) /*定义参数部分*/ RETURNS TABLE /*返回值为表类型*/ [ WITH [ ,...n ] ] /*定义函数的可选项*/ [ AS ] RETURN [ ( ] select_stmt [ ) ] /*通过SELECT语句返回内嵌表*/ [ ; ] RETURNS子句仅包含关键字TABLE，表示此函数返回一个表。内嵌表值函数的函数体仅有一个RETURN语句，并通过参数select-stmt指定的SELECT语句返回内嵌表值。语法格式中的其他参数项与标量函数的定义类似。 可以看到，该函数返回结果是TABLE类型数据（是一张表），且没有函数主体（BEGIN…END部分），而标量函数返回的是一个标量值，有自己的函数主体。 【例子】 定义内联表值函数。该函数的作用是按学号查询学生的学号、姓名和系别，其输入参数是学号，返回结果是由学号、姓名和系别构成的表。 USE MyDatabase; GO IF OBJECT_ID(N'dbo.get_SND', N'IF') IS NOT NULL DROP FUNCTION dbo.get_SND; GO CREATE FUNCTION dbo.get_SND(@s_no varchar(8)) RETURNS TABLE AS RETURN ( SELECT s_no, s_name, s_dept FROM student WHERE s_no = @s_no );  由于内联表值函数返回结果是一张表，所以对其调用必须按照对表的查询方式进行，其调用方法与标量函数的调用方法完全不同。内嵌表值函数的调用。内嵌表值函数只能通过SELECT语句调用，内嵌表值函数调用时，可以仅使用函数名。 【例子】 以下是调用函数get_SND的一条SELECT语句，在此函数get_SND是被当作一张表来使用的： SELECT * FROM dbo.get_SND('20170203')  内联表值函数返回的结果是一张“数据表”，而其本身并不保存数据。在这个意义上，内联表值函数与视图是一样的，而且也可以像对视图那样对其进行查询操作。其优点是它可以带参数，而视图不能带参数，但它不具备视图的全部功能。可以这样简要理解：内联表值函数是带参数的“视图”。 内嵌表值函数 内嵌函数可用于实现参数化视图。例如，有如下视图： CREATE VIEW View1 AS SELECT 学号, 姓名 FROM PXSCJ.dbo.XSB WHERE 专业= '计算机' 若希望设计更通用的程序，让用户能指定感兴趣的查询内容，可将“WHERE 专业= '计算机' ”替换为“WHERE 专业= @para”，@para用于传递参数。 由于视图不支持在WHERE子句中指定搜索条件参数，为解决这一问题，我们可使用内嵌用户定义函数，脚本如下： /*内嵌函数的定义*/ CREATE FUNCTION fn_View1( @Para nvarchar(30) ) RETURNS table AS RETURN ( SELECT 学号, 姓名 FROM PXSCJ.dbo.XSB WHERE 专业= @para ) GO /*内嵌函数的调用*/ SELECT * FROM fn_View1 ('计算机') 【例5.37】 对于PXSCJ数据库，为了让学生查询其各科成绩及学分，可以利用XSB、KCB、CJB三个表创建视图。程序如下： CREATE VIEW ST_VIEW AS SELECT dbo.XSB.学号, dbo.XSB.姓名, dbo.KCB.课程名, dbo.CJB.成绩 FROM dbo.KCB INNER JOIN dbo.CJB ON dbo.KCB.课程号 = dbo.CJB.课程号 INNER JOIN dbo.XSB ON dbo.CJB.学号 = dbo.XSB.学号 然后在此基础上定义如下内嵌函数： CREATE FUNCTION st_score(@student_ID char(6)) RETURNS table AS RETURN ( SELECT * FROM PXSCJ.dbo.ST_VIEW WHERE dbo. ST_VIEW.学号= @student_ID ) 在此，以前面定义的st_score()内嵌表值函数的调用作为应用举例，学生通过输入学号调用内嵌函数查询其成绩。 【例5.38】 调用st_score()函数，查询学号为081101的学生的各科成绩及学分。 SELECT * FROM PXSCJ.[dbo].st_score('081101') 执行结果如下： （3）多语句表值函数  多语句表值函数返回结果也是一张表，但与内联表值函数不同的是：在内联表值函数中，TABLE返回值是通过单个SELECT语句定义的，内联函数没有关联的返回变量。  在多语句表值函数中，@return_variable是TABLE类型的返回变量，用于存储和汇总应作为函数值返回的行。  多语句表值函数返回结果的原理是，先定义一个表变量，然后通过函数体中的语句实现向该表变量插入有关数据，最后将这个表变量作为结果返回。 多语句表值函数的语法如下： CREATE FUNCTION [ schema_name. ] function_name /*定义函数名部分*/ ( [ { @parameter_name [ AS ] [ type_schema_name. ] parameter_data_type [ = default ] } [ ,...n ] ]) /*定义函数参数部分*/ RETURNS @return_variable TABLE /*定义作为返回值的表*/ [ WITH [ ,...n ] ] /*定义函数的可选项*/ [ AS ] BEGIN function_body /*定义函数体*/ RETURN END [ ; ] 其中， :: = /*定义表，参考第3章*/ ( { } [ ] [ ,...n ] )  @return_variable为TABLE类型变量，用于存放函数返回的表。  多语句表值函数与标量函数都有函数的主体部分（function_body），它是由一系列定义函数值的Transact-SQL语句组成。在多语句表值函数中，function_body是一系列用于填充TABLE返回变量@return_variable的Transact-SQL 语句；在标量函数中，function_body是一系列用于计算标量值的Transact-SQL 语句。 【例6.16】 下例是一个多语句表值函数，其作用是按学号查询学生的一些基本信息。这些信息包括学号、姓名、专业、系别和平均成绩，其平均成绩是计算列，它由学生已选修的课程及课程成绩来决定。学生选修课程记录于表SC中。 该函数名为get_stu_info，带一个参数，其定义代码如下： USE MyDatabase; GO IF OBJECT_ID (N'dbo.get_stu_info', N'TF') IS NOT NULL DROP FUNCTION dbo.get_stu_info; GO CREATE FUNCTION dbo.get_stu_info(@no char(8)) RETURNS @stu_info TABLE -- 定义表变量 ( s_no char(8), s_name char(8), s_speciality varchar(50), s_dept varchar(50), s_avgrade numeric(3,1) ) AS BEGIN INSERT @stu_info -- 插入查询信息 SELECT s_no,s_name,s_speciality,s_dept,s_avgrade=( /*从表SC中生成计算列s_avgrade */ SELECT AVG(c_grade) FROM SC WHERE SC.s_no = student.s_no ) FROM student WHERE s_no=@no RETURN END 【例5.39】 在PXSCJ数据库中创建返回表的函数，通过以学号作为实参调用该函数，可显示该学生各门功课的成绩和学分。 CREATE FUNCTION score_table(@id char(6)) RETURNS @score TABLE ( xs_ID char(6), xs_Name char(8), kc_Name char(16), cj tinyint, xf tinyint ) AS BEGIN INSERT @score SELECT S.学号, S.姓名,P.课程名,O.成绩, P.学分 FROM PXSCJ.[dbo].XSB AS S INNER JOIN PXSCJ.[dbo].CJB AS O ON (S.学号= O.学号) INNER JOIN PXSCJ.[dbo].KCB AS P ON (O.课程号= P.课程号) WHERE S.学号=@id RETURN END  多语句表值函数的调用与内联表值函数的调用方法一样。 【例子】要查询学号为'20170201'的学生信息，可以按照下列方式调用函数get_stu_info： SELECT * FROM dbo.get_stu_info('20170201'); 以下例子是上述多语句表值函数score_table()的调用。 【例5.40】 以下语句查询学号为081101的学生的各科成绩和学分。 SELECT * FROM PXSCJ.[dbo].score_table('081101') 执行结果如下：  对于一个已创建的用户定义函数，可有两种方法删除： （1）通过对象资源管理器删除，此方法非常简单，请读者自己练习。 （2）利用T-SQL语句DROP FUNCTION删除，下面介绍其语法格式。 语法格式： DROP FUNCTION { [ schema_name. ] function_name } [ ,...n ] 用户自定义函数的删除实际上在上述介绍的例子中已经接触过了，即用DROP FUNCTION来实现对函数的删除。 【例子】 删除函数get_stu_info可以使用下列语句来完成： DROP FUNCTION dbo.get_stu_info; "},"page/11317.html":{"url":"page/11317.html","title":"配置函数","keywords":"","body":"配置函数 "},"page/11318.html":{"url":"page/11318.html","title":"MSSQL","keywords":"","body":"MSSQL配置函数 配置函数用于返回当前配置选项设置的信息。全局变量是以函数形式使用的，配置函数一般都是全局变量名 "},"page/11340.html":{"url":"page/11340.html","title":"游标函数","keywords":"","body":"游标函数 "},"page/11341.html":{"url":"page/11341.html","title":"MSSQL","keywords":"","body":"SQL Server 6．游标函数 游标函数用于返回有关游标的信息。主要的游标函数如下。 （1）@@CURSOR_ROWS函数。语法格式： @@CURSOR_ROWS 返回最后打开的游标中当前存在的满足条件的行数。返回值为0表示游标未打开；为-1表示游标为动态游标；为-m表示游标被异步填充，返回值（-m）是键集中当前的行数；为n表示游标已完全填充，返回值（n）是游标中的总行数。 【例5.31】 声明一个游标，并用SELECT显示@@CURSOR_ROWS 的值。 USE PXSCJ GO SELECT @@CURSOR_ROWS DECLARE student_cursor CURSOR FOR SELECT 姓名 FROM XSB OPEN student_cursor FETCH NEXT FROM student_cursor SELECT @@CURSOR_ROWS CLOSE student_cursor DEALLOCATE student_cursor （2）CURSOR_STATUS函数。语法格式： CURSOR_STATUS (  { 'local' , 'cursor_name' } /*指明数据源为本地游标*/ | { 'global' , 'cursor_name' } /*指明数据源为全局游标*/ | { 'variable' , 'cursor_variable' } /*指明数据源为游标变量*/ ) 结果显示游标状态是打开还是关闭。常量字符串local、global用于指定游标的类型，local表示为本地游标名，global表示为全局游标名。参数cursor_name用于指定游标名，常量字符串variable用于说明其后的游标变量为一个本地变量，参数cursor_variable为本地游标变量名称，返回值类型为smallint。 CURSOR_STATUS()函数返回值如表5.16所示。 CURSOR_STATUS返回值列表 返 回 值 游标名或游标变量 返 回 值 游标名或游标变量 1 游标的结果集至少有一行 -2 游标不可用 0 游标的结果集为空* -3 指定的游标不存在 -1 游标被关闭 （3）@@FETCH_STATUS函数。语法格式： @@FETCH_STATUS 返回FETCH语句执行后游标的状态。@@FETCH_STATUS返回值如表5.17所示 @@FETCH_STATUS返回值列表 返 回 值 说 明 返 回 值 说 明 0 FETCH 语句执行成功 -2 被读取的记录不存在 -1 FETCH 语句执行失败 【例5.32】 用@@FETCH_STATUS控制在一个WHILE循环中的游标活动。 USE PXSCJ GO DECLARE @name char(20), @st_id char(6) DECLARE Student_Cursor CURSOR FOR SELECT 姓名,学号 FROM PXSCJ.dbo.XSB OPEN Student_Cursor FETCH NEXT FROM Student_Cursor INTO @name, @st_id SELECT @name, @st_id WHILE @@FETCH_STATUS = 0 BEGIN FETCH NEXT FROM Student_Cursor END CLOSE Student_Cursor DEALLOCATE Student_Cursor "},"page/11342.html":{"url":"page/11342.html","title":"游标函数","keywords":"","body":"游标函数 "},"page/11343.html":{"url":"page/11343.html","title":"MSSQL","keywords":"","body":"MSSQL 元数据函数 元数据是用于描述数据库和数据库对象的。元数据函数用于返回有关数据库和数据库对象的信息。 （1）DB_ID函数。语法格式： DB_ID ( [ 'database_name' ] ) 系统在创建数据库时，自动为其创建一个标识号。函数DB_ID根据database_name指定的数据库名，返回其数据库标识（ID）号。如果参数database_name不指定，则返回当前数据库ID，返回值类型为smallint。 （2）DB_NAME函数。语法格式： DB_NAME ( database_id ) 根据参数database_id所给的数据库标识号，返回数据库名。参数database_id 类型为 smallint，如果没有指定数据库标识号，则返回当前数据库名。返回值类型为nvarchar(128)。 "},"page/11047.html":{"url":"page/11047.html","title":"流程设计","keywords":"","body":"流程设计 "},"page/11303.html":{"url":"page/11303.html","title":"MSSQL流程设计","keywords":"","body":"MSSQL流程设计 在设计程序时，常常需要利用各种流程控制语句，改变计算机的执行流程以满足程序设计的需要。在SQL Server中提供了如表所示的流程控制语句。 SQL Server流程控制语句 控 制 语 句 说 明 控 制 语 句 说 明 BEGIN…END 语句块 CONTINUE 用于重新开始下一次循环 IF…ELSE 条件语句 BREAK 用于退出最内层的循环 CASE 分支语句 RETURN 无条件返回 GOTO 无条件转移语句 WAITFOR 为语句的执行设置延迟 WHILE 循环语句 "},"page/11048.html":{"url":"page/11048.html","title":"语句块","keywords":"","body":"语句块 语句块是程序中一个相对独立的执行单元，它是由关键字BEGIN…END括起来而形成的代码段。其中，BEGIN用于标识语句块的开始，END则标识语句块的结束。语句块可以嵌套定义。 　　语句块通常与IF、WHILE等控制语句一起使用，以界定这些控制语句的作用范围。这在下面介绍控制语句的部分会涉及到。 "},"page/11107.html":{"url":"page/11107.html","title":"MSSQL","keywords":"","body":"SQL Server 语句块 语句块是程序中一个相对独立的执行单元，它是由关键字BEGIN…END括起来而形成的代码段。其中，BEGIN用于标识语句块的开始，END则标识语句块的结束。语句块可以嵌套定义。语 句块通常与IF、WHILE等控制语句一起使用，以界定这些控制语句的作用范围。这在下面介绍控制语句的部分会涉及到。 类似与高级语言的大括号 在T-SQL中可以定义BEGIN…END语句块。当要执行多条T-SQL语句时，就需要使用BEGIN…END将这些语句定义成一个语句块，作为一组语句来执行。语法格式如下： BEGIN { sql_statement | statement_block } END 关键字BEGIN是T-SQL语句块的起始位置，END标识同一个T-SQL语句块的结尾。sql_statement是语句块中的T-SQL语句。BEGIN…END可以嵌套使用，statement_block表示使用BEGIN…END定义的另一个语句块。 例如， USE PXSCJ GO BEGIN SELECT * FROM XSB SELECT * FROM KCB END "},"page/11108.html":{"url":"page/11108.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11049.html":{"url":"page/11049.html","title":"顺序","keywords":"","body":"顺序 "},"page/11109.html":{"url":"page/11109.html","title":"MSSQL","keywords":"","body":"SQL Server "},"page/11110.html":{"url":"page/11110.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11050.html":{"url":"page/11050.html","title":"选择","keywords":"","body":"选择 "},"page/11051.html":{"url":"page/11051.html","title":"条件语句--IF语句","keywords":"","body":"条件语句--IF语句 "},"page/11111.html":{"url":"page/11111.html","title":"MSSQL","keywords":"","body":"SQL Server 2 IF语句 　　 SQL Server支持两种形式的IF语句：IF…和IF…ELSE…句型。 2.1 IF…句型 该句型的语法格式如下： IF expression { sql_statement | statement_block } ​ expression为布尔表达式，如果该表达式中含有 SELECT 语句，必须用圆括号将 SELECT 语句括起来；sql_statement表示SQL语句；statement_block表示语句块（下同）。如果expression的返回值为TRUE，则执行IF后面的语句或语句块，否则什么都不执行。 IF语句的结构流程图如图6.2所示。 【例5.17】 如果“计算机基础”课程的平均成绩高于75分，则显示“平均成绩高于75分”。 IF ( SELECT AVG(成绩) FROM XSB, CJB, KCB WHERE XSB.学号= CJB.学号 AND CJB.课程号=KCB.课程号 AND KCB.课程名='计算机基础' ) 2.2 IF…ELSE…句型 　　有时候在作出判断以后，对不满足条件表达式的情况也要进行相应的处理，这时可以选用IF…ELSE…句型。其语法格式如下： IF expression { sql_statement1 | statement_block1 } ELSE { sql_statement2 | statement_block2} 　　该语句的结构流程图如图所示。 对于给定学号的查询，如果平均成绩不及格的则打印姓名和平均成绩，否则打印学号即可。实现代码如下： USE MyDatabase GO DECLARE @no char(8), @name char(8), @avgrade numeric(3,1) SET @no = '20170202' SELECT @name = s_name, @avgrade = s_avgrade FROM student WHERE s_no = @no; IF @avgrade【例5.18】 IF…ELSE语句的嵌套使用。 IF ( SELECT AVG(成绩) FROM XSB, CJB, KCB WHERE XSB.学号= CJB.学号 AND CJB.课程号=KCB.课程号 AND KCB.课程名='计算机基础' ) 75 SELECT '平均成绩高于75' 2.3 IF … ELSE IF … ELSE …句型 　　 当需要作两次或两次以上的判断并根据判断结果作出执行选择时，一般要使用IF … ELSE IF … ELSE …句型。该句型的语法格式如下： IF expression1 { sql_statement1 | statement_block1 } ELSE IF expression2 {sql_statement2 | statement_block2} [ELSE IF expression3 {sql_statement3 | statement_block3} …] ELSE {sql_statementn | statement_blockn} 上述语句的结构流程图如图6.4所示。 运用多分支的IF句型来查询并实现分等级打印学生成绩。 USE MyDatabase GO DECLARE @no char(8), @name char(8), @avgrade numeric(3,1) SET @no = '20170202' SELECT @name = s_name, @avgrade = s_avgrade FROM student WHERE s_no = @no; IF @avgrade>=90.0 PRINT '优秀' ELSE IF @avgrade>=80.0 PRINT '良好' ELSE IF @avgrade>=70.0 PRINT '中等' ELSE IF @avgrade>=60.0 PRINT '及格' ELSE PRINT '不及格' GO "},"page/11112.html":{"url":"page/11112.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11052.html":{"url":"page/11052.html","title":"多重分支--CASE语句","keywords":"","body":"多重分支--CASE语句 "},"page/11113.html":{"url":"page/11113.html","title":"MSSQL","keywords":"","body":"SQL Server 3 CASE语句 　　IF语句一般用于一个判断有少量出口（特别是两个出口）的情况。但在许多时候可能遇到一个判断有很多出口的情况，这时如果仍然使用IF语句，可能使得语句在结构上变得非常复杂。但如果换用CASE语句，将使得语句代码变得很精炼、简洁。　　在SQL Server中，CASE语句实际上是被当作一个函数来执行，执行后都有一个返回值。它有两种类型，一种是简单式，一种是搜索式。 3.1简单式CASE函数　　 以下是简单式CASE函数的语法格式： CASE input_expression WHEN when_expression THEN result_expression [ ...n ] [ ELSE else_result_expression ] END 相当于高级语言的switch 　　执行时，首先计算表达式input_expression的值，然后将计算结果与WHEN子句中的表达式进行比较，如果相等则计算THEN后面的表达式result_expression，并将得到的值作为整个CASE函数的值，同时退出CASE函数；如果结果与所有WHEN子句中的表达式的值都不相等，则计算ELSE后面的表达式else_result_expression。不管最后是计算哪个表达式，它的结果都将作为整个CASE函数的返回值。 　　when_expression 是任意有效的表达式。但input_expression 及每个WHEN 子句中的表达式when_expression的数据类型必须相同或是可隐式转换的数据类型。 【例6.9】 首先使用SELECT语句查询学生的学号，然后用CASE函数对学生的姓名和爱好进行简要说明。 实现代码如下： SELECT 学号 = s_no, 姓名及爱好 = CASE s_no WHEN '20170201' THEN '刘洋，游泳' WHEN '20170202' THEN '王晓珂，登山' WHEN '20170203' THEN '王伟志，滑雪' WHEN '20170204' THEN '岳志强，支部书记' WHEN '20170205' THEN '贾簿，足球' WHEN '20170206' THEN '李思思，爱好不详' WHEN '20170207' THEN '蒙恬，长跑' WHEN '20170208' THEN '张宇，山地自行车' ELSE '没有这个人' END FROM student 该语句执行后结果如下： 学号 姓名及爱好 -------------------------------------------- 20170201 刘洋，游泳 20170202 王晓珂，登山 20170203 王伟志，滑雪 20170204 岳志强，支部书记 20170205 贾簿，足球 20170206 李思思，爱好不详 20170207 蒙恬，长跑 20170208 张宇，山地自行车 3.2搜索式CASE函数 　　以下是搜索式CASE函数的语法格式： CASE WHEN expression THEN result_expression [ ...n ] [ ELSE else_result_expression ] END 相当于高级语言的if-else-if-else ​ 在搜索式CASE函数中，关键字CASE后面没有表达式，且WHEN后面的表达式expression已被限定为布尔表达式（返回值为TRUE或FALSE）。执行时，依次从上到下计算每个WHEN子句中表达式expression的值，如果值为TRUE则计算该WHEN子句中表达式result_expression的值，并将该值返回作为CASE函数的值；如果所有WHEN子句中表达式expression的值均为FALSE，则计算ELSE后面表达式else_result_expression的值并将其返回作为CASE函数的值。 【例6.10】 使用搜索式CASE函数来显示学生的成绩等级。 相应代码如下： SELECT 学号 = s_no, 姓名 = s_name, 成绩等级 = CASE WHEN s_avgrade>90.0 THEN '优秀' WHEN s_avgrade>80.0 THEN '良好' WHEN s_avgrade>70.0 THEN '中等' WHEN s_avgrade>60.0 THEN '及格' ELSE '不及格' END FROM student 该语句执行后结果如下： 学号 姓名 成绩等级 ------------------------------------------------- 20170201 刘洋 优秀 20170202 王晓珂 良好 20170203 王伟志 良好 20170204 岳志强 中等 20170205 贾簿 不及格 20170206 李思思 及格 20170207 蒙恬 中等 20170208 张宇 不及格 【例6.11】 为保证指导学生的质量，现在很多高校都从工作量上限制教师指导学生的人数。假设某高校制定如下的指导工作量公式，其中n为指导的学生人数： ​ 指导工作量 = 要求用上述公式重新定义表示工作量的字段c_hour，其他字段不变。 根据上述要求，为表supervisor 重新编写CREATE TABLE语句代码，结果如下： CREATE TABLE supervisor( t_no int PRIMARY KEY, t_name varchar(8) NOT NULL, s_n int NOT NULL CHECK(s_n>=0 and s_n　用上述CREATE TABLE语句重新创建数据表supervisor，然后用下列INSERT语句添加数据： insert supervisor values('19970101','方琼',7) insert supervisor values('19970102','赵构',9) insert supervisor values('19970103','李方正',15) 结果表supervisor中的数据如下： t_no t_name s_n c_hour --------------------------------------------------------------- 19970101 方琼 7 105 19970102 赵构 9 132 19970103 李方正 15 149 ​ 可以看到，只要正确设置字段s_n的值，工作量字段c_hour的值会自动计算产生。在软件开发中，如果能够灵活地利用CASE函数定义计算列，可以大大较少前台代码的编写工作量。 "},"page/11114.html":{"url":"page/11114.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11053.html":{"url":"page/11053.html","title":"循环","keywords":"","body":"循环 "},"page/11054.html":{"url":"page/11054.html","title":"WHILE语句","keywords":"","body":"WHILE语句 "},"page/11115.html":{"url":"page/11115.html","title":"MSSQL","keywords":"","body":"SQL Server WHILE语句 WHILE语句是典型的循环控制语句，其语法格式如下： WHILE expression /*条件表达式*/ {sql_statement | statement_block} /*T-SQL语句序列构成的循环体*/ 　　在WHILE语句中，只要表达式expression的值为真，就重复执行循环体中的语句。如果布尔表达式中含有SELECT语句，则必须用括号将SELECT语句括起来。 　　 WHILE语句也可以结合BREAK和CONTINUE语句一起使用，它们可以嵌入循环体内部，用于控制WHILE循环中语句的执行。 　　其中，当执行到BREAK语句时，程序将无条件退出当前的循环体，执行出现在END关键字（循环体结束的标记）后面的语句； 　　当执行到CONTINUE语句时，程序将不执行CONTINUE关键字后面的所有语句，提前结束本次循环（但没有退出循环体，这是与BREAK语句的不同之处），并重新开始新的一轮循环。 WHILE语句的结构流程图如图所示。 【例6.12】 如果学生成绩的平均值低于95分则循环执行对每个学生的成绩增加0.5%。在循环过程中，如果发现最高成绩超过99分则退出循环；在加分过程中，当成绩的平均值大于或等于75.5分时打印出当前成绩的平均值。 USE MyDatabase; GO DECLARE @max numeric(3,1),@avg numeric(3,1); SET @avg = (SELECT AVG(s_avgrade) FROM student) SET @max = (SELECT MAX(s_avgrade) FROM student) WHILE @avg 99 BREAK --退出循环体 UPDATE student SET s_avgrade = s_avgrade + s_avgrade * 0.005 SET @avg = (SELECT AVG(s_avgrade) FROM student) SET @max = (SELECT MAX(s_avgrade) FROM student) IF @avg 将学号为081101的学生的总学分使用循环修改到60，每次只加2，并判断循环了多少次。 USE PXSCJ GO DECLARE @num INT SET @num=0 WHILE (SELECT 总学分 FROM XSB WHERE 学号='081101') "},"page/11116.html":{"url":"page/11116.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11055.html":{"url":"page/11055.html","title":"BREAK/CONTINUE语句","keywords":"","body":"BREAK/CONTINUE语句 "},"page/11117.html":{"url":"page/11117.html","title":"MSSQL","keywords":"","body":"SQL Server BREAK语句 语法格式： BREAK BREAK语句一般用在循环语句中，用于退出本层循环。当程序中有多层循环嵌套时，使用BREAK语句只能退出其所在的这一层循环。 CONTINUE语句 语法格式： CONTINUE CONTINUE语句一般用在循环语句中，用于结束本次循环，重新转到下一次循环条件的判断。 "},"page/11118.html":{"url":"page/11118.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11056.html":{"url":"page/11056.html","title":"高级","keywords":"","body":"高级 "},"page/11057.html":{"url":"page/11057.html","title":"无条件转移--GOTO语句","keywords":"","body":"无条件转移--GOTO语句 "},"page/11119.html":{"url":"page/11119.html","title":"MSSQL","keywords":"","body":"SQL Server GOTO语句 　　GOTO语句是一种无条件转移语句，可以实现程序的执行流程从一个地方转移到另外的任意一个地方。与IF语句结合，GOTO语句也可以实现WHILE语句的循环功能。但是使用GOTO语句会降低程序的可读性，所以在一般情况下不提倡在程序中使用GOTO语句。 使用GOTO语句时，首先要定义标签，然后才能使用GOTO语句。其语法格式如下： Label: {sql_statement | statement_block} [IF …] GOTO Label; 　　其中，Label为定义的标签，它是GOTO语句转向的依据。 　　标签必须符合标识符命名规则。无论是否使用 GOTO 语句，标签均可作为注释方法使用。 　　当执行到语句“GOTO Label”时，执行流程将无条件转到标签Label所指向的地址，并从该地址起依次往下执行所遇到的语句。 【例6.13】 使用了GOTO语句来实现1到100的累加，结果放在局部变量@sum中，最后将结果打印出来。 DECLARE @s int, @sum int SET @s = 0 SET @sum = 0 label1: SET @s = @s + 1 SET @sum = @sum + @s IF @s <> 100 GOTO label1 PRINT @sum "},"page/11120.html":{"url":"page/11120.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11058.html":{"url":"page/11058.html","title":"返回语句--RETURN语句","keywords":"","body":"返回语句--RETURN语句 "},"page/11121.html":{"url":"page/11121.html","title":"MSSQL","keywords":"","body":"SQL Server RETURN语句 　　RETURN语句用于从过程、批处理或语句块中无条件退出，RETURN之后的语句不被执行。其语法如下： RETURN [integer_expression] 　　RETURN可以后跟整型表达式，当执行到RETURN语句的时候先计算该表达式的值，然后返回该值。 ​ 如果不提供integer_expression，则退出程序并返回一个空值；如果用在存储过程中，则可以返回整型值integer_expression。 　　如果将RETURN语句嵌入存储过程，该语句不能返回空值。 　　如果某个过程试图返回空值，则将生成警告消息并返回0值。 判断是否存在学号为081128的学生，如果存在则返回，不存在则插入081128号学生的信息。 IF EXISTS(SELECT * FROM XSB WHERE 学号='081128') RETURN ELSE INSERT INTO XSB VALUES('081128', '张可', 1, '1990-08-12', '计算机',52, NULL) "},"page/11122.html":{"url":"page/11122.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11059.html":{"url":"page/11059.html","title":"错误处理--TRY…CATCH语句","keywords":"","body":"错误处理--TRY…CATCH语句 TRY…CATCH语句 　　类似于其他高级语言，Transact-SQL也有异常的捕获和处理语句——TRY…CATCH语句。该语句的语法格式如下： BEGIN TRY { sql_statement | statement_block } END TRY BEGIN CATCH { sql_statement | statement_block } END CATCH[ ; ] 　　当TRY块内的语句产生错误时，则会将控制传递给CATCH块的第一个语句；当TRY块所包含的代码中没有错误时，则在TRY块中最后一个语句完成后将控制传递给紧跟在END CATCH 语句之后的语句。 【例子】下例中第二条插入语句有错误，所以在执行到该语句时程序将转到CATCH块中执行打印语句。这时第一条插入语句已经成功执行，而第三条插入语句则未能执行到，所以只有第一条数据被插入，而其他数据没有被插入到数据库中。 USE MyDatabase; GO DELETE FROM student GO BEGIN TRY INSERT student VALUES('20170201','刘洋','女','1997-02-03','计算机应用技术',98.5,'计算机系'); -- 下面语句中，时间常量'1997-09-201'格式错误 INSERT student VALUES('20170202','王晓珂','女','1997-09-201','计算机软件与理论',88.1,'计算机系'); INSERT student VALUES('20170203','王伟志','男','1996-12-12','智能科学与技术',89.8,'智能技术系'); END TRY BEGIN CATCH PRINT N'插入操作有错误。' END CATCH; "},"page/11123.html":{"url":"page/11123.html","title":"MSSQL","keywords":"","body":"SQL Server 在SQL Server 2008中，可以使用TRY…CATCH语句进行T-SQL语言中的错误处理。 语法格式： BEGIN TRY { sql_statement | statement_block } END TRY BEGIN CATCH [ { sql_statement | statement_block } ] END CATCH [ ; ] 当TRY块内的语句产生错误时，则会将控制传递给CATCH块的第一个语句；当TRY块所包含的代码中没有错误时，则在TRY块中最后一个语句完成后将控制传递给紧跟在END CATCH 语句之后的语句。 【例子】下例中第二条插入语句有错误，所以在执行到该语句时程序将转到CATCH块中执行打印语句。这时第一条插入语句已经成功执行，而第三条插入语句则未能执行到，所以只有第一条数据被插入，而其他数据没有被插入到数据库中。 USE MyDatabase; GO DELETE FROM student GO BEGIN TRY INSERT student VALUES('20170201','刘洋','女','1997-02-03','计算机应用技术',98.5,'计算机系'); -- 下面语句中，时间常量'1997-09-201'格式错误 INSERT student VALUES('20170202','王晓珂','女','1997-09-201','计算机软件与理论',88.1,'计算机系'); INSERT student VALUES('20170203','王伟志','男','1996-12-12','智能科学与技术',89.8,'智能技术系'); END TRY BEGIN CATCH PRINT N'插入操作有错误。' END CATCH; "},"page/11124.html":{"url":"page/11124.html","title":"Mysql","keywords":"","body":"Mysql "},"page/11060.html":{"url":"page/11060.html","title":"等待语句--WAITFOR语句","keywords":"","body":"等待语句--WAITFOR语句 "},"page/11125.html":{"url":"page/11125.html","title":"MSSQL","keywords":"","body":"SQL Server WAITFOR语句 　　WAITFOR语句用于设置指定程序段的执行时间，包括指定程序段在某一时刻执行或者在某一段时间间隔之后自动执行。其语法格式如下： WAITFOR { DELAY 'time_to_pass' | TIME 'time_to_execute' } 　　DELAY子句用于设定WAITFOR语句所要等待的时间（这个时间过后即执行WAITFOR后面的语句），时间的长短由参数time_to_pass说明（但只能包含时间部分，不能包含日期部分），最长为24小时；TIME子句用于设定WAITFOR语句等待的终结时刻，由参数time_to_execute说明，可以使用datetime数据类型接受的格式，但也只能包含时间部分。 设置在下午5:30（17:30）执行学生成绩查询。 USE MyDatabase; GO WAITFOR TIME '17:30'; SELECT 姓名 = s_name, 平均成绩 = s_avgrade FROM student 如果要求上述查询在1小时20分钟后执行，则可以使用下面的代码实现： USE MyDatabase; GO WAITFOR DELAY '01:20'; SELECT 姓名 = s_name, 平均成绩 = s_avgrade FROM student; 如下语句设定在早上8点执行查询语句。 BEGIN WAITFOR TIME '8:00' SELECT * FROM XSB END "},"page/11126.html":{"url":"page/11126.html","title":"Mysql","keywords":"","body":"SQL 什么是SQL语言 SQL语言的全名是结构化查询语言（Structured Query Language），是用于数据库中的标准数据查询语言，IBM公司最早使用该语言在其开发的数据库系统中。1986年10月，美国ANSI对 SQL进行规范后，以此作为关系数据库管理系统的标准语言。 作为关系数据库的标准语言，它已被众多商用数据库管理系统产品所采用，不过，不同的数据库管理系统在其实践过程中都对SQL规范做了某些改变和扩充。所以，实际上，不同数据库管理系统之间的SQL语言不能完全通用。例如，微软公司的MS SQL-Server支持的是T-SQL，而甲骨文公司的Oracle 数据库所使用的SQL语言则是PL-SQL。 "},"page/11344.html":{"url":"page/11344.html","title":"高级","keywords":"","body":""},"page/19999.html":{"url":"page/19999.html","title":"end11346","keywords":"","body":"end11201 "}}